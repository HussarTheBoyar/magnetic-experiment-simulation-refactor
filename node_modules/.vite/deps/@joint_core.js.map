{
  "version": 3,
  "sources": ["../../@joint/core/src/shapes/index.mjs", "../../@joint/core/src/shapes/standard.mjs", "../../@joint/core/src/g/index.mjs", "../../@joint/core/src/g/geometry.helpers.mjs", "../../@joint/core/src/g/line.bearing.mjs", "../../@joint/core/src/g/line.squaredLength.mjs", "../../@joint/core/src/g/line.length.mjs", "../../@joint/core/src/g/types.mjs", "../../@joint/core/src/g/point.mjs", "../../@joint/core/src/g/line.mjs", "../../@joint/core/src/g/ellipse.mjs", "../../@joint/core/src/g/rect.mjs", "../../@joint/core/src/g/points.mjs", "../../@joint/core/src/g/polyline.mjs", "../../@joint/core/src/g/curve.mjs", "../../@joint/core/src/g/extend.mjs", "../../@joint/core/src/g/path.mjs", "../../@joint/core/src/g/bezier.mjs", "../../@joint/core/src/g/polygon.mjs", "../../@joint/core/src/g/intersection.mjs", "../../@joint/core/src/V/index.mjs", "../../@joint/core/src/util/utilHelpers.mjs", "../../@joint/core/src/mvc/Data.mjs", "../../@joint/core/src/mvc/Dom/vars.mjs", "../../@joint/core/src/mvc/Dom/Event.mjs", "../../@joint/core/src/mvc/Dom/Dom.mjs", "../../@joint/core/src/mvc/Dom/methods.mjs", "../../@joint/core/src/mvc/Dom/animations.mjs", "../../@joint/core/src/mvc/Dom/props.mjs", "../../@joint/core/src/config/index.mjs", "../../@joint/core/src/mvc/Dom/events.mjs", "../../@joint/core/src/mvc/Dom/index.mjs", "../../@joint/core/src/util/util.mjs", "../../@joint/core/src/mvc/Events.mjs", "../../@joint/core/src/mvc/mvcUtils.mjs", "../../@joint/core/src/mvc/Model.mjs", "../../@joint/core/src/util/cloneCells.mjs", "../../@joint/core/src/dia/attributes/props.mjs", "../../@joint/core/src/dia/attributes/legacy.mjs", "../../@joint/core/src/util/calc.mjs", "../../@joint/core/src/dia/attributes/text.mjs", "../../@joint/core/src/dia/attributes/connection.mjs", "../../@joint/core/src/dia/attributes/shape.mjs", "../../@joint/core/src/dia/attributes/defs.mjs", "../../@joint/core/src/dia/attributes/offset.mjs", "../../@joint/core/src/dia/attributes/index.mjs", "../../@joint/core/src/dia/Cell.mjs", "../../@joint/core/src/util/index.mjs", "../../@joint/core/src/util/wrappers.mjs", "../../@joint/core/src/util/svgTagTemplate.mjs", "../../@joint/core/src/util/getRectPoint.mjs", "../../@joint/core/src/layout/ports/port.mjs", "../../@joint/core/src/layout/ports/portLabel.mjs", "../../@joint/core/src/dia/ports.mjs", "../../@joint/core/src/dia/Element.mjs", "../../@joint/core/src/dia/Link.mjs", "../../@joint/core/src/env/index.mjs", "../../@joint/core/src/connectors/index.mjs", "../../@joint/core/src/connectors/straight.mjs", "../../@joint/core/src/connectors/jumpover.mjs", "../../@joint/core/src/connectors/normal.mjs", "../../@joint/core/src/connectors/rounded.mjs", "../../@joint/core/src/connectors/smooth.mjs", "../../@joint/core/src/connectors/curve.mjs", "../../@joint/core/src/highlighters/index.mjs", "../../@joint/core/src/mvc/index.mjs", "../../@joint/core/src/mvc/ViewBase.mjs", "../../@joint/core/src/mvc/View.mjs", "../../@joint/core/src/mvc/Listener.mjs", "../../@joint/core/src/mvc/Collection.mjs", "../../@joint/core/src/dia/HighlighterView.mjs", "../../@joint/core/src/highlighters/stroke.mjs", "../../@joint/core/src/highlighters/mask.mjs", "../../@joint/core/src/highlighters/opacity.mjs", "../../@joint/core/src/highlighters/addClass.mjs", "../../@joint/core/src/highlighters/list.mjs", "../../@joint/core/src/connectionPoints/index.mjs", "../../@joint/core/src/connectionStrategies/index.mjs", "../../@joint/core/src/routers/index.mjs", "../../@joint/core/src/routers/normal.mjs", "../../@joint/core/src/routers/oneSide.mjs", "../../@joint/core/src/routers/orthogonal.mjs", "../../@joint/core/src/routers/manhattan.mjs", "../../@joint/core/src/routers/metro.mjs", "../../@joint/core/src/routers/rightAngle.mjs", "../../@joint/core/src/anchors/index.mjs", "../../@joint/core/src/linkAnchors/index.mjs", "../../@joint/core/src/dia/index.mjs", "../../@joint/core/src/dia/Graph.mjs", "../../@joint/core/src/dia/PaperLayer.mjs", "../../@joint/core/src/dia/attributes/eval.mjs", "../../@joint/core/src/dia/CellView.mjs", "../../@joint/core/src/dia/ElementView.mjs", "../../@joint/core/src/dia/LinkView.mjs", "../../@joint/core/src/dia/layers/GridLayer.mjs", "../../@joint/core/src/dia/Paper.mjs", "../../@joint/core/src/dia/ToolView.mjs", "../../@joint/core/src/dia/ToolsView.mjs", "../../@joint/core/src/linkTools/index.mjs", "../../@joint/core/src/linkTools/Vertices.mjs", "../../@joint/core/src/cellTools/helpers.mjs", "../../@joint/core/src/linkTools/Segments.mjs", "../../@joint/core/src/linkTools/Arrowhead.mjs", "../../@joint/core/src/linkTools/Anchor.mjs", "../../@joint/core/src/cellTools/Control.mjs", "../../@joint/core/src/linkTools/RotateLabel.mjs", "../../@joint/core/src/cellTools/Button.mjs", "../../@joint/core/src/cellTools/Boundary.mjs", "../../@joint/core/src/cellTools/Connect.mjs", "../../@joint/core/src/cellTools/HoverConnect.mjs", "../../@joint/core/src/elementTools/index.mjs", "../../@joint/core/src/elementTools/HoverConnect.mjs", "../../@joint/core/dist/version.mjs", "../../@joint/core/src/core.mjs"],
  "sourcesContent": ["import * as standard from './standard.mjs';\n\nexport { standard };\n", "import V from '../V/index.mjs';\nimport { Element } from '../dia/Element.mjs';\nimport { Link as LinkBase } from '../dia/Link.mjs';\nimport { isPercentage, assign } from '../util/index.mjs';\nimport { attributes } from '../dia/attributes/index.mjs';\nimport { env } from '../env/index.mjs';\n\n\n// ELEMENTS\n\nexport const Rectangle = Element.define('standard.Rectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body',\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Circle = Element.define('standard.Circle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(s/2)',\n            cy: 'calc(s/2)',\n            r: 'calc(s/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'circle',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Ellipse = Element.define('standard.Ellipse', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Path = Element.define('standard.Path', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            d: 'M 0 0 H calc(w) V calc(h) H 0 Z',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Polygon = Element.define('standard.Polygon', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polygon',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Polyline = Element.define('standard.Polyline', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polyline',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const Image = Element.define('standard.Image', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        image: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const BorderedImage = Element.define('standard.BorderedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5,\n            fill: '#FFFFFF'\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'background',\n        attributes: {\n            'stroke': 'none'\n        }\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'rect',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const EmbeddedImage = Element.define('standard.EmbeddedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#FFFFFF',\n            strokeWidth: 2\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(0.3*w)',\n            height: 'calc(h-20)',\n            x: 10,\n            y: 10,\n            preserveAspectRatio: 'xMidYMin'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'left',\n            x: 'calc(0.3*w+20)', // 10 + 10\n            y: 10,\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const InscribedImage = Element.define('standard.InscribedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            fill: '#FFFFFF'\n        },\n        image: {\n            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n            width: 'calc(0.68*w)',\n            height: 'calc(0.68*h)',\n            // The image offset is calculated as (100% - 68%) / 2\n            x: 'calc(0.16*w)',\n            y: 'calc(0.16*h)',\n            preserveAspectRatio: 'xMidYMid'\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'background'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'ellipse',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nexport const HeaderedRectangle = Element.define('standard.HeaderedRectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        header: {\n            width: 'calc(w)',\n            height: 30,\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        headerText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 15,\n            fontSize: 16,\n            fill: '#333333'\n        },\n        bodyText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'rect',\n        selector: 'header'\n    }, {\n        tagName: 'text',\n        selector: 'headerText'\n    }, {\n        tagName: 'text',\n        selector: 'bodyText'\n    }]\n});\n\nvar CYLINDER_TILT = 10;\n\nexport const Cylinder = Element.define('standard.Cylinder', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            lateralArea: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        top: {\n            cx: 'calc(w/2)',\n            cy: CYLINDER_TILT,\n            rx: 'calc(w/2)',\n            ry: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'ellipse',\n        selector: 'top'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }],\n\n    topRy: function(t, opt) {\n        // getter\n        if (t === undefined) return this.attr('body/lateralArea');\n\n        // setter\n        var bodyAttrs = { lateralArea: t };\n\n        var isPercentageSetter = isPercentage(t);\n        var ty = (isPercentageSetter) ? `calc(${parseFloat(t) / 100}*h)` : t;\n        var topAttrs = { cy: ty, ry: ty };\n\n        return this.attr({ body: bodyAttrs, top: topAttrs }, opt);\n    }\n\n}, {\n    attributes: {\n        'lateral-area': {\n            set: function(t, refBBox) {\n                var isPercentageSetter = isPercentage(t);\n                if (isPercentageSetter) t = parseFloat(t) / 100;\n\n                var x = refBBox.x;\n                var y = refBBox.y;\n                var w = refBBox.width;\n                var h = refBBox.height;\n\n                // curve control point variables\n                var rx = w / 2;\n                var ry = isPercentageSetter ? (h * t) : t;\n\n                var kappa = V.KAPPA;\n                var cx = kappa * rx;\n                var cy = kappa * (isPercentageSetter ? (h * t) : t);\n\n                // shape variables\n                var xLeft = x;\n                var xCenter = x + (w / 2);\n                var xRight = x + w;\n\n                var ySideTop = y + ry;\n                var yCurveTop = ySideTop - ry;\n                var ySideBottom = y + h - ry;\n                var yCurveBottom = y + h;\n\n                // return calculated shape\n                var data = [\n                    'M', xLeft, ySideTop,\n                    'L', xLeft, ySideBottom,\n                    'C', x, (ySideBottom + cy), (xCenter - cx), yCurveBottom, xCenter, yCurveBottom,\n                    'C', (xCenter + cx), yCurveBottom, xRight, (ySideBottom + cy), xRight, ySideBottom,\n                    'L', xRight, ySideTop,\n                    'C', xRight, (ySideTop - cy), (xCenter + cx), yCurveTop, xCenter, yCurveTop,\n                    'C', (xCenter - cx), yCurveTop, xLeft, (ySideTop - cy), xLeft, ySideTop,\n                    'Z'\n                ];\n                return { d: data.join(' ') };\n            },\n            unset: 'd'\n        }\n    }\n});\n\nvar foLabelMarkup = {\n    tagName: 'foreignObject',\n    selector: 'foreignObject',\n    attributes: {\n        'overflow': 'hidden'\n    },\n    children: [{\n        tagName: 'div',\n        namespaceURI: 'http://www.w3.org/1999/xhtml',\n        selector: 'label',\n        style: {\n            width: '100%',\n            height: '100%',\n            position: 'static',\n            backgroundColor: 'transparent',\n            textAlign: 'center',\n            margin: 0,\n            padding: '0px 5px',\n            boxSizing: 'border-box',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center'\n        }\n    }]\n};\n\nvar svgLabelMarkup = {\n    tagName: 'text',\n    selector: 'label',\n    attributes: {\n        'text-anchor': 'middle'\n    }\n};\n\nvar labelMarkup = (env.test('svgforeignobject')) ? foLabelMarkup : svgLabelMarkup;\n\nexport const TextBlock = Element.define('standard.TextBlock', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#ffffff',\n            strokeWidth: 2\n        },\n        foreignObject: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n        },\n        label: {\n            style: {\n                fontSize: 14\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, labelMarkup]\n}, {\n    attributes: {\n        text: {\n            set: function(text, refBBox, node, attrs) {\n                if (node instanceof HTMLElement) {\n                    node.textContent = text;\n                } else {\n                    // No foreign object\n                    var style = attrs['style'] || {};\n                    var wrapValue = { text, width: -5, height: '100%' };\n                    var wrapAttrs = assign({ 'text-vertical-anchor': 'middle' }, style);\n                    attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);\n                    return { fill: style.color || null };\n                }\n            },\n            unset: function(node) {\n                node.textContent = '';\n                if (node instanceof SVGElement) {\n                    return 'fill';\n                }\n            },\n            position: function(text, refBBox, node) {\n                // No foreign object\n                if (node instanceof SVGElement) return refBBox.center();\n            }\n        }\n    }\n});\n\n// LINKS\n\nexport const Link = LinkBase.define('standard.Link', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#333333',\n            strokeWidth: 2,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 10 -5 0 0 10 5 z'\n            }\n        },\n        wrapper: {\n            connection: true,\n            strokeWidth: 10,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'wrapper',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer',\n            'stroke': 'transparent',\n            'stroke-linecap': 'round'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nexport const DoubleLink = LinkBase.define('standard.DoubleLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#DDDDDD',\n            strokeWidth: 4,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                type: 'path',\n                stroke: '#000000',\n                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n            }\n        },\n        outline: {\n            connection: true,\n            stroke: '#000000',\n            strokeWidth: 6,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'outline',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nexport const ShadowLink = LinkBase.define('standard.ShadowLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#FF0000',\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M 0 -10 -10 0 0 10 z'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        },\n        shadow: {\n            connection: true,\n            transform: 'translate(3,6)',\n            stroke: '#000000',\n            strokeOpacity: 0.2,\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 0 -10 -10 0 0 10 z',\n                'stroke': 'none'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'shadow',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }]\n});\n", "// Geometry library.\n// -----------------\n\nexport * from './geometry.helpers.mjs';\nexport * from './bezier.mjs';\nexport * from './curve.mjs';\nexport * from './ellipse.mjs';\nexport * from './line.mjs';\nexport * from './path.mjs';\nexport * from './point.mjs';\nexport * from './polyline.mjs';\nexport * from './polygon.mjs';\nexport * from './rect.mjs';\nexport * from './types.mjs';\n\nimport * as _intersection from './intersection.mjs';\nexport const intersection = _intersection;\n", "// Declare shorthands to the most used math functions.\nconst {\n    round,\n    floor,\n    PI\n} = Math;\n\nexport const scale = {\n\n    // Return the `value` from the `domain` interval scaled to the `range` interval.\n    linear: function(domain, range, value) {\n\n        var domainSpan = domain[1] - domain[0];\n        var rangeSpan = range[1] - range[0];\n        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n    }\n};\n\nexport const normalizeAngle = function(angle) {\n\n    return (angle % 360) + (angle < 0 ? 360 : 0);\n};\n\nexport const snapToGrid = function(value, gridSize) {\n\n    return gridSize * round(value / gridSize);\n};\n\nexport const toDeg = function(rad) {\n\n    return (180 * rad / PI) % 360;\n};\n\nexport const toRad = function(deg, over360) {\n\n    over360 = over360 || false;\n    deg = over360 ? deg : (deg % 360);\n    return deg * PI / 180;\n};\n\n// Return a random integer from the interval [min,max], inclusive.\nexport const random = function(min, max) {\n\n    if (max === undefined) {\n        // use first argument as max, min is 0\n        max = (min === undefined) ? 1 : min;\n        min = 0;\n\n    } else if (max < min) {\n        // switch max and min\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n\n    return floor((Math.random() * (max - min + 1)) + min);\n};\n\n", "// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\nimport { toDeg, toRad } from './geometry.helpers.mjs';\n\nconst {\n    cos,\n    sin,\n    atan2\n} = Math;\n\nexport const bearing = function(p, q) {\n\n    var lat1 = toRad(p.y);\n    var lat2 = toRad(q.y);\n    var lon1 = p.x;\n    var lon2 = q.x;\n    var dLon = toRad(lon2 - lon1);\n    var y = sin(dLon) * cos(lat2);\n    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n    var brng = toDeg(atan2(y, x));\n\n    var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n    var index = brng - 22.5;\n    if (index < 0)\n        index += 360;\n    index = parseInt(index / 45);\n\n    return bearings[index];\n};\n", "// @return {integer} length without sqrt\n// @note for applications where the exact length is not necessary (e.g. compare only)\nexport const squaredLength = function(start, end) {\n\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = end.x;\n    var y1 = end.y;\n    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n};\n", "import { squaredLength } from './line.squaredLength.mjs';\n\nexport const length = function(start, end) {\n    return Math.sqrt(squaredLength(start, end));\n};\n", "export const types = {\n    Point: 1,\n    Line: 2,\n    Ellipse: 3,\n    Rect: 4,\n    Polyline: 5,\n    Polygon: 6,\n    Curve: 7,\n    Path: 8\n};\n", "/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nimport { normalizeAngle, random, snapToGrid, toDeg, toRad } from './geometry.helpers.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    sqrt,\n    min,\n    max,\n    atan2,\n    round,\n    pow,\n    PI\n} = Math;\n\nexport const Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = normalizeAngle(toDeg(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n\n    type: types.Point,\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return bearing(this, point);\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return length(this, p);\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = toRad((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = toRad(normalizeAngle(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = snapToGrid(this.x, gx);\n        this.y = snapToGrid(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n        return squaredLength(this, p);\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = toRad(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nexport const point = Point;\n", "import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    max,\n    min\n} = Math;\n\nexport const Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.end = new Point(p2);\n};\n\nLine.prototype = {\n\n    type: types.Line,\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return bearing(this.start, this.end);\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n        return length(this.start, this.end);\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return squaredLength(this.start, this.end);\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n\n// For backwards compatibility:\nexport const line = Line;\n", "import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    sqrt,\n    round,\n    pow\n} = Math;\n\nexport const Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    type: types.Ellipse,\n\n    bbox: function() {\n\n        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new Point(this));\n        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n\n        if (angle) p.rotate(new Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\n// For backwards compatibility:\nexport const ellipse = Ellipse;\n", "import { toRad } from './geometry.helpers.mjs';\nimport { Line } from './line.mjs';\nimport { Point } from './point.mjs';\nimport { Ellipse } from './ellipse.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    min,\n    max,\n    round,\n    pow\n} = Math;\n\nexport const Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function(...points) {\n\n    if (points.length === 0) return null;\n\n    const p = new Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function(...rects) {\n\n    if (rects.length === 0) return null;\n\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < rects.length; i++) {\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n\n    type: types.Rect,\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = toRad(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n\n    bottomLeft: function() {\n\n        return new Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    // @param {bool} strict If true, the point has to be strictly inside (not on the border).\n    containsPoint: function(p, opt) {\n        let x, y;\n        if (!p || (typeof p === 'string')) {\n            // Backwards compatibility: if the point is not provided,\n            // the point is considered to be the origin [0, 0].\n            ({ x, y } = new Point(p));\n        } else {\n            // Do not create a new Point object if the point is already a Point-like object.\n            ({ x = 0, y = 0 } = p);\n        }\n        return opt && opt.strict\n            ? (x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height)\n            : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, point.y);\n                case 'left':\n                    return new Point(this.x, point.y);\n                case 'bottom':\n                    return new Point(point.x, this.y + this.height);\n                case 'top':\n                    return new Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        return Rect.fromRectUnion(this, rect);\n    },\n\n    update: function(x, y, w, h) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nexport const rect = Rect;\n", "export function parsePoints(svgString) {\n\n    // Step 1: Discard surrounding spaces\n    const trimmedString = svgString.trim();\n    if (trimmedString === '') return [];\n\n    const points = [];\n\n    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n    // Note: This doesn't simplify double (or more) commas - causes empty coords\n    // This regex is used by `split()`, so it doesn't need to use /g\n    const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\n    const numCoords = coords.length;\n    for (let i = 0; i < numCoords; i += 2) {\n        // Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n    return points;\n}\n\nexport function clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nexport function convexHull(points) {\n\n    const { abs } = Math;\n\n    var i;\n    var n;\n\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for (i = 0; i < numPoints; i++) {\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n\n        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for (i = 0; i < numPoints; i++) {\n\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n            // the start point will end up at end of sorted list\n            // the start point will end up at beginning of hull points list\n        }\n\n        var entry = [points[i], i, angle];\n        sortedPointRecords.push(entry);\n    }\n\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n\n        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            // coincident points will be sorted in reverse-numerical order\n            // so the coincident points with lower original index will be considered first\n        }\n\n        return sortOutput;\n    });\n\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while (sortedPointRecords.length !== 0) {\n\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n            // this point had an incorrect turn at some previous iteration of this loop\n            // this disqualifies it from possibly being on the hull\n            continue;\n        }\n\n        var correctTurnFound = false;\n        while (!correctTurnFound) {\n\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                        // we are switching the order of the 0deg and 180deg points\n                        // correct turn not found\n                    }\n\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for (i = 0; i < n; i++) {\n\n        var currentHullIndex = hullPointRecords[i][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for (i = 0; i < n; i++) {\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return hullPoints;\n}\n", "import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\n\n\nexport const Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    return new Polyline(parsePoints(svgString));\n};\n\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft(),\n    ]);\n};\n\nPolyline.prototype = {\n\n    type: types.Polyline,\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n        return new Polyline(clonePoints(this.points));\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new Line();\n        var ray = new Line();\n        var rayEnd = new Point();\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n\n    lengthPoints: function() {\n        return this.points;\n    },\n\n    convexHull: function() {\n        return new Polyline(convexHull(this.points));\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new Line();\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var line = new Line();\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n        // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n        // because of the rounding errors that can occur when comparing distances.\n        const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n", "import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { Line } from './line.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    sqrt,\n    min,\n    max,\n    pow\n} = Math;\n\nexport const Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.controlPoint1 = new Point(p2);\n    this.controlPoint2 = new Point(p3);\n    this.end = new Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    type: types.Curve,\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new Line(start, control1)).pointAt(t);\n        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        var subdivisions = [new Curve(start, control1, control2, end)];\n        if (precision === 0) return subdivisions;\n\n        // special case #1: point-like curves\n        // - no need to calculate subdivisions, they would all be identical\n        var isPoint = !this.isDifferentiable();\n        if (isPoint) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // - (i.e. cubic curves cannot intersect the baseline more than once)\n        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n        // - (unless it's a straight-line curve, see below)\n        var minIterations = 2; // = 2*1\n\n        // special case #3: straight-line curves have the same observed length in all iterations\n        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n        // - we enforce the expected number of iterations = 2 * precision\n        var isLine = ((control1.cross(start, end) === 0) && (control2.cross(start, end) === 0));\n        if (isLine) {\n            minIterations = (2 * precision);\n        }\n\n        // recursively divide curve at `t = 0.5`\n        // until we reach `minIterations`\n        // and until the difference between observed length at subsequent iterations is lower than `precision`\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached minimum number of iterations\n            if (iteration >= minIterations) {\n\n                // check if we have reached required observed precision\n                var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n                if (observedPrecisionRatio < precisionRatio) {\n                    return newSubdivisions;\n                }\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n", "// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nexport function extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n", "// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nimport { Polyline } from './polyline.mjs';\nimport { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { Curve } from './curve.mjs';\nimport { types } from './types.mjs';\nimport { extend } from './extend.mjs';\nexport const Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    type: types.Path,\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new Point(+args[0], +args[1]);\n            this.controlPoint2 = new Point(+args[2], +args[3]);\n            this.end = new Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new Point(args[0]);\n            this.controlPoint2 = new Point(args[1]);\n            this.end = new Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n", "import { Path } from './path.mjs';\nimport { Curve } from './curve.mjs';\nimport { Point } from './point.mjs';\n\nexport const bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new Path(Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n", "import { Point } from './point.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { extend } from './extend.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\n\nexport const Polygon = function(points) {\n\n    if (!(this instanceof Polygon)) {\n        return new Polygon(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polygon.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolygon.parse = function(svgString) {\n    return new Polygon(parsePoints(svgString));\n};\n\nPolygon.fromRect = function(rect) {\n    return new Polygon([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft()\n    ]);\n};\n\nPolygon.prototype = extend(Polyline.prototype, {\n\n    type: types.Polygon,\n\n    clone: function() {\n        return new Polygon(clonePoints(this.points));\n    },\n\n    convexHull: function() {\n        return new Polygon(convexHull(this.points));\n    },\n\n    lengthPoints: function() {\n        const { start, end, points } = this;\n        if (points.length <= 1 || start.equals(end)) return points;\n        return [...points, start.clone()];\n    }\n\n});\n", "import { Line } from './line.mjs';\nimport { Polygon } from './polygon.mjs';\nimport { Rect } from './rect.mjs';\nimport { types } from './types.mjs';\n\nexport function exists(shape1, shape2, shape1opt, shape2opt) {\n    switch (shape1.type) {\n        case types.Line: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return lineWithLine(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Ellipse: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return ellipseWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return ellipseWithEllipse(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Rect: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return rectWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return rectWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return rectWithRect(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Polyline: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return polylineWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return polylineWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return polylineWithRect(shape1, shape2);\n                }\n                case types.Polyline: {\n                    return polylineWithPolyline(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Polygon: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return polygonWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return polygonWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return polygonWithRect(shape1, shape2);\n                }\n                case types.Polyline: {\n                    return polygonWithPolyline(shape1, shape2);\n                }\n                case types.Polygon: {\n                    return polygonWithPolygon(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Path: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return pathWithLine(shape1, shape2, shape1opt);\n                }\n                case types.Ellipse: {\n                    return pathWithEllipse(shape1, shape2, shape1opt);\n                }\n                case types.Rect: {\n                    return pathWithRect(shape1, shape2, shape1opt);\n                }\n                case types.Polyline: {\n                    return pathWithPolyline(shape1, shape2, shape1opt);\n                }\n                case types.Polygon: {\n                    return pathWithPolygon(shape1, shape2, shape1opt);\n                }\n                case types.Path: {\n                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                }\n            }\n            break;\n        }\n    }\n    // None of the cases above\n    switch (shape2.type) {\n        case types.Ellipse:\n        case types.Rect:\n        case types.Polyline:\n        case types.Polygon:\n        case types.Path: {\n            return exists(shape2, shape1, shape2opt, shape1opt);\n        }\n        default: {\n            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n        }\n    }\n}\n\n/* Line */\n\nexport function lineWithLine(line1, line2) {\n    const x1 = line1.start.x;\n    const y1 = line1.start.y;\n    const x2 = line1.end.x;\n    const y2 = line1.end.y;\n    const x3 = line2.start.x;\n    const y3 = line2.start.y;\n    const x4 = line2.end.x;\n    const y4 = line2.end.y;\n    const s1x = x2 - x1;\n    const s1y = y2 - y1;\n    const s2x = x4 - x3;\n    const s2y = y4 - y3;\n    const s3x = x1 - x3;\n    const s3y = y1 - y3;\n    const p = s1x * s2y - s2x * s1y;\n    const s = (s1x * s3y - s1y * s3x) / p;\n    const t = (s2x * s3y - s2y * s3x) / p;\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/* Ellipse */\n\nexport function ellipseWithLine(ellipse, line) {\n    const rex = ellipse.a;\n    const rey = ellipse.b;\n    const xe = ellipse.x;\n    const ye = ellipse.y;\n    const x1 = line.start.x - xe;\n    const x2 = line.end.x - xe;\n    const y1 = line.start.y - ye;\n    const y2 = line.end.y - ye;\n    const rex_2 = rex * rex;\n    const rey_2 = rey * rey;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const A = dx * dx / rex_2 + dy * dy / rey_2;\n    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n    const D = B * B - 4 * A * C;\n    if (D === 0) {\n        const t = -B / 2 / A;\n        return t >= 0 && t <= 1;\n    } else if (D > 0) {\n        const sqrt = Math.sqrt(D);\n        const t1 = (-B + sqrt) / 2 / A;\n        const t2 = (-B - sqrt) / 2 / A;\n        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);\n    }\n    return false;\n}\n\nexport function ellipseWithEllipse(ellipse1, ellipse2) {\n    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n\n/* Rect */\n\nexport function rectWithLine(rect, line) {\n    const { start, end } = line;\n    const { x, y, width, height } = rect;\n    if (\n        (start.x > x + width && end.x > x + width)\n        || (start.x < x && end.x < x)\n        || (start.y > y + height && end.y > y + height)\n        || (start.y < y && end.y < y)\n    ) {\n        return false;\n    }\n    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n        return true;\n    }\n    return lineWithLine(rect.topLine(), line)\n        || lineWithLine(rect.rightLine(), line)\n        || lineWithLine(rect.bottomLine(), line)\n        || lineWithLine(rect.leftLine(), line);\n}\n\nexport function rectWithEllipse(rect, ellipse) {\n    if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n    return polygonWithEllipse(Polygon.fromRect(rect), ellipse);\n}\n\nexport function rectWithRect(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width\n        && rect1.x + rect1.width > rect2.x\n        && rect1.y < rect2.y + rect2.height\n        && rect1.y + rect1.height > rect2.y;\n}\n\n/* Polyline */\n\nexport function polylineWithLine(polyline, line) {\n    return _polylineWithLine(polyline, line, { interior: false });\n}\n\nexport function polylineWithEllipse(polyline, ellipse) {\n    return _polylineWithEllipse(polyline, ellipse, { interior: false });\n}\n\nexport function polylineWithRect(polyline, rect) {\n    return _polylineWithRect(polyline, rect, { interior: false });\n}\n\nexport function polylineWithPolyline(polyline1, polyline2) {\n    return _polylineWithPolyline(polyline1, polyline2, { interior: false });\n}\n\n/* Polygon */\n\nexport function polygonWithLine(polygon, line) {\n    return _polylineWithLine(polygon, line, { interior: true });\n}\n\nexport function polygonWithEllipse(polygon, ellipse) {\n    return _polylineWithEllipse(polygon, ellipse, { interior: true });\n}\n\nexport function polygonWithRect(polygon, rect) {\n    return _polylineWithRect(polygon, rect, { interior: true });\n}\n\nexport function polygonWithPolyline(polygon, polyline) {\n    return _polylineWithPolyline(polygon, polyline, { interior: true });\n}\n\nexport function polygonWithPolygon(polygon1, polygon2) {\n    return _polylineWithPolygon(polygon1, polygon2, { interior: true });\n}\n\n/* Path */\n\nexport function pathWithLine(path, line, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithLine(polyline, line);\n        } else {\n            return polylineWithLine(polyline, line);\n        }\n    });\n}\n\nexport function pathWithEllipse(path, ellipse, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithEllipse(polyline, ellipse);\n        } else {\n            return polylineWithEllipse(polyline, ellipse);\n        }\n    });\n}\n\nexport function pathWithRect(path, rect, pathOpt) {\n    return pathWithPolygon(path, Polygon.fromRect(rect), pathOpt);\n}\n\nexport function pathWithPolyline(path, polyline, pathOpt) {\n    return _pathWithPolyline(path, polyline, pathOpt, { interior: false });\n}\n\nexport function pathWithPolygon(path, polygon, pathOpt) {\n    return _pathWithPolyline(path, polygon, pathOpt, { interior: true });\n}\n\nexport function pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n    return path1.getSubpaths().some(subpath => {\n        const [polyline1] = subpath.toPolylines(pathOpt1);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return pathWithPolygon(path2, polyline1, pathOpt2);\n        } else {\n            return pathWithPolyline(path2, polyline1, pathOpt2);\n        }\n    });\n}\n\nfunction _polylineWithLine(polyline, line, opt = {}) {\n    const { interior = false } = opt;\n    let thisPoints;\n    if (interior) {\n        if (polyline.containsPoint(line.start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        const { start, end, points } = polyline;\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = polyline.points;\n    }\n    const { length } = thisPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (lineWithLine(line, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n    const { start, end, points } = polyline;\n    if (ellipse.containsPoint(start)) {\n        return true;\n    }\n    let thisPoints;\n    const { interior = false } = opt;\n    if (interior) {\n        if (polyline.containsPoint(ellipse.center())) {\n            // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n        }\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = points;\n    }\n\n    const { length } = thisPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (ellipseWithLine(ellipse, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithRect(polyline, rect, opt) {\n    const polygon = Polygon.fromRect(rect);\n    return _polylineWithPolygon(polyline, polygon, opt);\n}\n\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline2] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return _polylineWithPolygon(polyline1, polyline2, opt);\n        } else {\n            return _polylineWithPolyline(polyline1, polyline2, opt);\n        }\n    });\n}\n\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n    const { interior = false } = opt;\n    let thisPolyline;\n    if (interior) {\n        const { start } = polyline2;\n        if (polyline1.containsPoint(start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        thisPolyline = polyline1.clone().close();\n    } else {\n        thisPolyline = polyline1;\n    }\n    const otherPoints = polyline2.points;\n    const { length } = otherPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = otherPoints[i];\n        segment.end = otherPoints[i + 1];\n        if (polylineWithLine(thisPolyline, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\n\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n    const { cos, sin } = Math;\n    const sinW1 = sin(w1);\n    const cosW1 = cos(w1);\n    const sinW2 = sin(w2);\n    const cosW2 = cos(w2);\n    const sinW1s = sinW1 * sinW1;\n    const cosW1s = cosW1 * cosW1;\n    const sinCos1 = sinW1 * cosW1;\n    const sinW2s = sinW2 * sinW2;\n    const cosW2s = cosW2 * cosW2;\n    const sinCos2 = sinW2 * cosW2;\n    const a1s = e1.a * e1.a;\n    const b1s = e1.b * e1.b;\n    const a2s = e2.a * e2.a;\n    const b2s = e2.b * e2.b;\n    const A1 = a1s * sinW1s + b1s * cosW1s;\n    const A2 = a2s * sinW2s + b2s * cosW2s;\n    const B1 = a1s * cosW1s + b1s * sinW1s;\n    const B2 = a2s * cosW2s + b2s * sinW2s;\n    let C1 = 2 * (b1s - a1s) * sinCos1;\n    let C2 = 2 * (b2s - a2s) * sinCos2;\n    let D1 = (-2 * A1 * e1.x - C1 * e1.y);\n    let D2 = (-2 * A2 * e2.x - C2 * e2.y);\n    let E1 = (-C1 * e1.x - 2 * B1 * e1.y);\n    let E2 = (-C2 * e2.x - 2 * B2 * e2.y);\n    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\n    C1 = C1 / 2;\n    C2 = C2 / 2;\n    D1 = D1 / 2;\n    D2 = D2 / 2;\n    E1 = E1 / 2;\n    E2 = E2 / 2;\n\n    const l3 = det3([\n        [A1, C1, D1],\n        [C1, B1, E1],\n        [D1, E1, F1]\n    ]);\n    const l0 = det3([\n        [A2, C2, D2],\n        [C2, B2, E2],\n        [D2, E2, F2]\n    ]);\n    const l2 = 0.33333333 * (det3([\n        [A2, C1, D1],\n        [C2, B1, E1],\n        [D2, E1, F1]\n    ]) + det3([\n        [A1, C2, D1],\n        [C1, B2, E1],\n        [D1, E2, F1]\n    ]) + det3([\n        [A1, C1, D2],\n        [C1, B1, E2],\n        [D1, E1, F2]\n    ]));\n    const l1 = 0.33333333 * (det3([\n        [A1, C2, D2],\n        [C1, B2, E2],\n        [D1, E2, F2]\n    ]) + det3([\n        [A2, C1, D2],\n        [C2, B1, E2],\n        [D2, E1, F2]\n    ]) + det3([\n        [A2, C2, D1],\n        [C2, B2, E1],\n        [D2, E2, F1]\n    ]));\n\n    const delta1 = det2([\n        [l3, l2],\n        [l2, l1]\n    ]);\n    const delta2 = det2([\n        [l3, l1],\n        [l2, l0]\n    ]);\n    const delta3 = det2([\n        [l2, l1],\n        [l1, l0]\n    ]);\n\n    const dP = det2([\n        [2 * delta1, delta2],\n        [delta2, 2 * delta3]\n    ]);\n\n    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n        return false;\n    }\n    return true;\n}\n\nfunction det2(m) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\n\nfunction det3(m) {\n    return m[0][0] * m[1][1] * m[2][2] -\n        m[0][0] * m[1][2] * m[2][1] -\n        m[0][1] * m[1][0] * m[2][2] +\n        m[0][1] * m[1][2] * m[2][0] +\n        m[0][2] * m[1][0] * m[2][1] -\n        m[0][2] * m[1][1] * m[2][0];\n}\n", "// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\nimport * as g from '../g/index.mjs';\n\nconst V = (function() {\n\n    var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n    // SVG support is required.\n    if (!hasSvg) {\n\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error('SVG is required to use Vectorizer.');\n        };\n    }\n\n    // XML namespaces.\n    var ns = {\n        svg: 'http://www.w3.org/2000/svg',\n        xmlns: 'http://www.w3.org/2000/xmlns/',\n        xml: 'http://www.w3.org/XML/1998/namespace',\n        xlink: 'http://www.w3.org/1999/xlink',\n        xhtml: 'http://www.w3.org/1999/xhtml'\n    };\n\n    var SVGVersion = '1.1';\n\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n\n    var V = function(el, attrs, children) {\n\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n\n        if (!el) return;\n\n        if (V.isV(el)) {\n            el = el.node;\n        }\n\n        attrs = attrs || {};\n\n        if (V.isString(el)) {\n\n            el = el.trim();\n\n            if (el.toLowerCase() === 'svg') {\n\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n\n            } else if (el[0] === '<') {\n\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n                var svgDoc = V.createSvgDocument(el);\n\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n\n                    return arrayOfVels;\n                }\n\n                el = document.importNode(svgDoc.firstChild, true);\n\n            } else {\n\n                el = document.createElementNS(ns.svg, el);\n            }\n\n            V.ensureId(el);\n        }\n\n        this.node = el;\n\n        this.setAttributes(attrs);\n\n        if (children) {\n            this.append(children);\n        }\n\n        return this;\n    };\n\n    var VPrototype = V.prototype;\n\n    Object.defineProperty(VPrototype, 'id', {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */\n    VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */\n    VPrototype.transform = function(matrix, opt) {\n\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr('transform'));\n        }\n\n        if (opt && opt.absolute) {\n            return this.attr('transform', V.matrixToTransformString(matrix));\n        }\n\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n\n    VPrototype.translate = function(tx, ty, opt) {\n\n        opt = opt || {};\n        ty = ty || 0;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n        return this;\n    };\n\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n        opt = opt || {};\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n        angle %= 360;\n\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n        return this;\n    };\n\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n\n        sy = V.isUndefined(sy) ? sx : sy;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n        return this;\n    };\n\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        try {\n\n            box = node.getBBox();\n\n        } catch (e) {\n\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n\n        if (withoutTransformations) {\n            return new g.Rect(box);\n        }\n\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n        return V.transformRect(box, matrix);\n    };\n\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n\n        var options = {};\n\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        if (opt) {\n            if (opt.target) { // check if target exists\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new g.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else { // if we want to calculate the bbox recursively\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n            var children = this.children();\n            var n = children.length;\n\n            if (n === 0) {\n                return this.getBBox({ target: options.target, recursive: false });\n            }\n\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n\n            for (var i = 0; i < n; i++) {\n                var currentChild = children[i];\n\n                var childBBox;\n\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n                }\n\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n\n            return outputBBox;\n        }\n    };\n\n    // Text() helpers\n\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V('textPath');\n        var d = attrs.d;\n        if (d && attrs['xlink:href'] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for (var j = 0; j <= lastJ; j++) {\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V('tspan', annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs['class'];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs['font-size']);\n                if (!isFinite(fontSize)) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || ' ');\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = (maxFontSize * 1.2);\n        }\n        return fontMetrics;\n    }\n\n    var emRegex = /em$/;\n\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for (var i = 1; i < n; i++) {\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch (alignment) {\n            case 'middle':\n                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n                break;\n            case 'bottom':\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            case 'top':\n            default:\n                dy = (0.8 * flMaxFont);\n                break;\n        }\n        return dy;\n    }\n\n    VPrototype.text = function(content, opt) {\n\n        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr('x') || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [annotations];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = (defaultLineHeight === 'auto');\n        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            'xml:space': 'preserve',\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            'display': (content || displayEmpty) ? null : 'none'\n        });\n\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr('font-size'));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n        }\n\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === 'string') textPath = { d: textPath };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split('\\n');\n        var linesMetrics = [];\n        var annotatedY;\n        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n            var dy = lineHeight;\n            var lineClassName = 'v-line';\n            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: (i !== lastI && eol),\n                        lineHeight: (autoLineHeight) ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = '-';\n                lineClassName += ' v-empty-line';\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) {\n                    // Empty line with annotations.\n                    lineMetrics = {};\n                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                    let lineFontSize = fontSize;\n                    // Check if any of the annotations overrides the font size.\n                    for (let j = lineAnnotations.length; j > 0; j--) {\n                        const attrs = lineAnnotations[j - 1].attrs;\n                        if (!attrs || !('font-size' in attrs)) continue;\n                        const fs = parseFloat(attrs['font-size']);\n                        if (isFinite(fs)) {\n                            lineFontSize = fs;\n                            break;\n                        }\n                    }\n                    if (autoLineHeight) {\n                        if (i > 0) {\n                            dy = lineFontSize * 1.2;\n                        } else {\n                            annotatedY = lineFontSize * 0.8;\n                        }\n                    }\n                    // The font size is important for the native selection box height.\n                    lineNode.setAttribute('font-size', lineFontSize);\n                    lineMetrics.maxFontSize = lineFontSize;\n                }\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute('dy', dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute('x', x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1;      // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === 'top') {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = '0.8em';\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch (verticalAnchor) {\n                    case 'middle':\n                        dy = (0.3 - (rh / 2)) + 'em';\n                        break;\n                    case 'bottom':\n                        dy = (-rh - 0.3) + 'em';\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = '0em';\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n            }\n        }\n        containerNode.firstChild.setAttribute('dy', dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */\n    VPrototype.removeAttr = function(name) {\n\n        const trueName = attributeNames[name];\n\n        const { ns, local } = V.qualifyAttr(trueName);\n        const el = this.node;\n\n        if (ns) {\n            if (el.hasAttributeNS(ns, local)) {\n                el.removeAttributeNS(ns, local);\n            }\n        } else if (el.hasAttribute(trueName)) {\n            el.removeAttribute(trueName);\n        }\n        return this;\n    };\n\n    VPrototype.attr = function(name, value) {\n\n        if (V.isUndefined(name)) {\n\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n\n            for (var i = 0; i < attributes.length; i++) {\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n\n            return attrs;\n        }\n\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(attributeNames[name]);\n        }\n\n        if (typeof name === 'object') {\n\n            for (var attrName in name) {\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n\n        } else {\n\n            this.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    VPrototype.normalizePath = function() {\n\n        var tagName = this.tagName();\n        if (tagName === 'PATH') {\n            this.attr('d', V.normalizePathData(this.attr('d')));\n        }\n\n        return this;\n    };\n\n    VPrototype.remove = function() {\n\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n\n        return this;\n    };\n\n    VPrototype.empty = function() {\n\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttributes = function(attrs) {\n\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.append = function(els) {\n\n        if (!V.isArray(els)) {\n            els = [els];\n        }\n\n        for (var i = 0, len = els.length; i < len; i++) {\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n\n        return this;\n    };\n\n    VPrototype.prepend = function(els) {\n\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n\n    VPrototype.before = function(els) {\n\n        var node = this.node;\n        var parent = node.parentNode;\n\n        if (parent) {\n\n            if (!V.isArray(els)) {\n                els = [els];\n            }\n\n            for (var i = 0, len = els.length; i < len; i++) {\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n\n    VPrototype.svg = function() {\n\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n\n    VPrototype.tagName = function() {\n\n        return this.node.tagName.toUpperCase();\n    };\n\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) return V(defsNode);\n        return V('defs').appendTo(context);\n    };\n\n    VPrototype.clone = function() {\n\n        var clone = V(this.node.cloneNode(true/* deep */));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n\n    VPrototype.findOne = function(selector) {\n\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n\n    VPrototype.find = function(selector) {\n\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n\n        if (nodes) {\n\n            // Map DOM elements to `V`s.\n            for (var i = 0; i < nodes.length; i++) {\n                vels.push(V(nodes[i]));\n            }\n        }\n\n        return vels;\n    };\n\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n\n        var children = this.node.childNodes;\n\n        var outputArray = [];\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    },\n\n    // Find an index of an element inside its container.\n    VPrototype.index = function() {\n\n        var index = 0;\n        var node = this.node.previousSibling;\n\n        while (node) {\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n\n        return index;\n    };\n\n    VPrototype.findParentByClass = function(className, terminator) {\n\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n\n        while (node && node !== terminator && node !== ownerSVGElement) {\n\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n\n            node = node.parentNode;\n        }\n\n        return null;\n    };\n\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n    };\n\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n\n        var svg = this.svg().node;\n\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n\n        try {\n\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n\n    VPrototype.translateCenterToPoint = function(p) {\n\n        var bbox = this.getBBox({ target: this.svg() });\n        var center = bbox.center();\n\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n        position = new g.Point(position);\n        reference =  new g.Point(reference);\n        target || (target = this.svg());\n\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr('transform', '');\n        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(\n            translateFromOrigin.matrix.multiply(\n                rotateAroundOrigin.matrix.multiply(\n                    translateToOrigin.matrix.multiply(\n                        ctm.scale(scale.sx, scale.sy)))));\n\n        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n        return this;\n    };\n\n    VPrototype.animateAlongPath = function(attrs, path) {\n\n        path = V.toNode(path);\n\n        var id = V.ensureId(path);\n        var animateMotion = V('animateMotion', attrs);\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n        animateMotion.append(mpath);\n\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n\n                var animationID = animation.getAttribute('id');\n                if (animationID) id2anim[animationID] = animation;\n\n                var targets = getTargets(animation);\n                for (var i = 0, len = targets.length; i < len; i++) {\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n\n\n    // Split a string into an array of tokens.\n    // https://infra.spec.whatwg.org/#ascii-whitespace\n    const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n    function getTokenList(str) {\n        if (!V.isString(str)) return [];\n        return str.trim().match(noHTMLWhitespaceRegex) || [];\n    }\n\n    VPrototype.hasClass = function(className) {\n        if (!V.isString(className)) return false;\n        return this.node.classList.contains(className.trim());\n    };\n\n    VPrototype.addClass = function(className) {\n        this.node.classList.add(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.removeClass = function(className) {\n        this.node.classList.remove(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.toggleClass = function(className, toAdd) {\n        const tokens = getTokenList(className);\n        for (let i = 0; i < tokens.length; i++) {\n            this.node.classList.toggle(tokens[i], toAdd);\n        }\n        return this;\n    };\n\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while (distance < length) {\n            sample = node.getPointAtLength(distance);\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\n            distance += interval;\n        }\n        return samples;\n    };\n\n    VPrototype.convertToPath = function() {\n\n        var path = V('path');\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr('d', d);\n        }\n        return path;\n    };\n\n    VPrototype.convertToPathData = function() {\n\n        var tagName = this.tagName();\n\n        switch (tagName) {\n            case 'PATH':\n                return this.attr('d');\n            case 'LINE':\n                return V.convertLineToPathData(this.node);\n            case 'POLYGON':\n                return V.convertPolygonToPathData(this.node);\n            case 'POLYLINE':\n                return V.convertPolylineToPathData(this.node);\n            case 'ELLIPSE':\n                return V.convertEllipseToPathData(this.node);\n            case 'CIRCLE':\n                return V.convertCircleToPathData(this.node);\n            case 'RECT':\n                return V.convertRectToPathData(this.node);\n        }\n\n        throw new Error(tagName + ' cannot be converted to PATH.');\n    };\n\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch (this.tagName()) {\n\n            case 'RECT':\n                x = parseFloat(this.attr('x')) || 0;\n                y = parseFloat(this.attr('y')) || 0;\n                width = parseFloat(this.attr('width')) || 0;\n                height = parseFloat(this.attr('height')) || 0;\n                return new g.Rect(x, y, width, height);\n\n            case 'CIRCLE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                r = parseFloat(this.attr('r')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, r, r);\n\n            case 'ELLIPSE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                rx = parseFloat(this.attr('rx')) || 0;\n                ry = parseFloat(this.attr('ry')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, rx, ry);\n\n            case 'POLYLINE':\n                points = V.getPointsFromSvgNode(this);\n                return new g.Polyline(points);\n\n            case 'POLYGON':\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new g.Polyline(points);\n\n            case 'PATH':\n                d = this.attr('d');\n                if (!g.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new g.Path(d);\n\n            case 'LINE':\n                x1 = parseFloat(this.attr('x1')) || 0;\n                y1 = parseFloat(this.attr('y1')) || 0;\n                x2 = parseFloat(this.attr('x2')) || 0;\n                y2 = parseFloat(this.attr('y2')) || 0;\n                return new g.Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n        }\n\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({ target: target });\n        var center = bbox.center();\n\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\n        var spot;\n        var tagName = this.tagName();\n\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === 'RECT') {\n\n            var gRect = new g.Rect(\n                parseFloat(this.attr('x') || 0),\n                parseFloat(this.attr('y') || 0),\n                parseFloat(this.attr('width')),\n                parseFloat(this.attr('height'))\n            );\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = (new g.Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n\n            var i, sample, gp, centerDistance, refDistance, distance;\n\n            for (i = 0; i < samples.length; i++) {\n\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new g.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\n                }\n            }\n\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n\n        return spot;\n    };\n\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttribute = function(name, value) {\n\n        const el = this.node;\n\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n\n        const trueName = attributeNames[name];\n\n        const { ns } = V.qualifyAttr(trueName);\n        if (ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(ns, trueName, value);\n        } else if (trueName === 'id') {\n            el.id = value;\n        } else {\n            el.setAttribute(trueName, value);\n        }\n\n        return this;\n    };\n\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, { async: false });\n            return documentElement;\n        }\n\n        const svg = document.createElementNS(ns.svg, 'svg');\n        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n        svg.setAttribute('version', SVGVersion);\n        return svg;\n    };\n\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V('style', { type: 'text/css' }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    },\n\n    V.createCDATASection = function(data = '') {\n        const xml = document.implementation.createDocument(null, 'xml', null);\n        return xml.createCDATASection(data);\n    };\n\n    V.idCounter = 0;\n\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n\n        return 'v-' + (++V.idCounter);\n    };\n\n    V.toNode = function(el) {\n\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n    };\n\n    V.ensureId = function(node) {\n\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n\n        return (text || '').replace(/ /g, '\\u00A0');\n    };\n\n    V.isUndefined = function(value) {\n\n        return typeof value === 'undefined';\n    };\n\n    V.isString = function(value) {\n\n        return typeof value === 'string';\n    };\n\n    V.isObject = function(value) {\n\n        return value && (typeof value === 'object');\n    };\n\n    V.isArray = Array.isArray;\n\n    V.parseXML = function(data, opt) {\n\n        opt = opt || {};\n\n        var xml;\n\n        try {\n            var parser = new DOMParser();\n\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n\n            xml = parser.parseFromString(data, 'text/xml');\n        } catch (error) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\n            throw new Error('Invalid XML: ' + data);\n        }\n\n        return xml;\n    };\n\n    // Create an empty object which does not inherit any properties from `Object.prototype`.\n    // This is useful when we want to use an object as a dictionary without having to\n    // worry about inherited properties such as `toString`, `valueOf` etc.\n    const _attributeNames = Object.create(null);\n\n    // List of attributes for which not to split camel case words.\n    // It contains known SVG attribute names and may be extended with user-defined attribute names.\n    [\n        'baseFrequency',\n        'baseProfile',\n        'clipPathUnits',\n        'contentScriptType',\n        'contentStyleType',\n        'diffuseConstant',\n        'edgeMode',\n        'externalResourcesRequired',\n        'filterRes', // deprecated\n        'filterUnits',\n        'gradientTransform',\n        'gradientUnits',\n        'kernelMatrix',\n        'kernelUnitLength',\n        'keyPoints',\n        'lengthAdjust',\n        'limitingConeAngle',\n        'markerHeight',\n        'markerUnits',\n        'markerWidth',\n        'maskContentUnits',\n        'maskUnits',\n        'numOctaves',\n        'pathLength',\n        'patternContentUnits',\n        'patternTransform',\n        'patternUnits',\n        'pointsAtX',\n        'pointsAtY',\n        'pointsAtZ',\n        'preserveAlpha',\n        'preserveAspectRatio',\n        'primitiveUnits',\n        'refX',\n        'refY',\n        'requiredExtensions',\n        'requiredFeatures',\n        'specularConstant',\n        'specularExponent',\n        'spreadMethod',\n        'startOffset',\n        'stdDeviation',\n        'stitchTiles',\n        'surfaceScale',\n        'systemLanguage',\n        'tableValues',\n        'targetX',\n        'targetY',\n        'textLength',\n        'viewBox',\n        'viewTarget', // deprecated\n        'xChannelSelector',\n        'yChannelSelector',\n        'zoomAndPan' // deprecated\n    ].forEach((name) => _attributeNames[name] = name);\n\n    _attributeNames['xlinkShow'] = 'xlink:show';\n    _attributeNames['xlinkRole'] = 'xlink:role';\n    _attributeNames['xlinkActuate'] = 'xlink:actuate';\n    _attributeNames['xlinkHref'] = 'xlink:href';\n    _attributeNames['xlinkType'] = 'xlink:type';\n    _attributeNames['xlinkTitle'] = 'xlink:title';\n    _attributeNames['xmlBase'] = 'xml:base';\n    _attributeNames['xmlLang'] = 'xml:lang';\n    _attributeNames['xmlSpace'] = 'xml:space';\n\n    const attributeNames = new Proxy(_attributeNames, {\n        get(cache, name) {\n            // The cache is a dictionary of attribute names. See `_attributeNames` above.\n            // If the attribute name is not in the cache, it means that it is not\n            // a camel-case attribute name. In that case, we need to convert\n            // the attribute name to dash-separated words.\n            if (!V.supportCamelCaseAttributes) return name;\n            if (name in cache) {\n                return cache[name];\n            }\n            // Convert camel case to dash-separated words.\n            return (cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n    });\n\n    // Dictionary of attribute names\n    Object.defineProperty(V, 'attributeNames', {\n        enumerable: true,\n        value: attributeNames,\n        writable: false,\n    });\n\n    // Should camel case attributes be supported?\n    Object.defineProperty(V, 'supportCamelCaseAttributes', {\n        enumerable: true,\n        value: true,\n        writable: true,\n    });\n\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */\n    V.qualifyAttr = function(name) {\n\n        if (name.indexOf(':') !== -1) {\n            var combinedKey = name.split(':');\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n\n        return {\n            ns: null,\n            local: name\n        };\n    };\n\n    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n    // This regex is used by `split()`, so it doesn't need to use /g\n    V.transformSeparatorRegex = /[ ,]+/;\n    // Note: All following regexes are more restrictive than SVG specification\n    // ReDoS mitigation: Use an anchor at the beginning of the match\n    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n    // ReDoS mitigation: Don't match initial `(` inside repeated part\n    // The following regex needs to use /g (= cannot use capturing groups)\n    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n    // The following regexes need to use capturing groups (= cannot use /g)\n    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\n    V.transformStringToMatrix = function(transform) {\n\n        // Initialize result matrix as identity matrix\n        let transformationMatrix = V.createSVGMatrix();\n\n        // Note: Multiple transform functions are allowed in `transform` string\n        // `match()` returns `null` if none found\n        const transformMatches = transform && transform.match(V.transformRegex);\n        if (!transformMatches) {\n            // Return identity matrix\n            return transformationMatrix;\n        }\n\n        const numMatches = transformMatches.length;\n        for (let i = 0; i < numMatches; i++) {\n\n            const transformMatch = transformMatches[i];\n            // Use same regex as above, but with capturing groups\n            // `match()` returns values of capturing groups as `[1]`, `[2]`\n            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n            if (transformFunctionMatch) {\n\n                let sx, sy, tx, ty, angle;\n                let ctm = V.createSVGMatrix();\n                const transformFunction = transformFunctionMatch[1].toLowerCase();\n                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                switch (transformFunction) {\n\n                    case 'scale':\n                        sx = parseFloat(args[0]);\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n\n                    case 'translate':\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n\n                    case 'rotate':\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n\n                    case 'skewx':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n\n                    case 'skewy':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n\n                    case 'matrix':\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n\n                    default:\n                        continue;\n                }\n\n                // Multiply current transformation into result matrix\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n\n        }\n        return transformationMatrix;\n    };\n\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n\n        return 'matrix(' +\n            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n            (matrix.f !== undefined ? matrix.f : 0) +\n            ')';\n    };\n\n    V.parseTransformString = function(transform) {\n\n        var translate, rotate, scale;\n\n        if (transform) {\n\n            var separator = V.transformSeparatorRegex;\n\n            // Special handling for `transform` with one or more matrix functions\n            if (transform.trim().indexOf('matrix') >= 0) {\n\n                // Convert EVERYTHING in `transform` string to a matrix\n                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                // Note: In non-matrix case, we only take first one of each (if any)\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n                // Extract `translate`, `scale`, `rotate` from matrix\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n                rotate = [decomposedMatrix.rotation];\n\n                // Rewrite `transform` string in `translate scale rotate` format\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push('translate(' + translate + ')');\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push('scale(' + scale + ')');\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push('rotate(' + rotate + ')');\n                }\n                transform = transformations.join(' ');\n\n            } else {\n\n                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                // Note: We only detect the first match of each (if any)\n                // `match()` returns value of capturing group as `[1]`\n                const translateMatch = transform.match(V.transformTranslateRegex);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                const rotateMatch = transform.match(V.transformRotateRegex);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                const scaleMatch = transform.match(V.transformScaleRegex);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n        return {\n            value: transform,\n            translate: {\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n\n    V.deltaTransformPoint = function(matrix, point) {\n\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return { x: dx, y: dy };\n    };\n\n    V.decomposeMatrix = function(matrix) {\n\n        // @see https://gist.github.com/2052247\n\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n        // calculate skew\n        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n        return {\n\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n\n        var p = { x: 0, y: 1 };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n\n        return {\n            angle: g.normalizeAngle(g.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n\n        return {\n            tx: (matrix && matrix.e) || 0,\n            ty: (matrix && matrix.f) || 0\n        };\n    };\n\n    V.isV = function(object) {\n\n        return object instanceof V;\n    };\n\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n    };\n\n    var svgDocument = V('svg').node;\n\n    V.createSVGMatrix = function(matrix) {\n\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for (var component in matrix) {\n            svgMatrix[component] = matrix[component];\n        }\n\n        return svgMatrix;\n    };\n\n    V.createSVGTransform = function(matrix) {\n\n        if (!V.isUndefined(matrix)) {\n\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n\n        return svgDocument.createSVGTransform();\n    };\n\n    V.createSVGPoint = function(x, y) {\n\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n\n    V.transformRect = function(r, matrix) {\n\n        var p = svgDocument.createSVGPoint();\n\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n        return new g.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n\n    V.transformPoint = function(p, matrix) {\n\n        return new g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n\n    V.transformLine = function(l, matrix) {\n\n        return new g.Line(\n            V.transformPoint(l.start, matrix),\n            V.transformPoint(l.end, matrix)\n        );\n    };\n\n    V.transformPolyline = function(p, matrix) {\n\n        var inPoints = (p instanceof g.Polyline) ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new g.Polyline(outPoints);\n    };\n\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(';');\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            var pair = style.split('=');\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? '0' : '1';\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n\n        return (da >= svgArcMax)\n            ? (r0\n                ? 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'M0,' + r0\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n                + 'Z'\n                : 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'Z')\n            : (r0\n                ? 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L' + r0 * c1 + ',' + r0 * s1\n                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n                + 'Z'\n                : 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L0,0'\n                + 'Z');\n    };\n\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n\n        for (var attr in b) {\n\n            if (attr === 'class') {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n            } else if (attr === 'style') {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n\n        return a;\n    };\n\n    V.annotateString = function(t, annotations, opt) {\n\n        annotations = annotations || [];\n        opt = opt || {};\n\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n\n        for (var i = 0; i < t.length; i++) {\n\n            item = ret[i] = t[i];\n\n            for (var j = 0; j < annotations.length; j++) {\n\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n\n            prev = ret[i - 1];\n\n            if (!prev) {\n\n                batch = item;\n\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || '') + item;\n            }\n        }\n\n        if (batch) {\n            compacted.push(batch);\n        }\n\n        return compacted;\n    };\n\n    V.findAnnotationsAtIndex = function(annotations, index) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n\n        return annotations;\n    };\n\n    V.convertLineToPathData = function(line) {\n\n        line = V(line);\n        var d = [\n            'M', line.attr('x1'), line.attr('y1'),\n            'L', line.attr('x2'), line.attr('y2')\n        ].join(' ');\n        return d;\n    };\n\n    V.convertPolygonToPathData = function(polygon) {\n\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points) + ' Z';\n    };\n\n    V.convertPolylineToPathData = function(polyline) {\n\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points);\n    };\n\n    V.svgPointsToPath = function(points) {\n\n        for (var i = 0, n = points.length; i < n; i++) {\n            points[i] = points[i].x + ' ' + points[i].y;\n        }\n\n        return 'M ' + points.join(' L');\n    };\n\n    V.getPointsFromSvgNode = function(node) {\n\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n                points.push(nodePoints.getItem(i));\n            }\n        }\n\n        return points;\n    };\n\n    V.KAPPA = 0.551784;\n\n    V.convertCircleToPathData = function(circle) {\n\n        circle = V(circle);\n        var cx = parseFloat(circle.attr('cx')) || 0;\n        var cy = parseFloat(circle.attr('cy')) || 0;\n        var r = parseFloat(circle.attr('r'));\n        var cd = r * V.KAPPA; // Control distance.\n\n        var d = [\n            'M', cx, cy - r,    // Move to the first point.\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertEllipseToPathData = function(ellipse) {\n\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\n        var rx = parseFloat(ellipse.attr('rx'));\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n\n        var d = [\n            'M', cx, cy - ry,    // Move to the first point.\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertRectToPathData = function(rect) {\n\n        rect = V(rect);\n\n        return V.rectToPath({\n            x: parseFloat(rect.attr('x')) || 0,\n            y: parseFloat(rect.attr('y')) || 0,\n            width: parseFloat(rect.attr('width')) || 0,\n            height: parseFloat(rect.attr('height')) || 0,\n            rx: parseFloat(rect.attr('rx')) || 0,\n            ry: parseFloat(rect.attr('ry')) || 0\n        });\n    };\n\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                'M', x, y + topRy,\n                'v', height - topRy - bottomRy,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n                'h', width - 2 * bottomRx,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n                'v', -(height - bottomRy - topRy),\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n                'h', -(width - 2 * topRx),\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n                'Z'\n            ];\n        } else {\n            d = [\n                'M', x, y,\n                'H', x + width,\n                'V', y + height,\n                'H', x,\n                'V', y,\n                'Z'\n            ];\n        }\n\n        return d.join(' ');\n    };\n\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = (function() {\n\n        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n\n        function q2c(x1, y1, ax, ay, x2, y2) {\n\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n        }\n\n        function rotate(x, y, rad) {\n\n            var X = (x * cos(rad)) - (y * sin(rad));\n            var Y = (x * sin(rad)) + (y * cos(rad));\n            return { x: X, y: Y };\n        }\n\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = (PI * 120) / 180;\n            var rad = (PI / 180) * (+angle || 0);\n            var res = [];\n            var xy;\n\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n\n                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n                if (!Number.isFinite(k)) {\n                    // Arc is a single point\n                    return [x1, y1, x2, y2, x2, y2];\n                }\n\n                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = ((x1 < cx) ? (PI - f1) : f1);\n                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n                if (f1 < 0) f1 = (PI * 2) + f1;\n                if (f2 < 0) f2 = (PI * 2) + f2;\n\n                if (sweep_flag && (f1 > f2)) f1 = f1 - (PI * 2);\n                if (!sweep_flag && (f2 > f1)) f2 = f2 - (PI * 2);\n\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n                x2 = cx + (rx * cos(f2));\n                y2 = cy + (ry * sin(f2));\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = (4 / 3) * (rx * t);\n            var hy = (4 / 3) * (ry * t);\n            var m1 = [x1, y1];\n            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n            var m4 = [x2, y2];\n\n            m2[0] = (2 * m1[0]) - m2[0];\n            m2[1] = (2 * m1[1]) - m2[1];\n\n            if (recursive) {\n                return [m2, m3, m4].concat(res);\n            } else {\n                res = [m2, m3, m4].concat(res).join().split(',');\n                var newres = [];\n                var ii = res.length;\n                for (var i = 0; i < ii; i++) {\n                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n\n        function parsePathString(pathString) {\n\n            if (!pathString) return null;\n\n            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n            var data = [];\n\n            String(pathString).replace(pathCommand, function(a, b, c) {\n\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n\n                if ((name === 'm') && (params.length > 2)) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = 'l';\n                    b = ((b === 'm') ? 'l' : 'L');\n                }\n\n                while (params.length >= paramCounts[name]) {\n                    data.push([b].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n\n            return data;\n        }\n\n        function pathToAbsolute(pathArray) {\n\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n                pathArray = parsePathString(pathArray);\n            }\n\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n\n            var ii = pathArray.length;\n            for (var i = start; i < ii; i++) {\n\n                var r = [];\n                res.push(r);\n\n                var pa = pathArray[i];\n                pa0 = pa[0];\n\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n\n                    var jj;\n                    var j;\n                    switch (r[0]) {\n                        case 'A':\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n\n                        case 'V':\n                            r[1] = +pa[1] + y;\n                            break;\n\n                        case 'H':\n                            r[1] = +pa[1] + x;\n                            break;\n\n                        case 'M':\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n\n                        default:\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for (var k = 0; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n\n                switch (r[0]) {\n                    case 'Z':\n                        x = +mx;\n                        y = +my;\n                        break;\n\n                    case 'H':\n                        x = r[1];\n                        break;\n\n                    case 'V':\n                        y = r[1];\n                        break;\n\n                    case 'M':\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n\n            return res;\n        }\n\n        function normalize(path) {\n\n            var p = pathToAbsolute(path);\n            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n            function processPath(path, d, pcom) {\n\n                var nx, ny;\n\n                if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n                if (!(path[0] in { T: 1, Q: 1 })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n\n                switch (path[0]) {\n                    case 'M':\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n\n                    case 'A':\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = ['L', path[6], path[7]];\n                        } else {\n                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        }\n                        break;\n\n                    case 'S':\n                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n                        } else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = ['C', nx, ny].concat(path.slice(1));\n                        break;\n\n                    case 'T':\n                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n                        } else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n\n                    case 'Q':\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n\n                    case 'H':\n                        path = ['L'].concat(path[1], d.y);\n                        break;\n\n                    case 'V':\n                        path = ['L'].concat(d.x, path[1]);\n                        break;\n\n                    case 'L':\n                        break;\n\n                    case 'Z':\n                        break;\n                }\n\n                return path;\n            }\n\n            function fixArc(pp, i) {\n\n                if (pp[i].length > 7) {\n\n                    pp[i].shift();\n                    var pi = pp[i];\n\n                    while (pi.length) {\n                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n                    }\n\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n\n            var pcoms = []; // path commands of original path p\n            var pfirst = ''; // temporary holder for original path command\n            var pcom = ''; // holder for previous path command of original path\n\n            var ii = p.length;\n            for (var i = 0; i < ii; i++) {\n                if (p[i]) pfirst = p[i][0]; // save current path command\n\n                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n                var seg = p[i];\n                var seglen = seg.length;\n\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== 'M') {\n                p.unshift(['M', 0, 0]);\n            }\n\n            return p;\n        }\n\n        return function(pathData) {\n            return normalize(pathData).join(',').split(',').join(' ');\n        };\n    })();\n\n    V.namespace = ns;\n\n    V.g = g;\n\n    return V;\n\n})();\n\nexport default V;\n", "// code is inspired by https://github.com/lodash/lodash\n\n/* eslint-disable no-case-declarations */\n// -- helper constants\nconst argsTag = '[object Arguments]';\nconst arrayTag = '[object Array]';\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst funcTag = '[object Function]';\nconst mapTag = '[object Map]';\nconst numberTag = '[object Number]';\nconst nullTag = '[object Null]';\nconst objectTag = '[object Object]';\nconst regexpTag = '[object RegExp]';\nconst setTag = '[object Set]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst undefinedTag = '[object Undefined]';\nconst weakMapTag = '[object WeakMap]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst dataViewTag = '[object DataView]';\nconst float32Tag = '[object Float32Array]';\nconst float64Tag = '[object Float64Array]';\nconst int8Tag = '[object Int8Array]';\nconst int16Tag = '[object Int16Array]';\nconst int32Tag = '[object Int32Array]';\nconst uint8Tag = '[object Uint8Array]';\nconst uint8ClampedTag = '[object Uint8ClampedArray]';\nconst uint16Tag = '[object Uint16Array]';\nconst uint32Tag = '[object Uint32Array]';\n\nconst CLONEABLE_TAGS = {\n    [argsTag]: true,\n    [arrayTag]: true,\n    [arrayBufferTag]: true,\n    [dataViewTag]: true,\n    [boolTag]: true,\n    [dateTag]: true,\n    [float32Tag]: true,\n    [float64Tag]: true,\n    [int8Tag]: true,\n    [int16Tag]: true,\n    [int32Tag]: true,\n    [mapTag]: true,\n    [numberTag]: true,\n    [objectTag]: true,\n    [regexpTag]: true,\n    [setTag]: true,\n    [stringTag]: true,\n    [symbolTag]: true,\n    [uint8Tag]: true,\n    [uint8ClampedTag]: true,\n    [uint16Tag]: true,\n    [uint32Tag]: true,\n    [errorTag]: false,\n    [funcTag]: false,\n    [weakMapTag]: false,\n};\n\n/** Used to compose unicode character classes. */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f';\nconst reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nconst rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff';\nconst rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff';\nconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\nconst rsDingbatRange = '\\\\u2700-\\\\u27bf';\nconst rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff';\nconst rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7';\nconst rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf';\nconst rsPunctuationRange = '\\\\u2000-\\\\u206f';\nconst rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000';\nconst rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\nconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nconst rsApos = '[\\'\\u2019]';\nconst rsBreak = `[${rsBreakRange}]`;\nconst rsCombo = `[${rsComboRange}]`;\nconst rsDigit = '\\\\d';\nconst rsDingbat = `[${rsDingbatRange}]`;\nconst rsLower = `[${rsLowerRange}]`;\nconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsUpper = `[${rsUpperRange}]`;\nconst rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nconst rsMiscLower = `(?:${rsLower}|${rsMisc})`;\nconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;\nconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;\nconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`;\nconst rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])';\nconst rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;\n\nconst reUnicodeWords = RegExp([\n    `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`,\n    `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`,\n    `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,\n    `${rsUpper}+${rsOptContrUpper}`,\n    rsOrdUpper,\n    rsOrdLower,\n    `${rsDigit}+`,\n    rsEmoji\n].join('|'), 'g');\n\nconst LARGE_ARRAY_SIZE = 200;\nconst HASH_UNDEFINED = '__hash_undefined__';\n\n// Used to match `toStringTag` values of typed arrays\nconst reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n\n// Used to compose unicode capture groups\nconst rsAstral = `[${rsAstralRange}]`;\n\n// Used to compose unicode regexes\nconst rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;\nconst rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})`;\n\n// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, 'g');\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n    , 'g');\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\nconst hasUnicodeWord = RegExp.prototype.test.bind(\n    /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/\n);\n\nconst MAX_ARRAY_INDEX = 4294967295 - 1;\n\n/** Used to match words composed of alphanumeric characters. */\n// eslint-disable-next-line no-control-regex\nconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n\n\n// -- helper functions\nconst hasUnicode = (string) => {\n    return reUnicode.test(string);\n};\n\nconst unicodeToArray = (string) => {\n    return string.match(reUnicode) || [];\n};\n\nconst asciiToArray = (string) => {\n    return string.split('');\n};\n\nconst stringToArray = (string) => {\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n};\n\nconst values = (object) => {\n    if (object == null) {\n        return [];\n    }\n\n    return keys(object).map((key) => object[key]);\n};\n\nconst keys = (object) => {\n    return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n};\n\nconst baseKeys = (object) => {\n    if (!isPrototype(object)) {\n        return Object.keys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n            result.push(key);\n        }\n    }\n\n    return result;\n};\n\nconst arrayLikeKeys = (value, inherited) => {\n    const isArr = Array.isArray(value);\n    const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n    const isType = !isArr && !isArg && isTypedArray(value);\n    const skipIndexes = isArr || isArg || isType;\n    const length = value.length;\n    const result = new Array(skipIndexes ? length : 0);\n    let index = skipIndexes ? -1 : length;\n    while (++index < length) {\n        result[index] = `${index}`;\n    }\n    for (const key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n                // Safari 9 has enumerable `arguments.length` in strict mode.\n                key === 'length' ||\n                // Skip index properties.\n                isIndex(key, length)\n            ))\n        ) {\n            result.push(key);\n        }\n    }\n    return result;\n};\n\nconst assocIndexOf = (array, key) => {\n    let { length } = array;\n    while (length--) {\n        if (eq(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n};\n\nconst eq = (value, other) => {\n    return value === other || (value !== value && other !== other);\n};\n\nconst isObjectLike = (value) => {\n    return value != null && typeof value == 'object';\n};\n\nconst isIterateeCall = (value, index, object) => {\n    if (!isObject(object)) {\n        return false;\n    }\n    const type = typeof index;\n\n    const isPossibleIteratee = type == 'number' ?\n        (isArrayLike(object) && index > -1 && index < object.length) :\n        (type == 'string' && index in object);\n\n    if (isPossibleIteratee) {\n        return eq(object[index], value);\n    }\n    return false;\n};\n\nconst isSet = (value) => {\n    return isObjectLike(value) && getTag(value) == setTag;\n};\n\nconst isMap = (value) => {\n    return isObjectLike(value) && getTag(value) == mapTag;\n};\n\nconst isPrototype = (value) => {\n    const Ctor = value && value.constructor;\n    const proto = (typeof Ctor === 'function' && Ctor.prototype) || Object.prototype;\n\n    return value === proto;\n};\n\nconst assignValue = (object, key, value) => {\n    const objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n        object[key] = value;\n    }\n};\n\nconst copyObject = (source, props, object) => {\n    let index = -1;\n    const length = props.length;\n\n    while (++index < length) {\n        const key = props[index];\n        assignValue(object, key, source[key]);\n    }\n    return object;\n};\n\nconst isArrayLike = (value) => {\n    return value != null && typeof value !== 'function' && typeof value.length === 'number' &&\n        value.length > -1 && value.length % 1 === 0;\n};\n\nconst isSymbol = (value) => {\n    return typeof value == 'symbol' ||\n        (isObjectLike(value) && getTag(value) === symbolTag);\n};\n\nconst initCloneArray = (array) => {\n    const length = array.length;\n    let result = new array.constructor(length);\n\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n    }\n\n    return result;\n};\n\nconst copyArray = (source, array) => {\n    let index = -1;\n    const length = source.length;\n\n    array || (array = new Array(length));\n    while (++index < length) {\n        array[index] = source[index];\n    }\n    return array;\n};\n\nconst getTag = (value) => {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return Object.prototype.toString.call(value);\n};\n\nconst cloneArrayBuffer = (arrayBuffer) => {\n    const result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n};\n\nconst cloneTypedArray = (typedArray, isDeep) => {\n    const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n};\n\nconst cloneRegExp = (regexp) =>{\n    const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n};\n\nconst initCloneObject = (object) => {\n    return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? Object.create(Object.getPrototypeOf(object))\n        : {};\n};\n\nconst getSymbols = (object) => {\n    if (object == null) {\n        return [];\n    }\n\n    object = Object(object);\n    const symbols = Object.getOwnPropertySymbols(object);\n\n    return symbols.filter((symbol) => propertyIsEnumerable.call(object, symbol));\n};\n\nconst copySymbols = (source, object) => {\n    return copyObject(source, getSymbols(source), object);\n};\n\nfunction cloneDataView(dataView, isDeep) {\n    const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nconst initCloneByTag = (object, tag, isDeep) => {\n    const Constructor = object.constructor;\n    switch(tag) {\n        case arrayBufferTag:\n            return cloneArrayBuffer(object);\n        case boolTag:\n        case dateTag:\n            return new Constructor(+object);\n        case dataViewTag:\n            return cloneDataView(object, isDeep);\n        case float32Tag:\n        case float64Tag:\n        case int8Tag:\n        case int16Tag:\n        case int32Tag:\n        case uint8Tag:\n        case uint8ClampedTag:\n        case uint16Tag:\n        case uint32Tag:\n            return cloneTypedArray(object, isDeep);\n        case mapTag:\n            return new Constructor(object);\n        case numberTag:\n        case stringTag:\n            return new Constructor(object);\n        case regexpTag:\n            return cloneRegExp(object);\n        case setTag:\n            return new Constructor;\n        case symbolTag:\n            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n    }\n};\n\nconst isTypedArray = (value) => {\n    return isObjectLike(value) && reTypedTag.test(getTag(value));\n};\n\nconst getAllKeys = (object) => {\n    const result = Object.keys(object);\n    if(!Array.isArray(object) && object != null) {\n        result.push(...getSymbols(Object(object)));\n    }\n\n    return result;\n};\n\nconst getSymbolsIn = (object) => {\n    const result = [];\n    while (object) {\n        result.push(...getSymbols(object));\n        object = Object.getPrototypeOf(Object(object));\n    }\n\n    return result;\n};\n\nconst getAllKeysIn = (object) => {\n    const result = [];\n\n    for (const key in object) {\n        result.push(key);\n    }\n\n    if (!Array.isArray(object)) {\n        result.push(...getSymbolsIn(object));\n    }\n\n    return result;\n};\n\nconst getMapData = ({ __data__ }, key) => {\n    const data = __data__;\n    return isKeyable(key)\n        ? data[typeof key === 'string' ? 'string' : 'hash']\n        : data.map;\n};\n\nconst equalObjects = (object, other, equalFunc, stack) => {\n    const objProps = getAllKeys(object);\n    const objLength = objProps.length;\n    const othProps = getAllKeys(other);\n    const othLength = othProps.length;\n\n    if (objLength != othLength) {\n        return false;\n    }\n    let key;\n    let index = objLength;\n    while (index--) {\n        key = objProps[index];\n        if (!(hasOwnProperty.call(other, key))) {\n            return false;\n        }\n    }\n\n    const objStacked = stack.get(object);\n    const othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    let result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n\n    let compared;\n    let skipCtor;\n\n    while (++index < objLength) {\n        key = objProps[index];\n        const objValue = object[key];\n        const othValue = other[key];\n\n        if (!(compared === undefined\n            ? (objValue === othValue || equalFunc(objValue, othValue, stack))\n            : compared\n        )) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n    }\n\n    if (result && !skipCtor) {\n        const objCtor = object.constructor;\n        const othCtor = other.constructor;\n\n        if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor === 'function' && objCtor instanceof objCtor &&\n            typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n};\n\nconst baseIsEqual = (value, other, stack) => {\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n    }\n\n    return baseIsEqualDeep(value, other, baseIsEqual, stack);\n};\n\nconst baseIsEqualDeep = (object, other, equalFunc, stack) => {\n    let objIsArr = Array.isArray(object);\n    const othIsArr = Array.isArray(other);\n    let objTag = objIsArr ? arrayTag : getTag(object);\n    let othTag = othIsArr ? arrayTag : getTag(other);\n\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n\n    let objIsObj = objTag == objectTag;\n    const othIsObj = othTag == objectTag;\n    const isSameTag = objTag == othTag;\n\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n            ? equalArrays(object, other, false, equalFunc, stack)\n            : equalByTag(object, other, objTag, equalFunc, stack);\n    }\n\n    const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');\n    const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n        const objUnwrapped = objIsWrapped ? object.value() : object;\n        const othUnwrapped = othIsWrapped ? other.value() : other;\n\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, stack);\n    }\n\n    if (!isSameTag) {\n        return false;\n    }\n\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, stack);\n};\n\nconst equalArrays = (array, other, compareUnordered, equalFunc, stack) => {\n    const isPartial = false;\n    const arrLength = array.length;\n    const othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Assume cyclic values are equal.\n    const arrStacked = stack.get(array);\n    const othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    let index = -1;\n    let result = true;\n    const seen = compareUnordered ? new SetCache : undefined;\n\n    stack.set(array, other);\n    stack.set(other, array);\n\n    while (++index < arrLength) {\n        let compared;\n        const arrValue = array[index];\n        const othValue = other[index];\n\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n\n        if (seen) {\n            if (!some(other, (othValue, othIndex) => {\n                if (!cacheHas(seen, othIndex) &&\n            (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(\n            arrValue === othValue ||\n            equalFunc(arrValue, othValue, stack)\n        )) {\n            result = false;\n            break;\n        }\n    }\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n};\n\nconst some = (array, predicate) => {\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst cacheHas = (cache, key) => {\n    return cache.has(key);\n};\n\nconst compareArrayBufferTag = (object, other, equalFunc, stack) => {\n    if ((object.byteLength != other.byteLength) ||\n                !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n        return false;\n    }\n    return true;\n};\n\nconst equalByTag = (object, other, tag, equalFunc, stack) => {\n\n    switch (tag) {\n        case dataViewTag:\n            if ((object.byteLength != other.byteLength) ||\n                (object.byteOffset != other.byteOffset)) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case arrayBufferTag:\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case boolTag:\n        case dateTag:\n        case numberTag:\n            return eq(+object, +other);\n        case errorTag:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n            return object == `${other}`;\n        case mapTag:\n            // This use of 'var' is intentional. Don't remove if replacing all instances.\n            var convert = mapToArray;\n        // Intentional fallthrough\n        // eslint-disable-next-line no-fallthrough\n        case setTag:\n            convert || (convert = setToArray);\n\n            if (object.size != other.size) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            const stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n            stack['delete'](object);\n            return result;\n        case symbolTag:\n            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n    }\n\n    return false;\n};\n\nconst mapToArray = (map) => {\n    let index = -1;\n    let result = Array(map.size);\n\n    map.forEach((value, key) => {\n        result[++index] = [key, value];\n    });\n    return result;\n};\n\nconst setToArray = (set) => {\n    let index = -1;\n    const result = new Array(set.size);\n\n    set.forEach((value) => {\n        result[++index] = value;\n    });\n    return result;\n};\n\nconst isKey = (value, object) => {\n    if (Array.isArray(value)) {\n        return false;\n    }\n    const type = typeof value;\n    if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n};\n\nconst stringToPath = (string) => {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push('');\n    }\n    string.replace(rePropName, (match, expression, quote, subString) => {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, '$1');\n        }\n        else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n    });\n    return result;\n};\n\nconst castPath = (path, object) => {\n    if (Array.isArray(path)) {\n        return path;\n    }\n\n    return isKey(path, object) ? [path] : stringToPath(`${path}`);\n};\n\nconst get = (object, path) => {\n    path = castPath(path, object);\n\n    let index = 0;\n    const length = path.length;\n\n    while (object != null && index < length) {\n        object = object[toKey(path[index])];\n        index++;\n    }\n\n    return (index && index == length) ? object : undefined;\n};\n\nfunction compareAscending(value, other) {\n    if (value !== other) {\n        const valIsDefined = value !== undefined;\n        const valIsNull = value === null;\n        const valIsReflexive = value === value;\n        const valIsSymbol = isSymbol(value);\n\n        const othIsDefined = other !== undefined;\n        const othIsNull = other === null;\n        const othIsReflexive = other === other;\n        const othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n            return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nfunction compareMultiple(object, other, orders) {\n    let index = -1;\n    const objCriteria = object.criteria;\n    const othCriteria = other.criteria;\n    const length = objCriteria.length;\n    const ordersLength = orders.length;\n\n    while (++index < length) {\n        const order = index < ordersLength ? orders[index] : null;\n        const cmpFn = (order && typeof order === 'function') ? order : compareAscending;\n        const result = cmpFn(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (order && typeof order !== 'function') {\n                return result * (order == 'desc' ? -1 : 1);\n            }\n            return result;\n        }\n    }\n\n    return object.index - other.index;\n}\n\nconst diff = (array, values) => {\n    let includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    let isCommon = true;\n    const result = [];\n    const valuesLength = values.length;\n\n    if (!array.length) {\n        return result;\n    }\n\n    if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = (cache, key) => cache.has(key);\n        isCommon = false;\n        values = new SetCache(values);\n    }\n\n    outer:\n    for (let key in array) {\n        let value = array[key];\n        const computed = value;\n\n        value = (value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n            let valuesIndex = valuesLength;\n            while (valuesIndex--) {\n                if (values[valuesIndex] === computed) {\n                    continue outer;\n                }\n            }\n            result.push(value);\n        }\n        else if (!includes(values, computed)) {\n            result.push(value);\n        }\n    }\n\n    return result;\n};\n\nconst intersect = (arrays) => {\n    const includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    const cacheHas = (cache, key) => cache.has(key);\n    const length = arrays[0].length;\n    const othLength = arrays.length;\n    const caches = new Array(othLength);\n    const result = [];\n\n    let array;\n    let maxLength = Infinity;\n    let othIndex = othLength;\n\n    while (othIndex--) {\n        array = arrays[othIndex];\n\n        maxLength = Math.min(array.length, maxLength);\n        caches[othIndex] = length >= 120 && array.length >= 120\n            ? new SetCache(othIndex && array)\n            : undefined;\n    }\n    array = arrays[0];\n\n    let index = -1;\n    const seen = caches[0];\n\n    outer:\n    while (++index < length && result.length < maxLength) {\n        let value = array[index];\n        const computed = value;\n\n        value = (value !== 0) ? value : 0;\n        if (!(seen\n            ? cacheHas(seen, computed)\n            : includes(result, computed)\n        )) {\n            othIndex = othLength;\n            while (--othIndex) {\n                const cache = caches[othIndex];\n                if (!(cache\n                    ? cacheHas(cache, computed)\n                    : includes(arrays[othIndex], computed))\n                ) {\n                    continue outer;\n                }\n            }\n            if (seen) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nconst toKey = (value) => {\n    if (typeof value === 'string' || isSymbol(value)) {\n        return value;\n    }\n    const result = `${value}`;\n    return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;\n};\n\nconst baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {\n    let result;\n\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n\n    if (result !== undefined) {\n        return result;\n    }\n\n    if (!isObject(value)) {\n        return value;\n    }\n\n    const isArr = Array.isArray(value);\n    const tag = getTag(value);\n\n    if (isArr) {\n        result = initCloneArray(value);\n\n        if (!isDeep) {\n            return copyArray(value, result);\n        }\n    } else {\n        const isFunc = typeof value === 'function';\n\n        if (tag === objectTag || tag === argsTag || (isFunc && !object)) {\n            result = (isFlat || isFunc) ? {} : initCloneObject(value);\n            if (!isDeep) {\n                return isFlat ?\n                    copySymbolsIn(value, copyObject(value, Object.keys(value), result)) :\n                    copySymbols(value, Object.assign(result, value));\n            }\n        } else {\n            if (isFunc || !CLONEABLE_TAGS[tag]) {\n                return object ? value : {};\n            }\n            result = initCloneByTag(value, tag, isDeep);\n        }\n    }\n\n    stack || (stack = new Stack);\n    const stacked = stack.get(value);\n\n    if (stacked) {\n        return stacked;\n    }\n\n    stack.set(value, result);\n\n    if (isMap(value)) {\n        value.forEach((subValue, key) => {\n            result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n        });\n\n        return result;\n    }\n\n    if (isSet(value)) {\n        value.forEach(subValue => {\n            result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n        });\n\n        return result;\n    }\n\n    if(isTypedArray(value)) {\n        return result;\n    }\n\n    const keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n    const props =  isArr ? undefined : keysFunc(value);\n\n    (props || value).forEach((subValue, key) => {\n        if (props) {\n            key = subValue;\n            subValue = value[key];\n        }\n\n        assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n    });\n\n    return result;\n};\n\nconst copySymbolsIn = (source, object) => {\n    return copyObject(source, getSymbolsIn(source), object);\n};\n\nconst parent = (object, path) => {\n    return path.length < 2 ? object : get(object, path.slice(0, -1));\n};\n\nconst set = (object, path, value) => {\n    if (!isObject(object)) {\n        return object;\n    }\n    path = castPath(path, object);\n\n    const length = path.length;\n    const lastIndex = length - 1;\n\n    let index = -1;\n    let nested = object;\n\n    while (nested != null && ++index < length) {\n        const key = toKey(path[index]);\n        let newValue = value;\n\n        if (index != lastIndex) {\n            const objValue = nested[key];\n            newValue = undefined;\n            if (newValue === undefined) {\n                newValue = isObject(objValue)\n                    ? objValue\n                    : (isIndex(path[index + 1]) ? [] : {});\n            }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n    }\n    return object;\n};\n\nconst isIndex = (value, length) => {\n    const type = typeof value;\n    length = length == null ? Number.MAX_SAFE_INTEGER : length;\n\n    return !!length &&\n    (type === 'number' ||\n        (type !== 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n};\n\nconst unset = (object, path) => {\n    path = castPath(path, object);\n    object = parent(object, path);\n    const lastSegment = path[path.length - 1];\n    return object == null || delete object[toKey(lastSegment)];\n};\n\nconst isKeyable = (value) => {\n    const type = typeof value;\n    return (type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n};\n\nconst keysIn = (object) => {\n    const result = [];\n    for (const key in object) {\n        result.push(key);\n    }\n    return result;\n};\n\nconst toPlainObject = (value) => {\n    value = Object(value);\n    const result = {};\n    for (const key in value) {\n        result[key] = value[key];\n    }\n    return result;\n};\n\nconst safeGet = (object, key) => {\n    if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n    }\n\n    if (key == '__proto__') {\n        return;\n    }\n\n    return object[key];\n};\n\nfunction createAssigner(assigner, isMerge = false) {\n    return (object, ...sources) => {\n        let index = -1;\n        let length = sources.length;\n        let customizer = length > 1 ? sources[length - 1] : undefined;\n        const guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer === 'function')\n            ? (length--, customizer)\n            : isMerge ? (a, b) => {\n                if (Array.isArray(a) && !Array.isArray(b)) {\n                    return b;\n                }\n            } : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n            customizer = length < 3 ? undefined : customizer;\n            length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n            const source = sources[index];\n            if (source) {\n                assigner(object, source, index, customizer);\n            }\n        }\n        return object;\n    };\n}\n\nconst baseMerge = (object, source, srcIndex, customizer, stack) => {\n    if (object === source) {\n        return;\n    }\n\n    forIn(source, (srcValue, key) => {\n        if (isObject(srcValue)) {\n            stack || (stack = new Stack);\n            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        } else {\n            let newValue = customizer\n                ? customizer(object[key], srcValue, `${key}`, object, source, stack)\n                : undefined;\n\n            if (newValue === undefined) {\n                newValue = srcValue;\n            }\n\n            assignMergeValue(object, key, newValue);\n        }\n    });\n};\n\nconst baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {\n    const objValue = safeGet(object, key);\n    const srcValue = safeGet(source, key);\n    const stacked = stack.get(srcValue);\n\n    if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n    }\n\n    let newValue = customizer\n        ? customizer(objValue, srcValue, `${key}`, object, source, stack)\n        : undefined;\n\n    let isCommon = newValue === undefined;\n\n    if (isCommon) {\n        const isArr = Array.isArray(srcValue);\n        const isTyped = !isArr && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isTyped) {\n            if (Array.isArray(objValue)) {\n                newValue = objValue;\n            }\n            else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n                newValue = copyArray(objValue);\n            }\n            else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n            }\n            else {\n                newValue = [];\n            }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n            newValue = objValue;\n            if (isArguments(objValue)) {\n                newValue = toPlainObject(objValue);\n            }\n            else if (typeof objValue === 'function' || !isObject(objValue)) {\n                newValue = initCloneObject(srcValue);\n            }\n        }\n        else {\n            isCommon = false;\n        }\n    }\n    if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n    }\n    assignMergeValue(object, key, newValue);\n};\n\nconst assignMergeValue = (object, key, value) => {\n    if ((value !== undefined && !eq(object[key], value)) ||\n        (value === undefined && !(key in object))) {\n        assignValue(object, key, value);\n    }\n};\n\nfunction baseFor(object, iteratee, keysFunc) {\n    const iterable = Object(object);\n    const props = keysFunc(object);\n    let { length } = props;\n    let index = -1;\n\n    while (length--) {\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n    return object;\n}\n\nconst baseForOwn = (object, iteratee) => {\n    return object && baseFor(object, iteratee, keys);\n};\n\nconst baseEach = (collection, iteratee) => {\n    if (collection == null) {\n        return collection;\n    }\n    if (!isArrayLike(collection)) {\n        return baseForOwn(collection, iteratee);\n    }\n    const length = collection.length;\n    const iterable = Object(collection);\n    let index = -1;\n\n    while (++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n        }\n    }\n    return collection;\n};\n\nfunction last(array) {\n    const length = array == null ? 0 : array.length;\n    return length ? array[length - 1] : undefined;\n}\n\nconst createSet = (Set && (1 / setToArray(new Set([undefined,-0]))[1]) == 1 / 0)\n    ? (values) => new Set(values)\n    : () => { /* no-op */ };\n\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n    if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n    }\n    return objValue;\n}\n\nfunction baseOrderBy(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = iteratees.map((iteratee) => {\n            if (Array.isArray(iteratee)) {\n                return (value) => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n\n            return iteratee;\n        });\n    } else {\n        iteratees = [(value) => value];\n    }\n\n    let criteriaIndex = -1;\n    let eachIndex = -1;\n\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n    baseEach(collection, (value) => {\n        const criteria = iteratees.map((iteratee) => iteratee(value));\n\n        result[++eachIndex] = {\n            criteria,\n            index: ++criteriaIndex,\n            value\n        };\n    });\n\n    return baseSortBy(result, (object, other) => compareMultiple(object, other, orders));\n}\n\nfunction baseSortBy(array, comparer) {\n    let { length } = array;\n\n    array.sort(comparer);\n    while (length--) {\n        array[length] = array[length].value;\n    }\n    return array;\n}\n\nfunction isStrictComparable(value) {\n    return value === value && !isObject(value);\n}\n\nfunction matchesStrictComparable(key, srcValue) {\n    return (object) => {\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue &&\n            (srcValue !== undefined || (key in Object(object)));\n    };\n}\n\nfunction hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\n\nfunction baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return (object) => {\n        const objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n            ? hasIn(object, path)\n            : baseIsEqual(srcValue, objValue);\n    };\n}\n\nfunction baseMatches(source) {\n    const matchData = getMatchData(source);\n    if (matchData.length === 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return (object) => object === source || baseIsMatch(object, source, matchData);\n}\n\nfunction getMatchData(object) {\n    const result = keys(object);\n    let length = result.length;\n\n    while (length--) {\n        const key = result[length];\n        const value = object[key];\n        result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n}\n\nfunction baseIsMatch(object, source, matchData, customizer) {\n    let index = matchData.length;\n    const length = index;\n    const noCustomizer = !customizer;\n\n    if (object == null) {\n        return !length;\n    }\n    let data;\n    let result;\n    object = Object(object);\n    while (index--) {\n        data = matchData[index];\n        if ((noCustomizer && data[2])\n            ? data[1] !== object[data[0]]\n            : !(data[0] in object)\n        ) {\n            return false;\n        }\n    }\n    while (++index < length) {\n        data = matchData[index];\n        const key = data[0];\n        const objValue = object[key];\n        const srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            const stack = new Stack;\n            if (customizer) {\n                result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, stack)\n                : result\n            )) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nfunction baseProperty(key) {\n    return (object) => object == null ? undefined : object[key];\n}\n\nfunction basePropertyDeep(path) {\n    return (object) => get(object, path);\n}\n\nfunction baseIteratee(value) {\n    if (typeof value == 'function') {\n        return value;\n    }\n    if (value == null) {\n        return (val) => val;\n    }\n    if (typeof value == 'object') {\n        return Array.isArray(value)\n            ? baseMatchesProperty(value[0], value[1])\n            : baseMatches(value);\n    }\n    return property(value);\n}\n\nfunction getIteratee() {\n    const result = baseIteratee;\n    return arguments.length ? result(arguments[0], arguments[1]) : result;\n}\n\nconst arrayReduce = (array, iteratee, accumulator, initAccum) => {\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n        accumulator = array[++index];\n    }\n    while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n};\n\nconst baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {\n    eachFunc(collection, (value, index, collection) => {\n        accumulator = initAccum\n            ? (initAccum = false, value)\n            : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n};\n\nfunction reduce(collection, iteratee, accumulator) {\n    const func = Array.isArray(collection) ? arrayReduce : baseReduce;\n    const initAccum = arguments.length < 3;\n    return func(collection, iteratee, accumulator, initAccum, baseEach);\n}\n\nconst isFlattenable = (value) => {\n    return Array.isArray(value) || isArguments(value) ||\n    !!(value && value[Symbol.isConcatSpreadable]);\n};\n\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n    let index = -1;\n    const length = array.length;\n\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten(value, depth - 1, predicate, isStrict, result);\n            } else {\n                result.push(...value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\n\nconst isArguments = (value) => {\n    return isObjectLike(value) && getTag(value) == '[object Arguments]';\n};\n\nconst basePick = (object, paths) => {\n    return basePickBy(object, paths, (value, path) => hasIn(object, path));\n};\n\nconst basePickBy = (object, paths, predicate) => {\n    let index = -1;\n    const length = paths.length;\n    const result = {};\n\n    while (++index < length) {\n        const path = paths[index];\n        const value = get(object, path);\n        if (predicate(value, path)) {\n            set(result, castPath(path, object), value);\n        }\n    }\n    return result;\n};\n\nconst isLength = (value) => {\n    return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n};\n\nconst baseHasIn = (object, key) =>{\n    return object != null && key in Object(object);\n};\n\nconst hasPath = (object, path, hasFunc) => {\n    path = castPath(path, object);\n\n    var index = -1,\n        length = path.length,\n        result = false;\n\n    while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) &&\n        (Array.isArray(object) || isArguments(object));\n};\n\nconst asciiWords = (string) => {\n    return string.match(reAsciiWord);\n};\n\nconst unicodeWords = (string) => {\n    return string.match(reUnicodeWords);\n};\n\nconst words = (string, pattern) => {\n    if (pattern === undefined) {\n        const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n        return result || [];\n    }\n    return string.match(pattern) || [];\n};\n\nconst castSlice = (array, start, end) => {\n    const { length } = array;\n    end = end === undefined ? length : end;\n    return (!start && end >= length) ? array : array.slice(start, end);\n};\n\nconst upperFirst = createCaseFirst('toUpperCase');\n\nfunction createCaseFirst(methodName) {\n    return (string) => {\n        if (!string) {\n            return '';\n        }\n\n        const strSymbols = hasUnicode(string)\n            ? stringToArray(string)\n            : undefined;\n\n        const chr = strSymbols\n            ? strSymbols[0]\n            : string[0];\n\n        const trailing = strSymbols\n            ? castSlice(strSymbols, 1).join('')\n            : string.slice(1);\n\n        return chr[methodName]() + trailing;\n    };\n}\n\nexport function matches(source) {\n    return baseMatches(baseClone(source, true));\n}\n\n// -- helper classes\nclass Stack {\n    constructor(entries) {\n        const data = this.__data__ = new ListCache(entries);\n        this.size = data.size;\n    }\n\n    clear() {\n        this.__data__ = new ListCache;\n        this.size = 0;\n    }\n\n    delete(key) {\n        const data = this.__data__;\n        const result = data['delete'](key);\n\n        this.size = data.size;\n        return result;\n    }\n\n    get(key) {\n        return this.__data__.get(key);\n    }\n\n    has(key) {\n        return this.__data__.has(key);\n    }\n\n    set(key, value) {\n        let data = this.__data__;\n        if (data instanceof ListCache) {\n            const pairs = data.__data__;\n            if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([key, value]);\n                this.size = ++data.size;\n                return this;\n            }\n            data = this.__data__ = new MapCache(pairs);\n        }\n        data.set(key, value);\n        this.size = data.size;\n        return this;\n    }\n}\n\nclass ListCache {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n\n    delete(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n\n        if (index < 0) {\n            return false;\n        }\n        const lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            data.splice(index, 1);\n        }\n        --this.size;\n        return true;\n    }\n\n    get(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n\n    has(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    set(key, value) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n\n        if (index < 0) {\n            ++this.size;\n            data.push([key, value]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n}\n\nclass MapCache {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.size = 0;\n        this.__data__ = {\n            'hash': new Hash,\n            'map': new Map,\n            'string': new Hash\n        };\n    }\n\n    delete(key) {\n        const result = getMapData(this, key)['delete'](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n\n    get(key) {\n        return getMapData(this, key).get(key);\n    }\n\n    has(key) {\n        return getMapData(this, key).has(key);\n    }\n\n    set(key, value) {\n        const data = getMapData(this, key);\n        const size = data.size;\n\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n}\n\nclass Hash {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.__data__ = Object.create(null);\n        this.size = 0;\n    }\n\n    delete(key) {\n        const result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n\n    get(key) {\n        const data = this.__data__;\n        const result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    has(key) {\n        const data = this.__data__;\n        return data[key] !== undefined;\n    }\n\n    set(key, value) {\n        const data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n}\n\nclass SetCache {\n    constructor(values) {\n        let index = -1;\n        const length = values == null ? 0 : values.length;\n\n        this.__data__ = new MapCache;\n        while (++index < length) {\n            this.add(values[index]);\n        }\n    }\n\n    add(value) {\n        this.__data__.set(value, HASH_UNDEFINED);\n        return this;\n    }\n\n    has(value) {\n        return this.__data__.has(value);\n    }\n}\n\nSetCache.prototype.push = SetCache.prototype.add;\n\n// -- top level functions\n\nexport const isBoolean = function(value) {\n    var toString = Object.prototype.toString;\n    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === boolTag);\n};\n\nexport const isObject = function(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function');\n};\n\nexport const isNumber = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === numberTag);\n};\n\nexport const isString = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === stringTag);\n};\n\nexport const assign = createAssigner((object, source) => {\n    if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n    }\n    for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n            assignValue(object, key, source[key]);\n        }\n    }\n});\n\nexport const mixin = assign;\n\nexport const deepMixin = mixin;\n\nexport const supplement = (object, ...sources) => {\n    let index = -1;\n    let length = sources.length;\n    const guard = length > 2 ? sources[2] : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n    }\n\n    while (++index < length) {\n        const source = sources[index];\n\n        if (source == null) {\n            continue;\n        }\n\n        const props = Object.keys(source);\n        const propsLength = props.length;\n        let propsIndex = -1;\n\n        while (++propsIndex < propsLength) {\n            const key = props[propsIndex];\n            const value = object[key];\n\n            if (value === undefined ||\n                (eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key))) {\n                object[key] = source[key];\n            }\n        }\n    }\n\n    return object;\n};\n\nexport const defaults = supplement;\n\nexport const deepSupplement = function defaultsDeep(...args) {\n    args.push(undefined, customDefaultsMerge);\n    return merge.apply(undefined, args);\n};\n\nexport const defaultsDeep = deepSupplement;\n\n// _.invokeMap\nexport const invoke = (collection, path, ...args) => {\n    let index = -1;\n    const isFunc = typeof path === 'function';\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n    baseEach(collection, (value) => {\n        result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);\n    });\n\n    return result;\n};\n\n// _.invoke\nexport const invokeProperty = (object, path, ...args) => {\n    path = castPath(path, object);\n    object = parent(object, path);\n    const func = object == null ? object : object[toKey(last(path))];\n    return func == null ? undefined : func.apply(object, args);\n};\n\nexport const sortedIndex = (array, value, iteratee) => {\n    let low = 0;\n    let high = array == null ? 0 : array.length;\n    if (high == 0) {\n        return 0;\n    }\n\n    iteratee = getIteratee(iteratee, 2);\n    value = iteratee(value);\n\n    const valIsNaN = value !== value;\n    const valIsNull = value === null;\n    const valIsSymbol = isSymbol(value);\n    const valIsUndefined = value === undefined;\n\n    while (low < high) {\n        let setLow;\n        const mid = Math.floor((low + high) / 2);\n        const computed = iteratee(array[mid]);\n        const othIsDefined = computed !== undefined;\n        const othIsNull = computed === null;\n        const othIsReflexive = computed === computed;\n        const othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n            setLow = othIsReflexive;\n        } else if (valIsUndefined) {\n            setLow = othIsReflexive &&othIsDefined;\n        } else if (valIsNull) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull;\n        } else if (valIsSymbol) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n        } else if (othIsNull || othIsSymbol) {\n            setLow = false;\n        } else {\n            setLow = computed < value;\n        }\n        if (setLow) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return Math.min(high, MAX_ARRAY_INDEX);\n};\n\nexport const uniq = (array, iteratee) => {\n    let index = -1;\n    let includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    iteratee = getIteratee(iteratee, 2);\n    let isCommon = true;\n\n    const { length } = array;\n    const result = [];\n    let seen = result;\n\n    if (length >= LARGE_ARRAY_SIZE) {\n        const set = iteratee ? null : createSet(array);\n        if (set) {\n            return setToArray(set);\n        }\n        isCommon = false;\n        includes = (cache, key) => cache.has(key);\n        seen = new SetCache;\n    } else {\n        seen = iteratee ? [] : result;\n    }\n    outer:\n    while (++index < length) {\n        let value = array[index];\n        const computed = iteratee ? iteratee(value) : value;\n\n        value = (value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n            let seenIndex = seen.length;\n            while (seenIndex--) {\n                if (seen[seenIndex] === computed) {\n                    continue outer;\n                }\n            }\n            if (iteratee) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n        else if (!includes(seen, computed)) {\n            if (seen !== result) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nexport const clone = (value) => baseClone(value);\n\nexport const cloneDeep = (value) => baseClone(value, true);\n\nexport const isEmpty = (value) => {\n    if (value == null) {\n        return true;\n    }\n    if (isArrayLike(value) &&\n        (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' ||\n            isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n    }\n    const tag = getTag(value);\n    if (tag == '[object Map]' || tag == '[object Set]') {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !baseKeys(value).length;\n    }\n    for (const key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n};\nexport const isEqual = (object, other) => baseIsEqual(object, other);\n\nexport const isFunction = (value) => typeof value === 'function';\n\nexport const isPlainObject = (value) => {\n    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n};\n\nexport const toArray = (value) => {\n    if (!value) {\n        return [];\n    }\n\n    if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n    }\n\n    if (Symbol.iterator && Symbol.iterator in Object(value)) {\n        const iterator = value[Symbol.iterator]();\n        let data;\n        const result = [];\n\n        while (!(data = iterator.next()).done) {\n            result.push(data.value);\n        }\n        return result;\n    }\n\n    const tag = getTag(value);\n    const func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n    return func(value);\n};\n\nexport function debounce(func, wait, opt) {\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n\n    let lastArgs;\n    let lastThis;\n    let maxWait;\n    let result;\n    let timerId;\n    let lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n\n    const useRaf = (!wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function');\n\n    wait = +wait || 0;\n\n    if (isObject(opt)) {\n        leading = !!opt.leading;\n        maxing = 'maxWait' in opt;\n        maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n        trailing = 'trailing' in opt ? !!opt.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n\n    function startTimer(pendingFunc, wait) {\n        if (useRaf) {\n            window.cancelAnimationFrame(timerId);\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n\n    function cancelTimer(id) {\n        if (useRaf) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n\n        return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n        timerId = undefined;\n\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n\n    debounced.cancel = () => {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    };\n    debounced.flush = () => timerId === undefined ? result : trailingEdge(Date.now());\n    debounced.pending = () => timerId !== undefined;\n\n    return debounced;\n}\n\nexport const groupBy = (collection, iteratee) => {\n    iteratee = getIteratee(iteratee, 2);\n\n    return reduce(collection, (result, value) => {\n        const key = iteratee(value);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(value);\n        } else {\n            assignValue(result, key, [value]);\n        }\n        return result;\n    }, {});\n};\n\nexport const sortBy = (collection, iteratees = []) => {\n    if (collection == null) {\n        return [];\n    }\n\n    const length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n    }\n\n    if (!Array.isArray(iteratees)) {\n        iteratees = [getIteratee(iteratees, 2)];\n    }\n\n    return baseOrderBy(collection, iteratees.flat(1), []);\n};\n\nexport const flattenDeep = (array) => {\n    const length = array == null ? 0 : array.length;\n    return length ? baseFlatten(array, Infinity) : [];\n};\n\nexport const without = (array, ...values) => isArrayLike(array) ? diff(array, values) : [];\n\nexport const difference = (array, ...values) =>\n    isObjectLike(array) && isArrayLike(array) ?\n        diff(array, values.flat(1)) : [];\n\nexport const intersection = (...arrays) => {\n    const mapped = arrays.map((array) =>\n        isObjectLike(array) && isArrayLike(array) ?\n            array : []\n    );\n\n    return mapped.length && mapped[0] === arrays[0] ?\n        intersect(mapped) : [];\n};\n\nexport const union = (...arrays) => {\n    const array = arrays.flat(1);\n    return uniq(array);\n};\n\nexport const has = (object, key) => {\n    if (object == null) {\n        return false;\n    }\n\n    if (typeof key === 'string') {\n        key = key.split('.');\n    }\n\n    let index = -1;\n    let value = object;\n\n    while (++index < key.length) {\n        if (!value || !hasOwnProperty.call(value, key[index])) {\n            return false;\n        }\n        value = value[key[index]];\n    }\n\n    return true;\n};\n\nexport const result = (object, path, defaultValue) => {\n    path = castPath(path, object);\n\n    let index = -1;\n    let length = path.length;\n\n    if (!length) {\n        length = 1;\n        object = undefined;\n    }\n    while (++index < length) {\n        let value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n            index = length;\n            value = defaultValue;\n        }\n        object = typeof value === 'function' ? value.call(object) : value;\n    }\n    return object;\n};\n\nexport const omit = (object, ...paths) => {\n    let result = {};\n    if (object == null) {\n        return result;\n    }\n    let isDeep = false;\n    paths = paths.flat(1).map((path) => {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n    });\n    copyObject(object, getAllKeysIn(object), result);\n    if (isDeep) {\n        result = baseClone(result, true, true, true, (value) => isPlainObject(value) ? undefined : value);\n    }\n    let length = paths.length;\n    while (length--) {\n        unset(result, paths[length]);\n    }\n    return result;\n};\n\nexport const pick = (object, ...paths) => {\n    return object == null ? {} : basePick(object, paths.flat(Infinity));\n};\n\nexport const bindAll = (object, ...methodNames) => {\n    methodNames.flat(1).forEach((key) => {\n        key = toKey(key);\n        assignValue(object, key, object[key].bind(object));\n    });\n    return object;\n};\n\nexport const forIn = (object, iteratee = (value) => value) => {\n    let index = -1;\n    const iterable = Object(object);\n    const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n    let length = props.length;\n\n    while(length--) {\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n};\n\nexport const camelCase = (string = '') => (\n    words(`${string}`.replace(/['\\u2019]/g, ''))\n        .reduce((result, word, index) => {\n            word = word.toLowerCase();\n            return result + (index ? upperFirst(word) : word);\n        }, '')\n);\n\nlet idCounter = 0;\n\nexport const uniqueId = (prefix = '') => {\n    const id = ++idCounter;\n    return `${prefix}` + id;\n};\n\nexport const merge = createAssigner((object, source, srcIndex, customizer) => {\n    baseMerge(object, source, srcIndex, customizer);\n}, true);\n", "class Data {\n\n    constructor() {\n        this.map = new WeakMap();\n    }\n\n    has(obj, key) {\n        if (key === undefined) return this.map.has(obj);\n        return key in this.map.get(obj);\n    }\n\n    create(obj) {\n        if (!this.has(obj)) this.map.set(obj, Object.create(null));\n        return this.get(obj);\n    }\n\n    get(obj, key) {\n        if (!this.has(obj)) return undefined;\n        const data = this.map.get(obj);\n        if (key === undefined) return data;\n        return data[key];\n    }\n\n    set(obj, key, value) {\n        if (key === undefined) return;\n        const data = this.create(obj);\n        if (typeof key === 'string') {\n            data[key] = value;\n        } else {\n            Object.assign(data, key);\n        }\n    }\n\n    remove(obj, key) {\n        if (!this.has(obj)) return;\n        if (key === undefined) {\n            this.map.delete(obj);\n        } else {\n            const data = this.map.get(obj);\n            delete data[key];\n        }\n    }\n}\n\nexport default Data;\n\n", "import Data from '../Data.mjs';\n\nexport const dataPriv = new Data();\n\nexport const dataUser = new Data();\n", "export const Event = function(src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof Event)) {\n        return new Event(src, props);\n    }\n\n    // Event object\n    if (src && src.type) {\n        this.originalEvent = src;\n        this.type = src.type;\n\n        // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n        this.isDefaultPrevented = src.defaultPrevented\n            ? returnTrue\n            : returnFalse;\n\n        // Create target properties\n        this.target = src.target;\n        this.currentTarget = src.currentTarget;\n        this.relatedTarget = src.relatedTarget;\n\n        // Event type\n    } else {\n        this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n        Object.assign(this, props);\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = (src && src.timeStamp) || Date.now();\n\n    // Mark it as fixed\n    this.envelope = true;\n};\n\n// $.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n    constructor: Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function() {\n        const evt = this.originalEvent;\n        this.isDefaultPrevented = returnTrue;\n        if (evt) {\n            evt.preventDefault();\n        }\n    },\n    stopPropagation: function() {\n        const evt = this.originalEvent;\n        this.isPropagationStopped = returnTrue;\n        if (evt) {\n            evt.stopPropagation();\n        }\n    },\n    stopImmediatePropagation: function() {\n        const evt = this.originalEvent;\n        this.isImmediatePropagationStopped = returnTrue;\n        if (evt) {\n            evt.stopImmediatePropagation();\n        }\n        this.stopPropagation();\n    },\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\n[\n    'altKey',\n    'bubbles',\n    'cancelable',\n    'changedTouches',\n    'ctrlKey',\n    'detail',\n    'eventPhase',\n    'metaKey',\n    'pageX',\n    'pageY',\n    'shiftKey',\n    'view',\n    'char',\n    'code',\n    'charCode',\n    'key',\n    'keyCode',\n    'button',\n    'buttons',\n    'clientX',\n    'clientY',\n    'offsetX',\n    'offsetY',\n    'pointerId',\n    'pointerType',\n    'screenX',\n    'screenY',\n    'targetTouches',\n    'toElement',\n    'touches',\n    'which',\n].forEach((name) => addProp(name));\n\nfunction addProp(name) {\n    Object.defineProperty(Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: function() {\n            return this.originalEvent ? this.originalEvent[name] : undefined;\n        },\n        set: function(value) {\n            Object.defineProperty(this, name, {\n                enumerable: true,\n                configurable: true,\n                writable: true,\n                value: value,\n            });\n        },\n    });\n}\n\nfunction returnTrue() {\n    return true;\n}\n\nfunction returnFalse() {\n    return false;\n}\n", "\n/*!\n * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-11-24T14:04Z\n */\n\nimport { uniq, isEmpty } from '../../util/utilHelpers.mjs';\nimport { dataPriv, dataUser } from './vars.mjs';\nimport { Event } from './Event.mjs';\n\nconst document = (typeof window !== 'undefined') ? window.document : null;\nconst documentElement = document && document.documentElement;\n\nconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n// Only count HTML whitespace\n// Other whitespace should count in values\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n// Define a local copy of $\nconst $ = function(selector) {\n    // The $ object is actually just the init constructor 'enhanced'\n    // Need init if $ is called (just allow error to be thrown if not included)\n    return new $.Dom(selector);\n};\n\n$.fn = $.prototype = {\n    constructor: $,\n    // The default length of a $ object is 0\n    length: 0,\n};\n\n// A global GUID counter for objects\n$.guid = 1;\n\n// User data storage\n$.data = dataUser;\n\n$.merge = function(first, second) {\n    let len = +second.length;\n    let i = first.length;\n    for (let j = 0; j < len; j++) {\n        first[i++] = second[j];\n    }\n    first.length = i;\n    return first;\n};\n\n$.parseHTML = function(string) {\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n    const context = document.implementation.createHTMLDocument();\n    // Set the base href for the created document so any parsed elements with URLs\n    // are based on the document's URL\n    const base = context.createElement('base');\n    base.href = document.location.href;\n    context.head.appendChild(base);\n\n    context.body.innerHTML = string;\n    // remove scripts\n    const scripts = context.getElementsByTagName('script');\n    for (let i = 0; i < scripts.length; i++) {\n        scripts[i].remove();\n    }\n    return Array.from(context.body.childNodes);\n};\n\nif (typeof Symbol === 'function') {\n    $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n}\n\n$.fn.toArray = function() {\n    return Array.from(this);\n};\n\n// Take an array of elements and push it onto the stack\n// (returning the new matched element set)\n$.fn.pushStack = function(elements) {\n    // Build a new $ matched element set\n    const ret = $.merge(this.constructor(), elements);\n    // Add the old object onto the stack (as a reference)\n    ret.prevObject = this;\n    // Return the newly-formed element set\n    return ret;\n};\n\n$.fn.find = function(selector) {\n    const [el] = this;\n    const ret = this.pushStack([]);\n    if (!el) return ret;\n    // Early return if context is not an element, document or document fragment\n    const { nodeType } = el;\n    if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return ret;\n    }\n    if (typeof selector !== 'string') {\n        if (el !== selector && el.contains(selector)) {\n            $.merge(ret, [selector]);\n        }\n    } else {\n        $.merge(ret, el.querySelectorAll(selector));\n    }\n    return ret;\n};\n\n$.fn.add = function(selector) {\n    const newElements = $(selector).toArray();\n    const prevElements = this.toArray();\n    const ret = this.pushStack([]);\n    $.merge(ret, uniq(prevElements.concat(newElements)));\n    return ret;\n};\n\n$.fn.addBack = function() {\n    return this.add(this.prevObject);\n};\n\n$.fn.filter = function(selector) {\n    const matches = [];\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (!node.matches(selector)) continue;\n        matches.push(node);\n    }\n    return this.pushStack(matches);\n};\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n// Strict HTML recognition (trac-11290: must start with <)\n// Shortcut simple #id case for speed\nconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n\nfunction isObviousHtml(input) {\n    return (\n        input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3\n    );\n}\n\nconst Dom = function(selector) {\n    if (!selector) {\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        return this;\n    }\n    if (typeof selector === 'function') {\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        throw new Error('function not supported');\n    }\n    if (arguments.length > 1) {\n        throw new Error('selector with context not supported');\n    }\n    if (selector.nodeType) {\n        // HANDLE: $(DOMElement)\n        this[0] = selector;\n        this.length = 1;\n        return this;\n    }\n    let match;\n    if (isObviousHtml(selector + '')) {\n        // Handle obvious HTML strings\n        // Assume that strings that start and end with <> are HTML and skip\n        // the regex check. This also handles browser-supported HTML wrappers\n        // like TrustedHTML.\n        match = [null, selector, null];\n    } else if (typeof selector === 'string') {\n        // Handle HTML strings or selectors\n        match = rQuickExpr.exec(selector);\n    } else {\n        // Array-like\n        return $.merge(this, selector);\n    }\n    if (!match || !match[1]) {\n        // HANDLE: $(expr)\n        return $root.find(selector);\n    }\n    // Match html or make sure no context is specified for #id\n    // Note: match[1] may be a string or a TrustedHTML wrapper\n    if (match[1]) {\n        // HANDLE: $(html) -> $(array)\n        $.merge(this, $.parseHTML(match[1]));\n        return this;\n    }\n    // HANDLE: $(#id)\n    const el = document.getElementById(match[2]);\n    if (el) {\n        // Inject the element directly into the $ object\n        this[0] = el;\n        this.length = 1;\n    }\n    return this;\n};\n\n$.Dom = Dom;\n\n// Give the init function the $ prototype for later instantiation\nDom.prototype = $.fn;\n\n// Events\n\n$.Event = Event;\n\n$.event = {\n    special: Object.create(null),\n};\n\n$.event.has = function(elem, eventType) {\n    const events = dataPriv.get(elem, 'events');\n    if (!events) return false;\n    if (!eventType) return true;\n    return Array.isArray(events[eventType]) && events[eventType].length > 0;\n};\n\n$.event.on = function(elem, types, selector, data, fn, one) {\n\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n        // ( types-Object, selector, data )\n        if (typeof selector !== 'string') {\n            // ( types-Object, data )\n            data = data || selector;\n            selector = undefined;\n        }\n        for (let type in types) {\n            $.event.on(elem, type, selector, data, types[type], one);\n        }\n        return elem;\n    }\n\n    if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === 'string') {\n            // ( types, selector, fn )\n            fn = data;\n            data = undefined;\n        } else {\n            // ( types, data, fn )\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n    if (!fn) {\n        return elem;\n    }\n    if (one === 1) {\n        const origFn = fn;\n        fn = function(event) {\n            // Can use an empty set, since event contains the info\n            $().off(event);\n            return origFn.apply(this, arguments);\n        };\n\n        // Use same guid so caller can remove using origFn\n        fn.guid = origFn.guid || (origFn.guid = $.guid++);\n    }\n    for (let i = 0; i < elem.length; i++) {\n        $.event.add(elem[i], types, fn, data, selector);\n    }\n};\n\n$.event.add = function(elem, types, handler, data, selector) {\n    // Only attach events to objects for which we can store data\n    if (typeof elem != 'object') {\n        return;\n    }\n\n    const elemData = dataPriv.create(elem);\n\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handleObjIn;\n    if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n    }\n\n    // Ensure that invalid selectors throw exceptions at attach time\n    // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n    if (selector) {\n        documentElement.matches(selector);\n    }\n\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    if (!handler.guid) {\n        handler.guid = $.guid++;\n    }\n\n    // Init the element's event structure and main handler, if this is the first\n    let events;\n    if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n    }\n    let eventHandle;\n    if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function(e) {\n            // Discard the second event of a $.event.trigger() and\n            // when an event is called after a page has unloaded\n            return (typeof $ !== 'undefined')\n                ? $.event.dispatch.apply(elem, arguments)\n                : undefined;\n        };\n    }\n\n    // Handle multiple events separated by a space\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!origType) {\n            continue;\n        }\n\n        const namespaces = ns.split('.').sort();\n        // If event changes its type, use the special event handlers for the changed type\n        let special = $.event.special[origType];\n        // If selector defined, determine special event api type, otherwise given type\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        // Update special based on newly reset type\n        special = $.event.special[type];\n        // handleObj is passed to all event handlers\n        const handleObj = Object.assign(\n            {\n                type: type,\n                origType: origType,\n                data: data,\n                handler: handler,\n                guid: handler.guid,\n                selector: selector,\n                namespace: namespaces.join('.'),\n            },\n            handleObjIn\n        );\n\n        let handlers;\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n            handlers = events[type] = [];\n            handlers.delegateCount = 0;\n\n            // Only use addEventListener if the special events handler returns false\n            if (\n                !special || !special.setup ||\n                    special.setup.call(elem, data, namespaces, eventHandle) === false\n            ) {\n                if (elem.addEventListener) {\n                    elem.addEventListener(type, eventHandle);\n                }\n            }\n        }\n\n        if (special && special.add) {\n            special.add.call(elem, handleObj);\n            if (!handleObj.handler.guid) {\n                handleObj.handler.guid = handler.guid;\n            }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n            handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n            handlers.push(handleObj);\n        }\n    }\n};\n\n// Detach an event or set of events from an element\n$.event.remove = function(elem, types, handler, selector, mappedTypes) {\n\n    const elemData = dataPriv.get(elem);\n    if (!elemData || !elemData.events) return;\n    const events = elemData.events;\n\n    // Once for each type.namespace in types; type may be omitted\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!origType) {\n            for (const type in events) {\n                $.event.remove(\n                    elem,\n                    type + typesArr[i],\n                    handler,\n                    selector,\n                    true\n                );\n            }\n            continue;\n        }\n\n        const special = $.event.special[origType];\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        const handlers = events[type];\n        if (!handlers || handlers.length === 0) continue;\n\n        const namespaces = ns.split('.').sort();\n        const rNamespace = ns\n            ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\n            : null;\n\n        // Remove matching events\n        const origCount = handlers.length;\n        let j = origCount;\n        while (j--) {\n            const handleObj = handlers[j];\n\n            if (\n                (mappedTypes || origType === handleObj.origType) &&\n                    (!handler || handler.guid === handleObj.guid) &&\n                    (!rNamespace || rNamespace.test(handleObj.namespace)) &&\n                    (!selector ||\n                        selector === handleObj.selector ||\n                        (selector === '**' && handleObj.selector))\n            ) {\n                handlers.splice(j, 1);\n                if (handleObj.selector) {\n                    handlers.delegateCount--;\n                }\n                if (special && special.remove) {\n                    special.remove.call(elem, handleObj);\n                }\n            }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && handlers.length === 0) {\n            if (\n                !special || !special.teardown ||\n                    special.teardown.call(elem, namespaces, elemData.handle) === false\n            ) {\n                // This \"if\" is needed for plain objects\n                if (elem.removeEventListener) {\n                    elem.removeEventListener(type, elemData.handle);\n                }\n            }\n            delete events[type];\n        }\n    }\n\n    // Remove data if it's no longer used\n    if (isEmpty(events)) {\n        dataPriv.remove(elem, 'handle');\n        dataPriv.remove(elem, 'events');\n    }\n};\n\n$.event.dispatch = function(nativeEvent) {\n\n    const elem = this;\n    // Make a writable $.Event from the native event object\n    const event = $.event.fix(nativeEvent);\n    event.delegateTarget = elem;\n    // Use the fix-ed $.Event rather than the (read-only) native event\n    const args = Array.from(arguments);\n    args[0] = event;\n\n    const eventsData = dataPriv.get(elem, 'events');\n    const handlers = (eventsData && eventsData[event.type]) || [];\n    const special = $.event.special[event.type];\n\n    // Call the preDispatch hook for the mapped type, and let it bail if desired\n    if (special && special.preDispatch) {\n        if (special.preDispatch.call(elem, event) === false) return;\n    }\n\n    // Determine handlers\n    const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n    // Run delegates first; they may want to stop propagation beneath us\n    let i = 0;\n    let matched;\n    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        let j = 0;\n        let handleObj;\n        while (\n            (handleObj = matched.handlers[j++]) &&\n                !event.isImmediatePropagationStopped()\n        ) {\n\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n\n            const origSpecial = $.event.special[handleObj.origType];\n            let handler;\n            if (origSpecial && origSpecial.handle) {\n                handler = origSpecial.handle;\n            } else {\n                handler = handleObj.handler;\n            }\n\n            const ret = handler.apply(matched.elem, args);\n            if (ret !== undefined) {\n                if ((event.result = ret) === false) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                }\n            }\n        }\n    }\n\n    // Call the postDispatch hook for the mapped type\n    if (special && special.postDispatch) {\n        special.postDispatch.call(elem, event);\n    }\n\n    return event.result;\n};\n\n$.event.handlers = function(event, handlers) {\n\n    const delegateCount = handlers.delegateCount;\n    const handlerQueue = [];\n\n    // Find delegate handlers\n    if (\n        delegateCount &&\n            // Support: Firefox <=42 - 66+\n            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n            // Support: IE 11+\n            // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n            !(event.type === 'click' && event.button >= 1)\n    ) {\n        for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n            // Don't check non-elements (trac-13208)\n            // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n            if (\n                cur.nodeType === 1 &&\n                    !(event.type === 'click' && cur.disabled === true)\n            ) {\n                const matchedHandlers = [];\n                const matchedSelectors = {};\n                for (let i = 0; i < delegateCount; i++) {\n                    const handleObj = handlers[i];\n                    // Don't conflict with Object.prototype properties (trac-13203)\n                    const sel = handleObj.selector + ' ';\n                    if (matchedSelectors[sel] === undefined) {\n                        matchedSelectors[sel] = cur.matches(sel);\n                    }\n                    if (matchedSelectors[sel]) {\n                        matchedHandlers.push(handleObj);\n                    }\n                }\n                if (matchedHandlers.length) {\n                    handlerQueue.push({\n                        elem: cur,\n                        handlers: matchedHandlers,\n                    });\n                }\n            }\n        }\n    }\n\n    // Add the remaining (directly-bound) handlers\n    if (delegateCount < handlers.length) {\n        handlerQueue.push({\n            elem: this,\n            handlers: handlers.slice(delegateCount),\n        });\n    }\n\n    return handlerQueue;\n};\n\n$.event.fix = function(originalEvent) {\n    return originalEvent.envelope ? originalEvent : new Event(originalEvent);\n};\n\n// A central reference to the root $(document)\nconst $root = $(document);\n\nexport { $ as default };\n", "import { camelCase } from '../../util/utilHelpers.mjs';\nimport $ from './Dom.mjs';\nimport V from '../../V/index.mjs';\nimport { dataPriv, dataUser } from './vars.mjs';\n\n// Manipulation\n\nfunction cleanNodesData(nodes) {\n    let i = nodes.length;\n    while (i--) cleanNodeData(nodes[i]);\n}\n\nfunction cleanNodeData(node) {\n    $.event.remove(node);\n    dataPriv.remove(node);\n    dataUser.remove(node);\n}\n\nfunction removeNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\n\nexport function remove() {\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        cleanNodeData(node);\n        cleanNodesData(node.getElementsByTagName('*'));\n    }\n    removeNodes(this);\n    return this;\n}\n\nexport function detach() {\n    removeNodes(this);\n    return this;\n}\n\nexport function empty() {\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (node.nodeType === 1) {\n            cleanNodesData(node.getElementsByTagName('*'));\n            // Remove any remaining nodes\n            node.textContent = '';\n        }\n    }\n    return this;\n}\n\nexport function clone() {\n    const clones = [];\n    for (let i = 0; i < this.length; i++) {\n        clones.push(this[i].cloneNode(true));\n    }\n    return this.pushStack(clones);\n}\n\nexport function html(html) {\n    const [el] = this;\n    if (!el) return null;\n    if (arguments.length === 0) return el.innerHTML;\n    if (html === undefined) return this; // do nothing\n    cleanNodesData(el.getElementsByTagName('*'));\n    if (typeof html === 'string' || typeof html === 'number') {\n        el.innerHTML = html;\n    } else {\n        el.innerHTML = '';\n        return this.append(html);\n    }\n    return this;\n}\n\nexport function append(...nodes) {\n    const [parent] = this;\n    if (!parent) return this;\n    nodes.forEach((node) => {\n        if (!node) return;\n        if (typeof node === 'string') {\n            parent.append(...$.parseHTML(node));\n        } else if (node.toString() === '[object Object]') {\n            // $ object\n            this.append(...Array.from(node));\n        } else if (Array.isArray(node)) {\n            this.append(...node);\n        } else {\n            // DOM node\n            parent.appendChild(node);\n        }\n    });\n    return this;\n}\n\nexport function prepend(...nodes) {\n    const [parent] = this;\n    if (!parent) return this;\n    nodes.forEach((node) => {\n        if (!node) return;\n        if (typeof node === 'string') {\n            parent.prepend(...$.parseHTML(node));\n        } else if (node.toString() === '[object Object]') {\n            // $ object\n            this.prepend(...Array.from(node));\n        } else if (Array.isArray(node)) {\n            this.prepend(...node);\n        } else {\n            // DOM node\n            parent.insertBefore(node, parent.firstChild);\n        }\n    });\n    return this;\n}\n\nexport function appendTo(parent) {\n    $(parent).append(this);\n    return this;\n}\n\nexport function prependTo(parent) {\n    $(parent).prepend(this);\n    return this;\n}\n\n// Styles and attributes\n\nconst requireUnits = {};\n[\n    'width', 'height', 'top', 'bottom', 'left', 'right',\n    'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight',\n    'margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight',\n].forEach((cssProp) => {\n    requireUnits[cssProp] = true;\n});\n\nfunction setCSSProperty(el, name, value) {\n    if (typeof value === 'number' && requireUnits[camelCase(name)]) {\n        value += 'px';\n    }\n    el.style[name] = value;\n}\n\nexport function css(name, value) {\n    let styles;\n    if (typeof name === 'string') {\n        if (value === undefined) {\n            const [el] = this;\n            if (!el) return null;\n            return el.style[name];\n        } else {\n            styles = { [name]: value };\n        }\n    } else if (!name) {\n        throw new Error('no styles provided');\n    } else {\n        styles = name;\n    }\n    for (let style in styles) {\n        if (styles.hasOwnProperty(style)) {\n            for (let i = 0; i < this.length; i++) {\n                setCSSProperty(this[i], style, styles[style]);\n            }\n        }\n    }\n    return this;\n}\n\nexport function data(name, value) {\n    if (arguments.length < 2) {\n        const [el] = this;\n        if (!el) return null;\n        if (name === undefined) {\n            return el.dataset;\n        }\n        return el.dataset[name];\n    }\n    for (let i = 0; i < this.length; i++) {\n        this[i].dataset[name] = value;\n    }\n    return this;\n}\n\n// Classes\n\nfunction setNodesClass(method, nodes, args) {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        V.prototype[method].apply({ node }, args);\n    }\n}\n\nexport function removeClass() {\n    setNodesClass('removeClass', this, arguments);\n    return this;\n}\n\nexport function addClass() {\n    setNodesClass('addClass', this, arguments);\n    return this;\n}\n\nexport function toggleClass() {\n    setNodesClass('toggleClass', this, arguments);\n    return this;\n}\n\nexport function hasClass() {\n    const [node] = this;\n    if (!node) return false;\n    return V.prototype.hasClass.apply({ node }, arguments);\n}\n\n// Traversing\n\nexport function children(selector) {\n    const matches = [];\n    for(let i = 0; i < this.length; i++) {\n        const node = this[i];\n        let children = Array.from(node.children);\n        if (typeof selector === 'string') {\n            children = children.filter(child => child.matches(selector));\n        }\n        matches.push(...children);\n    }\n    return this.pushStack(matches);\n}\n\nexport function closest(selector) {\n    const closest = [];\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        if (typeof selector === 'string') {\n            const closestEl = el.closest(selector);\n            if (closestEl) {\n                closest.push(closestEl);\n            }\n        } else {\n            const [ancestorEl] = $(selector);\n            if (ancestorEl && ancestorEl.contains(el)) {\n                closest.push(ancestorEl);\n            }\n        }\n    }\n    return this.pushStack(closest);\n}\n\n// Events\n\nexport function on(types, selector, data, fn) {\n    $.event.on(this, types, selector, data, fn);\n    return this;\n}\n\nexport function one(types, selector, data, fn) {\n    $.event.on(this, types, selector, data, fn, 1);\n    return this;\n}\n\nexport function off(types, selector, fn) {\n    if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched $.Event\n        const handleObj = types.handleObj;\n        $(types.delegateTarget).off(\n            handleObj.namespace\n                ? handleObj.origType + '.' + handleObj.namespace\n                : handleObj.origType,\n            handleObj.selector,\n            handleObj.handler\n        );\n        return this;\n    }\n    if (typeof types === 'object') {\n        // ( types-object [, selector] )\n        for (let type in types) {\n            this.off(type, selector, types[type]);\n        }\n        return this;\n    }\n    if (selector === false || typeof selector === 'function') {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n    }\n    for (let i = 0; i < this.length; i++) {\n        $.event.remove(this[i], types, fn, selector);\n    }\n    return this;\n}\n\n// Measurements\n\nexport function width() {\n    const [el] = this;\n    if (el === window) return el.document.documentElement.clientWidth;\n    else if (!el) return undefined;\n    const styles = window.getComputedStyle(el);\n    const height = el.offsetWidth;\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderBottomWidth = parseFloat(styles.borderBottomWidth);\n    const paddingTop = parseFloat(styles.paddingTop);\n    const paddingBottom = parseFloat(styles.paddingBottom);\n    return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;\n}\n\nexport function height() {\n    const [el] = this;\n    if (el === window) return el.document.documentElement.clientHeight;\n    if (!el) return undefined;\n    const styles = window.getComputedStyle(el);\n    const width = el.offsetHeight;\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    const borderRightWidth = parseFloat(styles.borderRightWidth);\n    const paddingLeft = parseFloat(styles.paddingLeft);\n    const paddingRight = parseFloat(styles.paddingRight);\n    return width - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;\n}\n\nexport function position() {\n    const [el] = this;\n    if (!el) return;\n    let $el = $(el);\n    let offsetParent;\n    let offset;\n    let doc;\n    let parentOffset = { top: 0, left: 0 };\n    // position:fixed elements are offset from the viewport, which itself always has zero offset\n    if ($el.css('position') === 'fixed') {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = el.getBoundingClientRect();\n    } else {\n        offset = $el.offset();\n        // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n        doc = el.ownerDocument;\n        offsetParent = el.offsetParent || doc.documentElement;\n        const isStaticallyPositioned = (el) => {\n            const { position } = getComputedStyle(el);\n            return position === 'static';\n        };\n        while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {\n            offsetParent = offsetParent.offsetParent || doc.documentElement;\n        }\n        if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {\n            // Incorporate borders into its offset, since they are outside its content origin\n            const offsetParentStyles = window.getComputedStyle(offsetParent);\n            const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;\n            const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;\n            parentOffset = $(offsetParent).offset();\n            parentOffset.top += borderTopWidth;\n            parentOffset.left += borderLeftWidth;\n        }\n    }\n    const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;\n    const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;\n    // Subtract parent offsets and element margins\n    return {\n        top: offset.top - parentOffset.top - marginTop,\n        left: offset.left - parentOffset.left - marginLeft\n    };\n}\n\nexport function offset(coordinates) {\n    const [el] = this;\n    //  Getter\n    if (coordinates === undefined) {\n        if (!el) return null;\n        if (!el.getClientRects().length) {\n            return { top: 0, left: 0 };\n        }\n        const rect = el.getBoundingClientRect();\n        return {\n            top: rect.top + window.scrollY,\n            left: rect.left + window.scrollX\n        };\n    }\n    // Setter\n    if (!el) return this;\n    const currentStyle = window.getComputedStyle(el);\n    if (currentStyle.position === 'static') {\n        this.css('position', 'relative');\n    }\n    const currentOffset = this.offset();\n    const topDifference = coordinates.top - currentOffset.top;\n    const leftDifference = coordinates.left - currentOffset.left;\n    this.css({\n        top: (parseFloat(currentStyle.top) || 0) + topDifference + 'px',\n        left: (parseFloat(currentStyle.left) || 0) + leftDifference + 'px'\n    });\n    return this;\n}\n\n", "import $ from './Dom.mjs';\nimport { dataPriv } from './vars.mjs';\n\nconst animationKey = 'animationFrameId';\nconst cssReset = {};\n\ncssReset['transition-property'] =\ncssReset['transition-duration'] =\ncssReset['transition-delay'] =\ncssReset['transition-timing-function'] =\ncssReset['animation-name'] =\ncssReset['animation-duration'] =\ncssReset['animation-delay'] =\ncssReset['animation-timing-function'] = '';\n\nexport function animate(properties, opt = {}) {\n    this.stop();\n    for (let i = 0; i < this.length; i++) {\n        animateNode(this[i], properties, opt);\n    }\n    return this;\n}\n\nfunction animateNode(el, properties, opt = {}) {\n\n    let {\n        duration = 400,\n        easing = 'ease-in-out',\n        delay = 0,\n        complete\n    } = opt;\n\n    const delayId = setTimeout(function() {\n\n        const $el = $(el);\n        let fired = false;\n        let endEvent = 'transitionend';\n\n        // Convert milliseconds to seconds for CSS\n        duration = duration / 1000;\n        delay = delay / 1000;\n\n        // Set up CSS values for transition or keyframe animation\n        const cssValues = {};\n        if (typeof properties === 'string') {\n            // Keyframe animation\n            cssValues['animation-name'] = properties;\n            cssValues['animation-duration'] = duration + 's';\n            cssValues['animation-delay'] = delay + 's';\n            cssValues['animation-timing-function'] = easing;\n            endEvent = 'animationend';\n        } else {\n            // CSS transitions\n            const transitionProperties = [];\n            for (var key in properties) {\n                if (properties.hasOwnProperty(key)) {\n                    cssValues[key] = properties[key];\n                    transitionProperties.push(key);\n                }\n            }\n\n            if (duration > 0) {\n                cssValues['transition-property'] = transitionProperties.join(', ');\n                cssValues['transition-duration'] = duration + 's';\n                cssValues['transition-delay'] = delay + 's';\n                cssValues['transition-timing-function'] = easing;\n            }\n        }\n\n        const wrappedCallback = function(event){\n            if (event) {\n                if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from \"below\"\n                event.target.removeEventListener(endEvent, wrappedCallback);\n            } else {\n                el.removeEventListener(endEvent, wrappedCallback); // triggered by setTimeout\n            }\n            fired = true;\n            $el.css(cssReset);\n            complete && complete.call(el);\n        };\n\n        if (duration > 0){\n            el.addEventListener(endEvent, wrappedCallback);\n            // transitionEnd is not always firing on older Android phones\n            // so make sure it gets fired\n            const callbackId = setTimeout(function() {\n                if (fired) return;\n                wrappedCallback(null);\n            }, ((duration + delay) * 1000) + 25);\n\n            dataPriv.set(el, animationKey, {\n                id: callbackId,\n                stop: () => {\n                    clearTimeout(callbackId);\n                    el.removeEventListener(endEvent, wrappedCallback);\n                }\n            });\n        }\n\n        $el.css(cssValues);\n\n        if (duration <= 0) {\n            wrappedCallback(null);\n        }\n    });\n\n    dataPriv.set(el, animationKey, {\n        stop: () => clearTimeout(delayId)\n    });\n}\n\nexport function stop() {\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        const animation = dataPriv.get(el, animationKey);\n        if (!animation) continue;\n        animation.stop();\n        dataPriv.remove(el, animationKey);\n    }\n    this.css(cssReset);\n    return this;\n}\n", "const propertySetters = {\n    outerWidth: 'offsetWidth',\n    outerHeight: 'offsetHeight',\n    innerWidth: 'clientWidth',\n    innerHeight: 'clientHeight',\n    scrollLeft: 'scrollLeft',\n    scrollTop: 'scrollTop',\n    val: 'value',\n    text: 'textContent',\n};\n\nconst propertiesMap = {\n    disabled: 'disabled',\n    value: 'value',\n    text: 'textContent',\n};\n\nfunction prop(name, value) {\n    if (!name) throw new Error('no property provided');\n    if (arguments.length === 1) {\n        const [el] = this;\n        if (!el) return null;\n        return el[name];\n    }\n    if (value === undefined) return this;\n    for (let i = 0; i < this.length; i++) {\n        this[i][name] = value;\n    }\n    return this;\n}\n\nfunction attr(name, value) {\n    let attributes;\n    if (typeof name === 'string') {\n        if (value === undefined) {\n            const [el] = this;\n            if (!el) return null;\n            return el.getAttribute(name);\n        } else {\n            attributes = { [name]: value };\n        }\n    } else if (!name) {\n        throw new Error('no attributes provided');\n    } else {\n        attributes = name;\n    }\n    for (let attr in attributes) {\n        if (attributes.hasOwnProperty(attr)) {\n            const value = attributes[attr];\n            if (propertiesMap[attr]) {\n                this.prop(propertiesMap[attr], value);\n                continue;\n            }\n            for (let i = 0; i < this.length; i++) {\n                if (value === null) {\n                    this[i].removeAttribute(attr);\n                } else {\n                    this[i].setAttribute(attr, value);\n                }\n            }\n        }\n    }\n    return this;\n}\n\nconst methods = {\n    prop,\n    attr\n};\n\nObject.keys(propertySetters).forEach(methodName => {\n    methods[methodName] = function(...args) {\n        return this.prop(propertySetters[methodName], ...args);\n    };\n});\n\nexport default methods;\n", "export const config = {\n    // When set to `true` the cell selectors could be defined as CSS selectors.\n    // If not, only JSON Markup selectors are taken into account.\n    useCSSSelectors: false,\n    // The class name prefix config is for advanced use only.\n    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n    classNamePrefix: 'joint-',\n    defaultTheme: 'default',\n    // The maximum delay required for two consecutive touchend events to be interpreted\n    // as a double-tap.\n    doubleTapInterval: 300\n};\n", "// TODO: should not read config outside the mvc package\nimport { config } from '../../config/index.mjs';\nimport $ from './Dom.mjs';\n\n\n// Special events\n\nconst special = Object.create(null);\n\nexport default special;\n\nspecial.load = {\n    // Prevent triggered image.load events from bubbling to window.load\n    noBubble: true,\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in $.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n[\n    ['mouseenter', 'mouseover'],\n    ['mouseleave', 'mouseout'],\n    ['pointerenter', 'pointerover'],\n    ['pointerleave', 'pointerout'],\n].forEach(([orig, fix]) => {\n    special[orig] = {\n        delegateType: fix,\n        bindType: fix,\n        handle: function(event) {\n            const target = this;\n            const related = event.relatedTarget;\n            const handleObj = event.handleObj;\n            let ret;\n            // For mouseenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if (!related || !target.contains(related)) {\n                event.type = handleObj.origType;\n                ret = handleObj.handler.apply(target, arguments);\n                event.type = fix;\n            }\n            return ret;\n        },\n    };\n});\n\n\n// Gestures\n\nconst maxDelay = config.doubleTapInterval;\nconst minDelay = 30;\n\nspecial.dbltap = {\n    bindType: 'touchend',\n    delegateType: 'touchend',\n    handle: function(event, ...args) {\n        const { handleObj, target } = event;\n        const targetData = $.data.create(target);\n        const now = new Date().getTime();\n        const delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;\n        if (delta < maxDelay && delta > minDelay) {\n            targetData.lastTouch = null;\n            event.type = handleObj.origType;\n            // let $ handle the triggering of \"dbltap\" event handlers\n            handleObj.handler.call(this, event, ...args);\n        } else {\n            targetData.lastTouch = now;\n        }\n    }\n};\n", "import { default as $ } from './Dom.mjs';\nimport * as methods from './methods.mjs';\nimport * as animations from './animations.mjs';\nimport { default as props } from './props.mjs';\nimport { default as special } from './events.mjs';\n\nObject.assign($.fn, methods);\nObject.assign($.fn, animations);\nObject.assign($.fn, props);\nObject.assign($.event.special, special);\n\nexport default $;\n\n", "import $ from '../mvc/Dom/index.mjs';\nimport V from '../V/index.mjs';\nimport { config } from '../config/index.mjs';\nimport {\n    isBoolean,\n    isObject,\n    isNumber,\n    isString,\n    mixin,\n    deepMixin,\n    supplement,\n    defaults,\n    defaultsDeep,\n    deepSupplement,\n    assign,\n    invoke,\n    invokeProperty,\n    sortedIndex,\n    uniq,\n    clone,\n    cloneDeep,\n    isEmpty,\n    isEqual,\n    isFunction,\n    isPlainObject,\n    toArray,\n    debounce,\n    groupBy,\n    sortBy,\n    flattenDeep,\n    without,\n    difference,\n    intersection,\n    union,\n    has,\n    result,\n    omit,\n    pick,\n    bindAll,\n    forIn,\n    camelCase,\n    uniqueId,\n    merge\n} from './utilHelpers.mjs';\n\nexport const addClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, config.classNamePrefix.length) !== config.classNamePrefix) {\n            _className = config.classNamePrefix + _className;\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nexport const removeClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, config.classNamePrefix.length) === config.classNamePrefix) {\n            _className = _className.substr(config.classNamePrefix.length);\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nexport const parseDOMJSON = function(json, namespace) {\n\n    const selectors = {};\n    const groupSelectors = {};\n    const svgNamespace = V.namespace.svg;\n\n    const initialNS = namespace || svgNamespace;\n    const fragment = document.createDocumentFragment();\n\n    const parseNode = function(siblingsDef, parentNode, parentNS) {\n        for (let i = 0; i < siblingsDef.length; i++) {\n            const nodeDef = siblingsDef[i];\n\n            // Text node\n            if (typeof nodeDef === 'string') {\n                const textNode = document.createTextNode(nodeDef);\n                parentNode.appendChild(textNode);\n                continue;\n            }\n\n            // TagName\n            if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n            const tagName = nodeDef.tagName;\n\n            let node;\n\n            // Namespace URI\n            const ns = (nodeDef.hasOwnProperty('namespaceURI')) ? nodeDef.namespaceURI : parentNS;\n            node = document.createElementNS(ns, tagName);\n            const svg = (ns === svgNamespace);\n\n            const wrapperNode = (svg) ? V(node) : $(node);\n            // Attributes\n            const attributes = nodeDef.attributes;\n            if (attributes) wrapperNode.attr(attributes);\n            // Style\n            const style = nodeDef.style;\n            if (style) $(node).css(style);\n            // ClassName\n            if (nodeDef.hasOwnProperty('className')) {\n                const className = nodeDef.className;\n                if (svg) {\n                    node.className.baseVal = className;\n                } else {\n                    node.className = className;\n                }\n            }\n            // TextContent\n            if (nodeDef.hasOwnProperty('textContent')) {\n                node.textContent = nodeDef.textContent;\n            }\n            // Selector\n            if (nodeDef.hasOwnProperty('selector')) {\n                const nodeSelector = nodeDef.selector;\n                if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n                selectors[nodeSelector] = node;\n                wrapperNode.attr('joint-selector', nodeSelector);\n            }\n            // Groups\n            if (nodeDef.hasOwnProperty('groupSelector')) {\n                let nodeGroups = nodeDef.groupSelector;\n                if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n                for (let j = 0; j < nodeGroups.length; j++) {\n                    const nodeGroup = nodeGroups[j];\n                    let group = groupSelectors[nodeGroup];\n                    if (!group) group = groupSelectors[nodeGroup] = [];\n                    group.push(node);\n                }\n            }\n\n            parentNode.appendChild(node);\n\n            // Children\n            const childrenDef = nodeDef.children;\n            if (Array.isArray(childrenDef)) {\n                parseNode(childrenDef, node, ns);\n            }\n        }\n    };\n    parseNode(json, fragment, initialNS);\n    return {\n        fragment: fragment,\n        selectors: selectors,\n        groupSelectors: groupSelectors\n    };\n};\n\n// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\nexport const hashCode = function(str) {\n\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + c;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\n\nexport const getByPath = function(obj, path, delimiter) {\n\n    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    var key;\n    var i = 0;\n    var length = keys.length;\n    while (i < length) {\n        key = keys[i++];\n        if (Object(obj) === obj && key in obj) {\n            obj = obj[key];\n        } else {\n            return undefined;\n        }\n    }\n    return obj;\n};\n\nconst isGetSafe = function(obj, key) {\n    // Prevent prototype pollution\n    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n    if (typeof key !== 'string' && typeof key !== 'number') {\n        key = String(key);\n    }\n    if (key === 'constructor' && typeof obj[key] === 'function') {\n        return false;\n    }\n    if (key === '__proto__') {\n        return false;\n    }\n    return true;\n};\n\nexport const setByPath = function(obj, path, value, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        // diver creates an empty object if there is no nested object under such a key.\n        // This means that one can populate an empty nested object with setByPath().\n        diver = value || (diver[key] = {});\n    }\n\n    diver[keys[last]] = value;\n\n    return obj;\n};\n\nexport const unsetByPath = function(obj, path, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        if (!value) return obj;\n        diver = value;\n    }\n\n    delete diver[keys[last]];\n\n    return obj;\n};\n\nexport const flattenObject = function(obj, delim, stop) {\n\n    delim = delim || '/';\n    var ret = {};\n\n    for (var key in obj) {\n\n        if (!obj.hasOwnProperty(key)) continue;\n\n        var shouldGoDeeper = typeof obj[key] === 'object';\n        if (shouldGoDeeper && stop && stop(obj[key])) {\n            shouldGoDeeper = false;\n        }\n\n        if (shouldGoDeeper) {\n\n            var flatObject = flattenObject(obj[key], delim, stop);\n\n            for (var flatKey in flatObject) {\n                if (!flatObject.hasOwnProperty(flatKey)) continue;\n                ret[key + delim + flatKey] = flatObject[flatKey];\n            }\n\n        } else {\n\n            ret[key] = obj[key];\n        }\n    }\n\n    return ret;\n};\n\nexport const uuid = function() {\n\n    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0;\n        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n};\n\n// Generates global unique id and stores it as a property of the object, if provided.\nexport const guid = function(obj) {\n\n    guid.id = guid.id || 1;\n\n    if (obj === undefined) {\n        return 'j_' + guid.id++;\n    }\n\n    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n    return obj.id;\n};\n\nexport const toKebabCase = function(string) {\n\n    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\nexport const normalizeEvent = function(evt) {\n\n    if (evt.normalized) return evt;\n\n    const { originalEvent, target } = evt;\n\n    // If the event is a touch event, normalize it to a mouse event.\n    const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n    if (touch) {\n        for (let property in touch) {\n            // copy all the properties from the first touch that are not\n            // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n            if (evt[property] === undefined) {\n                evt[property] = touch[property];\n            }\n        }\n    }\n    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n    if (target) {\n        const useElement = target.correspondingUseElement;\n        if (useElement) evt.target = useElement;\n    }\n\n    evt.normalized = true;\n\n    return evt;\n};\n\nexport const normalizeWheel = function(evt) {\n    // Sane values derived empirically\n    const PIXEL_STEP  = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0, sY = 0, pX = 0, pY = 0;\n\n    // Legacy\n    if ('detail'      in evt) { sY = evt.detail; }\n    if ('wheelDelta'  in evt) { sY = -evt.wheelDelta / 120; }\n    if ('wheelDeltaY' in evt) { sY = -evt.wheelDeltaY / 120; }\n    if ('wheelDeltaX' in evt) { sX = -evt.wheelDeltaX / 120; }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ( 'axis' in evt && evt.axis === evt.HORIZONTAL_AXIS ) {\n        sX = sY;\n        sY = 0;\n    }\n\n    pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;\n    pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;\n\n    if ((pX || pY) && evt.deltaMode) {\n        if (evt.deltaMode == 1) {\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n        } else {\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n        }\n    }\n\n    // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n    if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n        pX = pY;\n        pY = 0;\n        sX = sY;\n        sY = 0;\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n    if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n    return {\n        spinX  : sX,\n        spinY  : sY,\n        deltaX : pX,\n        deltaY : pY,\n    };\n};\n\nexport const cap = function(val, max) {\n    return val > max ? max : val < -max ? -max : val;\n};\n\nexport const nextFrame = (function() {\n\n    var raf;\n\n    if (typeof window !== 'undefined') {\n\n        raf = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame;\n    }\n\n    if (!raf) {\n\n        var lastTime = 0;\n\n        raf = function(callback) {\n\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n\n            lastTime = currTime + timeToCall;\n\n            return id;\n        };\n    }\n\n    return function(callback, context, ...rest) {\n        return (context !== undefined)\n            ? raf(callback.bind(context, ...rest))\n            : raf(callback);\n    };\n\n})();\n\nexport const cancelFrame = (function() {\n\n    var caf;\n    var client = typeof window != 'undefined';\n\n    if (client) {\n\n        caf = window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.webkitCancelRequestAnimationFrame ||\n            window.msCancelAnimationFrame ||\n            window.msCancelRequestAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            window.oCancelRequestAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.mozCancelRequestAnimationFrame;\n    }\n\n    caf = caf || clearTimeout;\n\n    return client ? caf.bind(window) : caf;\n\n})();\n\nexport const isPercentage = function(val) {\n\n    return isString(val) && val.slice(-1) === '%';\n};\n\nexport const parseCssNumeric = function(val, restrictUnits) {\n\n    function getUnit(validUnitExp) {\n\n        // one or more numbers, followed by\n        // any number of (\n        //  `.`, followed by\n        //  one or more numbers\n        // ), followed by\n        // `validUnitExp`, followed by\n        // end of string\n        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n        if (!matches) return null;\n        return matches[1];\n    }\n\n    var number = parseFloat(val);\n\n    // if `val` cannot be parsed as a number, return `null`\n    if (Number.isNaN(number)) return null;\n\n    // else: we know `output.value`\n    var output = {};\n    output.value = number;\n\n    // determine the unit\n    var validUnitExp;\n    if (restrictUnits == null) {\n        // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = '[A-Za-z]*';\n\n    } else if (Array.isArray(restrictUnits)) {\n        // if this is an empty array, top restriction - return `null`\n        if (restrictUnits.length === 0) return null;\n\n        // else: restriction - an array of valid unit strings\n        validUnitExp = restrictUnits.join('|');\n\n    } else if (isString(restrictUnits)) {\n        // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n    }\n    var unit = getUnit(validUnitExp);\n\n    // if we found no matches for `restrictUnits`, return `null`\n    if (unit === null) return null;\n\n    // else: we know the unit\n    output.unit = unit;\n    return output;\n};\n\nconst NO_SPACE = 0;\n\nfunction splitWordWithEOL(word, eol) {\n    const eolWords = word.split(eol);\n    let n = 1;\n    for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {\n        const replacement = [];\n        if (j > 0 || eolWords[0] !== '') replacement.push(NO_SPACE);\n        replacement.push(eol);\n        if (j < jl - 1 || eolWords[jl] !== '') replacement.push(NO_SPACE);\n        eolWords.splice(n, 0, ...replacement);\n        n += replacement.length + 1;\n    }\n    return eolWords.filter(word => word !== '');\n}\n\n\nfunction getLineHeight(heightValue, textElement) {\n    if (heightValue === null) {\n        // Default 1em lineHeight\n        return textElement.getBBox().height;\n    }\n\n    switch (heightValue.unit) {\n        case 'em':\n            return textElement.getBBox().height * heightValue.value;\n        case 'px':\n        case '':\n            return heightValue.value;\n    }\n}\n\nexport const breakText = function(text, size, styles = {}, opt = {}) {\n\n    var width = size.width;\n    var height = size.height;\n\n    var svgDocument = opt.svgDocument || V('svg').node;\n    var textSpan = V('tspan').node;\n    var textElement = V('text').attr(styles).append(textSpan).node;\n    var textNode = document.createTextNode('');\n\n    // Prevent flickering\n    textElement.style.opacity = 0;\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    textElement.style.display = 'block';\n    textSpan.style.display = 'block';\n\n    textSpan.appendChild(textNode);\n    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n    if (!opt.svgDocument) {\n\n        document.body.appendChild(svgDocument);\n    }\n\n    const preserveSpaces = opt.preserveSpaces;\n    const space = ' ';\n    const separator = (opt.separator || opt.separator === '') ? opt.separator : space;\n    // If separator is a RegExp, we use the space character to join words together again (not ideal)\n    const separatorChar = (typeof separator === 'string') ? separator : space;\n    var eol = opt.eol || '\\n';\n    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d\\u00C0-\\u1FFF\\u2800-\\uFFFD]/;\n    var maxLineCount = opt.maxLineCount;\n    if (!isNumber(maxLineCount)) maxLineCount = Infinity;\n\n    var words = text.split(separator);\n    var full = [];\n    var lines = [];\n    var p, h;\n    var lineHeight;\n\n    if (preserveSpaces) {\n        V(textSpan).attr('xml:space', 'preserve');\n    }\n\n    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n        var word = words[i];\n\n        if (!word && !preserveSpaces) continue;\n        if (typeof word !== 'string') continue;\n\n        var isEol = false;\n        if (eol && word.indexOf(eol) >= 0) {\n            // word contains end-of-line character\n            if (word.length > 1) {\n                // separate word and continue cycle\n                const eolWords = splitWordWithEOL(words[i], eol);\n                words.splice(i, 1, ...eolWords);\n                i--;\n                len = words.length;\n                continue;\n            } else {\n                // creates a new line\n                if (preserveSpaces && typeof words[i - 1] === 'string' ) {\n                    words.splice(i, NO_SPACE, '', NO_SPACE);\n                    len += 2;\n                    i--;\n                    continue;\n                }\n                lines[++l] = (!preserveSpaces || typeof words[i + 1] === 'string') ? '' : undefined;\n                isEol = true;\n            }\n        }\n\n        if (!isEol) {\n\n            let data;\n            if (preserveSpaces) {\n                data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;\n            } else {\n                data = lines[l] ? lines[l] + separatorChar + word : word;\n            }\n\n            textNode.data = data;\n\n            if (textSpan.getComputedTextLength() <= width) {\n\n                // the current line fits\n                lines[l] = data;\n\n                if (p || h) {\n                    // We were partitioning. Put rest of the word onto next line\n                    full[l++] = true;\n\n                    // cancel partitioning and splitting by hyphens\n                    p = 0;\n                    h = 0;\n                }\n\n            } else {\n\n                if (!lines[l] || p) {\n\n                    var partition = !!p;\n\n                    p = word.length - 1;\n\n                    if (partition || !p) {\n\n                        // word has only one character.\n                        if (!p) {\n\n                            if (!lines[l]) {\n\n                                // we won't fit this text within our rect\n                                lines = [];\n\n                                break;\n                            }\n\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n\n                            // cancel partitions created\n                            words.splice(i, 2, word + words[i + 1]);\n\n                            // adjust word length\n                            len--;\n\n                            full[l++] = true;\n                            i--;\n\n                            continue;\n                        }\n\n                        // move last letter to the beginning of the next word\n                        words[i] = word.substring(0, p);\n                        const nextWord = words[i + 1];\n                        words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? '' : nextWord);\n\n                    } else {\n\n                        if (h) {\n                        // cancel splitting and put the words together again\n                            words.splice(i, 2, words[i] + words[i + 1]);\n                            h = 0;\n                        } else {\n                            var hyphenIndex = word.search(hyphen);\n                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                h = hyphenIndex + 1;\n                                p = 0;\n                            }\n\n                            // We initiate partitioning or splitting\n                            // split the long word into two words\n                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n                            // adjust words length\n                            len++;\n\n                        }\n\n                        if (l && !full[l - 1]) {\n                        // if the previous line is not full, try to fit max part of\n                        // the current word there\n                            l--;\n                        }\n                    }\n\n                    if (!preserveSpaces || lines[l] !== '') {\n                        i--;\n                    }\n\n                    continue;\n                }\n\n                l++;\n                i--;\n            }\n        }\n        var lastL = null;\n\n        if (lines.length > maxLineCount) {\n\n            lastL = maxLineCount - 1;\n\n        } else if (height !== undefined) {\n\n            // if size.height is defined we have to check whether the height of the entire\n            // text exceeds the rect height\n\n            if (lineHeight === undefined && textNode.data !== '') {\n\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === 'auto') {\n                    lineHeight = getLineHeight({ value: 1.5, unit: 'em' }, textElement);\n                } else {\n                    const parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);\n\n                    lineHeight = getLineHeight(parsed, textElement);\n                }\n            }\n\n            if (lineHeight * lines.length > height) {\n                // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n        }\n\n        if (lastL !== null) {\n\n            lines.splice(lastL + 1);\n\n            // add ellipsis\n            var ellipsis = opt.ellipsis;\n            if (!ellipsis || lastL < 0) break;\n            if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\n            var lastLine = lines[lastL];\n            if (!lastLine && !isEol) break;\n            var k = lastLine.length;\n            var lastLineWithOmission, lastChar;\n            do {\n                lastChar = lastLine[k];\n                lastLineWithOmission = lastLine.substring(0, k);\n                if (!lastChar) {\n                    lastLineWithOmission += separatorChar;\n                } else if (lastChar.match(separator)) {\n                    lastLineWithOmission += lastChar;\n                }\n                lastLineWithOmission += ellipsis;\n                textNode.data = lastLineWithOmission;\n                if (textSpan.getComputedTextLength() <= width) {\n                    lines[lastL] = lastLineWithOmission;\n                    break;\n                }\n                k--;\n            } while (k >= 0);\n            break;\n        }\n    }\n\n    if (opt.svgDocument) {\n\n        // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n\n    } else {\n\n        // clean svg document\n        document.body.removeChild(svgDocument);\n    }\n\n    return lines.join(eol);\n};\n\n// Sanitize HTML\n// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n// Parses a string into an array of DOM nodes.\n// Then outputs it back as a string.\nexport const sanitizeHTML = function(html) {\n\n    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n    const [outputEl] = $.parseHTML('<div>' + html + '</div>');\n\n    Array.from(outputEl.getElementsByTagName('*')).forEach(function(node) { // for all nodes\n        const names = node.getAttributeNames();\n        names.forEach(function(name) {\n            const value = node.getAttribute(name);\n            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n            if (name.startsWith('on') || value.startsWith('javascript:' || value.startsWith('data:') || value.startsWith('vbscript:'))) {\n                node.removeAttribute(name);\n            }\n        });\n    });\n\n    return outputEl.innerHTML;\n};\n\n// Download `blob` as file with `fileName`.\n// Does not work in IE9.\nexport const downloadBlob = function(blob, fileName) {\n\n    if (window.navigator.msSaveBlob) { // requires IE 10+\n        // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n\n    } else { // other browsers\n        // downloads directly in Chrome and Safari\n\n        // presents a save/open dialog in Firefox\n        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement('a');\n\n        link.href = url;\n        link.download = fileName;\n        document.body.appendChild(link);\n\n        link.click();\n\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n    }\n};\n\n// Download `dataUri` as file with `fileName`.\n// Does not work in IE9.\nexport const downloadDataUri = function(dataUri, fileName) {\n\n    const blob = dataUriToBlob(dataUri);\n    downloadBlob(blob, fileName);\n};\n\n// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\nexport const dataUriToBlob = function(dataUri) {\n\n    // first, make sure there are no newlines in the data uri\n    dataUri = dataUri.replace(/\\s/g, '');\n    dataUri = decodeURIComponent(dataUri);\n\n    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n    var data = dataUri.slice(firstCommaIndex + 1);\n    var decodedString;\n    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n        decodedString = atob(data); // decode data\n    } else {\n        // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    var ia = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n        ia[i] = decodedString.charCodeAt(i);\n    }\n\n    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n};\n\n// Read an image at `url` and return it as base64-encoded data uri.\n// The mime type of the image is inferred from the `url` file extension.\n// If data uri is provided as `url`, it is returned back unchanged.\n// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n// Works with IE9.\nexport const imageToDataUri = function(url, callback) {\n\n    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n        // No need to convert to data uri if it is already in data uri.\n\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n    }\n\n    // chrome, IE10+\n    var modernHandler = function(xhr, callback) {\n\n        if (xhr.status === 200) {\n\n            var reader = new FileReader();\n\n            reader.onload = function(evt) {\n                var dataUri = evt.target.result;\n                callback(null, dataUri);\n            };\n\n            reader.onerror = function() {\n                callback(new Error('Failed to load image ' + url));\n            };\n\n            reader.readAsDataURL(xhr.response);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var legacyHandler = function(xhr, callback) {\n\n        var Uint8ToString = function(u8a) {\n            var CHUNK_SZ = 0x8000;\n            var c = [];\n            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n            }\n            return c.join('');\n        };\n\n        if (xhr.status === 200) {\n\n            var bytes = new Uint8Array(xhr.response);\n\n            var suffix = (url.split('.').pop()) || 'png';\n            var map = {\n                'svg': 'svg+xml'\n            };\n            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n            var b64encoded = meta + btoa(Uint8ToString(bytes));\n            callback(null, b64encoded);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', function() {\n        callback(new Error('Failed to load image ' + url));\n    });\n\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n    xhr.addEventListener('load', function() {\n        if (window.FileReader) {\n            modernHandler(xhr, callback);\n        } else {\n            legacyHandler(xhr, callback);\n        }\n    });\n\n    xhr.send();\n};\n\nexport const getElementBBox = function(el) {\n\n    var $el = $(el);\n    if ($el.length === 0) {\n        throw new Error('Element not found');\n    }\n\n    var element = $el[0];\n    var doc = element.ownerDocument;\n    var clientBBox = element.getBoundingClientRect();\n\n    var strokeWidthX = 0;\n    var strokeWidthY = 0;\n\n    // Firefox correction\n    if (element.ownerSVGElement) {\n\n        var vel = V(element);\n        var bbox = vel.getBBox({ target: vel.svg() });\n\n        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n        strokeWidthX = (clientBBox.width - bbox.width);\n        strokeWidthY = (clientBBox.height - bbox.height);\n    }\n\n    return {\n        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n        width: clientBBox.width - strokeWidthX,\n        height: clientBBox.height - strokeWidthY\n    };\n};\n\n\n// Highly inspired by the jquery.sortElements plugin by Padolsey.\n// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\nexport const sortElements = function(elements, comparator) {\n\n    elements = $(elements).toArray();\n    var placements = elements.map(function(sortElement) {\n\n        var parentNode = sortElement.parentNode;\n        // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n        return function() {\n\n            if (parentNode === this) {\n                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n            }\n\n            // Insert before flag:\n            parentNode.insertBefore(this, nextSibling);\n            // Remove flag:\n            parentNode.removeChild(nextSibling);\n        };\n    });\n\n    elements.sort(comparator);\n    for (var i = 0; i < placements.length; i++) {\n        placements[i].call(elements[i]);\n    }\n    return elements;\n};\n\n// Sets attributes on the given element and its descendants based on the selector.\n// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\nexport const setAttributesBySelector = function(element, attrs) {\n\n    var $element = $(element);\n\n    forIn(attrs, function(attrs, selector) {\n        var $elements = $element.find(selector).addBack().filter(selector);\n        // Make a special case for setting classes.\n        // We do not want to overwrite any existing class.\n        if (has(attrs, 'class')) {\n            $elements.addClass(attrs['class']);\n            attrs = omit(attrs, 'class');\n        }\n        $elements.attr(attrs);\n    });\n};\n\n// Return a new object with all four sides (top, right, bottom, left) in it.\n// Value of each side is taken from the given argument (either number or object).\n// Default value for a side is 0.\n// Examples:\n// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\nexport const normalizeSides = function(box) {\n\n    if (Object(box) !== box) { // `box` is not an object\n        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n        return { top: val, right: val, bottom: val, left: val };\n    }\n\n    // `box` is an object\n    var top, right, bottom, left;\n    top = right = bottom = left = 0;\n\n    if (isFinite(box.vertical)) top = bottom = +box.vertical;\n    if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\n    if (isFinite(box.top)) top = +box.top; // overwrite vertical\n    if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n    if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n    return { top: top, right: right, bottom: bottom, left: left };\n};\n\nexport const timing = {\n\n    linear: function(t) {\n        return t;\n    },\n\n    quad: function(t) {\n        return t * t;\n    },\n\n    cubic: function(t) {\n        return t * t * t;\n    },\n\n    inout: function(t) {\n        if (t <= 0) return 0;\n        if (t >= 1) return 1;\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n    },\n\n    exponential: function(t) {\n        return Math.pow(2, 10 * (t - 1));\n    },\n\n    bounce: function(t) {\n        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n            if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        }\n    },\n\n    reverse: function(f) {\n        return function(t) {\n            return 1 - f(1 - t);\n        };\n    },\n\n    reflect: function(f) {\n        return function(t) {\n            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n        };\n    },\n\n    clamp: function(f, n, x) {\n        n = n || 0;\n        x = x || 1;\n        return function(t) {\n            var r = f(t);\n            return r < n ? n : r > x ? x : r;\n        };\n    },\n\n    back: function(s) {\n        if (!s) s = 1.70158;\n        return function(t) {\n            return t * t * ((s + 1) * t - s);\n        };\n    },\n\n    elastic: function(x) {\n        if (!x) x = 1.5;\n        return function(t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n        };\n    }\n};\n\nexport const interpolate = {\n\n    number: function(a, b) {\n        var d = b - a;\n        return function(t) {\n            return a + d * t;\n        };\n    },\n\n    object: function(a, b) {\n        var s = Object.keys(a);\n        return function(t) {\n            var i, p;\n            var r = {};\n            for (i = s.length - 1; i != -1; i--) {\n                p = s[i];\n                r[p] = a[p] + (b[p] - a[p]) * t;\n            }\n            return r;\n        };\n    },\n\n    hexColor: function(a, b) {\n\n        var ca = parseInt(a.slice(1), 16);\n        var cb = parseInt(b.slice(1), 16);\n        var ra = ca & 0x0000ff;\n        var rd = (cb & 0x0000ff) - ra;\n        var ga = ca & 0x00ff00;\n        var gd = (cb & 0x00ff00) - ga;\n        var ba = ca & 0xff0000;\n        var bd = (cb & 0xff0000) - ba;\n\n        return function(t) {\n\n            var r = (ra + rd * t) & 0x000000ff;\n            var g = (ga + gd * t) & 0x0000ff00;\n            var b = (ba + bd * t) & 0x00ff0000;\n\n            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n        };\n    },\n\n    unit: function(a, b) {\n\n        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n        var ma = r.exec(a);\n        var mb = r.exec(b);\n        var p = mb[1].indexOf('.');\n        var f = p > 0 ? mb[1].length - p - 1 : 0;\n        a = +ma[1];\n        var d = +mb[1] - a;\n        var u = ma[2];\n\n        return function(t) {\n            return (a + d * t).toFixed(f) + u;\n        };\n    }\n};\n\n// SVG filters.\n// (values in parentheses are default values)\nexport const filter = {\n\n    // `color` ... outline color ('blue')\n    // `width`... outline width (1)\n    // `opacity` ... outline opacity (1)\n    // `margin` ... gap between outline and the element (2)\n    outline: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n        var width = Number.isFinite(args.width) ? args.width : 1;\n\n        return template(tpl)({\n            color: args.color || 'blue',\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            outerRadius: margin + width,\n            innerRadius: margin\n        });\n    },\n\n    // `color` ... color ('red')\n    // `width`... width (1)\n    // `blur` ... blur (0)\n    // `opacity` ... opacity (1)\n    highlight: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n        return template(tpl)({\n            color: args.color || 'red',\n            width: Number.isFinite(args.width) ? args.width : 1,\n            blur: Number.isFinite(args.blur) ? args.blur : 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n        });\n    },\n\n    // `x` ... horizontal blur (2)\n    // `y` ... vertical blur (optional)\n    blur: function(args) {\n\n        var x = Number.isFinite(args.x) ? args.x : 2;\n\n        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n        });\n    },\n\n    // `dx` ... horizontal shift (0)\n    // `dy` ... vertical shift (0)\n    // `blur` ... blur (4)\n    // `color` ... color ('black')\n    // `opacity` ... opacity (1)\n    dropShadow: function(args) {\n\n        var tpl = 'SVGFEDropShadowElement' in window\n            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        return template(tpl)({\n            dx: args.dx || 0,\n            dy: args.dy || 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            color: args.color || 'black',\n            blur: Number.isFinite(args.blur) ? args.blur : 4\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n    grayscale: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n    sepia: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n    saturate: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - amount\n        });\n    },\n\n    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n    hueRotate: function(args) {\n\n        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: args.angle || 0\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n    invert: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: 1 - amount\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    brightness: function(args) {\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(args.amount) ? args.amount : 1\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    contrast: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    }\n};\n\nexport const format = {\n\n    // Formatting numbers via the Python Format Specification Mini-language.\n    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n    // Heavilly inspired by the D3.js library implementation.\n    number: function(specifier, value, locale) {\n\n        locale = locale || {\n\n            currency: ['$', ''],\n            decimal: '.',\n            thousands: ',',\n            grouping: [3]\n        };\n\n        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n        var match = re.exec(specifier);\n        var fill = match[1] || ' ';\n        var align = match[2] || '>';\n        var sign = match[3] || '';\n        var symbol = match[4] || '';\n        var zfill = match[5];\n        var width = +match[6];\n        var comma = match[7];\n        var precision = match[8];\n        var type = match[9];\n        var scale = 1;\n        var prefix = '';\n        var suffix = '';\n        var integer = false;\n\n        if (precision) precision = +precision.substring(1);\n\n        if (zfill || fill === '0' && align === '=') {\n            zfill = fill = '0';\n            align = '=';\n            if (comma) width -= Math.floor((width - 1) / 4);\n        }\n\n        switch (type) {\n            case 'n':\n                comma = true;\n                type = 'g';\n                break;\n            case '%':\n                scale = 100;\n                suffix = '%';\n                type = 'f';\n                break;\n            case 'p':\n                scale = 100;\n                suffix = '%';\n                type = 'r';\n                break;\n            case 'b':\n            case 'o':\n            case 'x':\n            case 'X':\n                if (symbol === '#') prefix = '0' + type.toLowerCase();\n                break;\n            case 'c':\n            case 'd':\n                integer = true;\n                precision = 0;\n                break;\n            case 's':\n                scale = -1;\n                type = 'r';\n                break;\n        }\n\n        if (symbol === '$') {\n            prefix = locale.currency[0];\n            suffix = locale.currency[1];\n        }\n\n        // If no precision is specified for `'r'`, fallback to general notation.\n        if (type == 'r' && !precision) type = 'g';\n\n        // Ensure that the requested precision is in the supported range.\n        if (precision != null) {\n            if (type == 'g') precision = Math.max(1, Math.min(21, precision));\n            else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n        }\n\n        var zcomma = zfill && comma;\n\n        // Return the empty string for floats formatted as ints.\n        if (integer && (value % 1)) return '';\n\n        // Convert negative to positive, and record the sign prefix.\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n        var fullSuffix = suffix;\n\n        // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n        if (scale < 0) {\n            var unit = this.prefix(value, precision);\n            value = unit.scale(value);\n            fullSuffix = unit.symbol + suffix;\n        } else {\n            value *= scale;\n        }\n\n        // Convert to the desired precision.\n        value = this.convert(type, value, precision);\n\n        // Break the value into the integer part (before) and decimal part (after).\n        var i = value.lastIndexOf('.');\n        var before = i < 0 ? value : value.substring(0, i);\n        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n        function formatGroup(value) {\n\n            var i = value.length;\n            var t = [];\n            var j = 0;\n            var g = locale.grouping[0];\n            while (i > 0 && g > 0) {\n                t.push(value.substring(i -= g, i + g));\n                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n            }\n            return t.reverse().join(locale.thousands);\n        }\n\n        // If the fill character is not `'0'`, grouping is applied before padding.\n        if (!zfill && comma && locale.grouping) {\n\n            before = formatGroup(before);\n        }\n\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n        // If the fill character is `'0'`, grouping is applied after padding.\n        if (zcomma) before = formatGroup(padding + before);\n\n        // Apply prefix.\n        negative += prefix;\n\n        // Rejoin integer and decimal parts.\n        value = before + after;\n\n        return (align === '<' ? negative + value + padding\n            : align === '>' ? padding + negative + value\n                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n    },\n\n    // Formatting string via the Python Format string.\n    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n    string: function(formatString, value) {\n\n        var fieldDelimiterIndex;\n        var fieldDelimiter = '{';\n        var endPlaceholder = false;\n        var formattedStringArray = [];\n\n        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n            var pieceFormattedString, formatSpec, fieldName;\n\n            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n            if (endPlaceholder) {\n                formatSpec = pieceFormattedString.split(':');\n                fieldName = formatSpec.shift().split('.');\n                pieceFormattedString = value;\n\n                for (var i = 0; i < fieldName.length; i++)\n                    pieceFormattedString = pieceFormattedString[fieldName[i]];\n\n                if (formatSpec.length)\n                    pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n            }\n\n            formattedStringArray.push(pieceFormattedString);\n\n            formatString = formatString.slice(fieldDelimiterIndex + 1);\n            endPlaceholder = !endPlaceholder;\n            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n        }\n        formattedStringArray.push(formatString);\n\n        return formattedStringArray.join('');\n    },\n\n    convert: function(type, value, precision) {\n\n        switch (type) {\n            case 'b':\n                return value.toString(2);\n            case 'c':\n                return String.fromCharCode(value);\n            case 'o':\n                return value.toString(8);\n            case 'x':\n                return value.toString(16);\n            case 'X':\n                return value.toString(16).toUpperCase();\n            case 'g':\n                return value.toPrecision(precision);\n            case 'e':\n                return value.toExponential(precision);\n            case 'f':\n                return value.toFixed(precision);\n            case 'r':\n                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n            default:\n                return value + '';\n        }\n    },\n\n    round: function(value, precision) {\n\n        return precision\n            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n            : Math.round(value);\n    },\n\n    precision: function(value, precision) {\n\n        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n    },\n\n    prefix: function(value, precision) {\n\n        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', 'µ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n            var k = Math.pow(10, Math.abs(8 - i) * 3);\n            return {\n                scale: i > 8 ? function(d) {\n                    return d / k;\n                } : function(d) {\n                    return d * k;\n                },\n                symbol: d\n            };\n        });\n\n        var i = 0;\n        if (value) {\n            if (value < 0) value *= -1;\n            if (precision) value = this.round(value, this.precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n        }\n        return prefixes[8 + i / 3];\n    }\n};\n\n/*\n    Pre-compile the HTML to be used as a template.\n*/\nexport const template = function(html) {\n\n    /*\n        Must support the variation in templating syntax found here:\n        https://lodash.com/docs#template\n    */\n    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n    return function(data) {\n\n        data = data || {};\n\n        return html.replace(regex, function(match) {\n\n            var args = Array.from(arguments);\n            var attr = args.slice(1, 4).find(function(_attr) {\n                return !!_attr;\n            });\n\n            var attrArray = attr.split('.');\n            var value = data[attrArray.shift()];\n\n            while (value !== undefined && attrArray.length) {\n                value = value[attrArray.shift()];\n            }\n\n            return value !== undefined ? value : '';\n        });\n    };\n};\n\n/**\n * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n */\nexport const toggleFullScreen = function(el) {\n\n    var topDocument = window.top.document;\n    el = el || topDocument.body;\n\n    function prefixedResult(el, prop) {\n\n        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n        for (var i = 0; i < prefixes.length; i++) {\n            var prefix = prefixes[i];\n            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n            if (el[propName] !== undefined) {\n                return isFunction(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n    }\n\n    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n    } else {\n        prefixedResult(el, 'RequestFullscreen') || // Spec.\n        prefixedResult(el, 'RequestFullScreen'); // Firefox\n    }\n};\n\nfunction findDifference(obj, baseObj, currentDepth, maxDepth) {\n\n    if (currentDepth === maxDepth) {\n        return {};\n    }\n\n    const diff = {};\n\n    Object.keys(obj).forEach((key) => {\n\n        const objValue = obj[key];\n        const baseValue = baseObj[key];\n\n        if (!Array.isArray(objValue) && !Array.isArray(baseValue) && isObject(objValue) && isObject(baseValue)) {\n\n            const nestedDepth = currentDepth + 1;\n            const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);\n\n            if (Object.keys(nestedDiff).length > 0) {\n                diff[key] = nestedDiff;\n            } else if ((currentDepth === 0 || nestedDepth === maxDepth)) {\n                diff[key] = {};\n            }\n\n        } else if (!isEqual(objValue, baseValue)) {\n            diff[key] = objValue;\n        }\n    });\n\n    return diff;\n}\n\nexport function objectDifference(object, base, opt) {\n\n    const { maxDepth = Number.POSITIVE_INFINITY } = opt || {};\n\n    return findDifference(object, base, 0, maxDepth);\n}\n\nexport {\n    isBoolean,\n    isObject,\n    isNumber,\n    isString,\n    mixin,\n    deepMixin,\n    supplement,\n    defaults,\n    deepSupplement,\n    defaultsDeep,\n    assign,\n    invoke,\n    invokeProperty,\n    sortedIndex,\n    uniq,\n    clone,\n    cloneDeep,\n    isEmpty,\n    isEqual,\n    isFunction,\n    isPlainObject,\n    toArray,\n    debounce,\n    groupBy,\n    sortBy,\n    flattenDeep,\n    without,\n    difference,\n    intersection,\n    union,\n    has,\n    result,\n    omit,\n    pick,\n    bindAll,\n    forIn,\n    camelCase,\n    uniqueId,\n    merge\n};\n\nexport const noop = function() {\n    // Do nothing.\n};\n", "import {\n    isEmpty,\n    uniqueId \n} from '../util/util.mjs';\n\n// Events\n// ---------------\n\n// A module that can be mixed in to *any object* in order to provide it with\n// a custom event channel. You may bind a callback to an event with `on` or\n// remove with `off`; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     const object = {};\n//     assign(object, Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nexport var Events = {};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// A private global variable to share between listeners and listenees.\nvar _listening;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n    // Handle event maps.\n        if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n        for (names = Object.keys(name); i < names.length ; i++) {\n            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n        }\n    } else if (name && eventSplitter.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n        for (names = name.split(eventSplitter); i < names.length; i++) {\n            events = iteratee(events, names[i], callback, opts);\n        }\n    } else {\n    // Finally, standard events.\n        events = iteratee(events, name, callback, opts);\n    }\n    return events;\n};\n\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\n// the callback to all events fired.\nEvents.on = function(name, callback, context) {\n    this._events = eventsApi(onApi, this._events || {}, name, callback, {\n        context: context,\n        ctx: this,\n        listening: _listening\n    });\n\n    if (_listening) {\n        var listeners = this._listeners || (this._listeners = {});\n        listeners[_listening.id] = _listening;\n        // Allow the listening to use a counter, instead of tracking\n        // callbacks for library interop\n        _listening.interop = false;\n    }\n\n    return this;\n};\n\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\n// an event in another object... keeping track of what it's listening to\n// for easier unbinding later.\nEvents.listenTo = function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = uniqueId('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = _listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n        this._listenId || (this._listenId = uniqueId('l'));\n        listening = _listening = listeningTo[id] = new Listening(this, obj);\n    }\n\n    // Bind callbacks on obj.\n    var error = tryCatchOn(obj, name, callback, this);\n    _listening = void 0;\n\n    if (error) throw error;\n    // If the target obj is not Events, track events manually.\n    if (listening.interop) listening.on(name, callback);\n\n    return this;\n};\n\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function(events, name, callback, options) {\n    if (callback) {\n        var handlers = events[name] || (events[name] = []);\n        var context = options.context, ctx = options.ctx, listening = options.listening;\n        if (listening) listening.count++;\n\n        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n    }\n    return events;\n};\n\n// An try-catch guarded #on function, to prevent poisoning the global\n// `_listening` variable.\nvar tryCatchOn = function(obj, name, callback, context) {\n    try {\n        obj.on(name, callback, context);\n    } catch (e) {\n        return e;\n    }\n};\n\n// Remove one or many callbacks. If `context` is null, removes all\n// callbacks with that function. If `callback` is null, removes all\n// callbacks for the event. If `name` is null, removes all bound\n// callbacks for all events.\nEvents.off = function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n    });\n\n    return this;\n};\n\n// Tell this object to stop listening to either specific events ... or\n// to every object it's currently listening to.\nEvents.stopListening = function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n    for (var i = 0; i < ids.length; i++) {\n        var listening = listeningTo[ids[i]];\n\n        // If listening doesn't exist, this object is not currently\n        // listening to obj. Break out early.\n        if (!listening) break;\n\n        listening.obj.off(name, callback, this);\n        if (listening.interop) listening.off(name, callback);\n    }\n    if (isEmpty(listeningTo)) this._listeningTo = void 0;\n\n    return this;\n};\n\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var context = options.context, listeners = options.listeners;\n    var i = 0, names;\n\n    // Delete all event listeners and \"drop\" events.\n    if (!name && !context && !callback) {\n        if(listeners != null) {\n            for (names = Object.keys(listeners); i < names.length; i++) {\n                listeners[names[i]].cleanup();\n            }\n        }\n        return;\n    }\n    names = name ? [name] : Object.keys(events);\n    for (; i < names.length; i++) {\n        name = names[i];\n        var handlers = events[name];\n\n        // Bail out if there are no events stored.\n        if (!handlers) break;\n\n        // Find any remaining events.\n        var remaining = [];\n        for (var j = 0; j < handlers.length; j++) {\n            var handler = handlers[j];\n            if (\n                callback && callback !== handler.callback &&\n        callback !== handler.callback._callback ||\n          context && context !== handler.context\n            ) {\n                remaining.push(handler);\n            } else {\n                var listening = handler.listening;\n                if (listening) listening.off(name, callback);\n            }\n        }\n\n        // Replace events if there are any remaining.  Otherwise, clean up.\n        if (remaining.length) {\n            events[name] = remaining;\n        } else {\n            delete events[name];\n        }\n    }\n\n    return events;\n};\n\n// Bind an event to only be triggered a single time. After the first time\n// the callback is invoked, its listener will be removed. If multiple events\n// are passed in using the space-separated syntax, the handler will fire\n// once for each event, not once for a combination of all events.\nEvents.once = function(name, callback, context) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n    if (typeof name === 'string' && context == null) callback = void 0;\n    return this.on(events, callback, context);\n};\n\n// Inversion-of-control versions of `once`.\nEvents.listenToOnce = function(obj, name, callback) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n    return this.listenTo(obj, events);\n};\n\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n// `offer` unbinds the `onceWrapper` after it has been called.\nvar onceMap = function(map, name, callback, offer) {\n    if (callback) {\n        var once = map[name] = onceInvoke(function() {\n            offer(name, once);\n            callback.apply(this, arguments);\n        });\n        once._callback = callback;\n    }\n    return map;\n};\n\n// Creates a function that is restricted to invoking 'func' once.\n// Repeat calls to the function return the value of the first invocation.\nvar onceInvoke = function(func) {\n    var result;\n    if (typeof func != 'function') {\n        throw new TypeError('Expected a function');\n    }\n    var n = 2;\n    return function() {\n        if (--n > 0) {\n            result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n            func = undefined;\n        }\n        return result;\n    };\n};\n\n// Trigger one or many events, firing all bound callbacks. Callbacks are\n// passed the same arguments as `trigger` is, apart from the event name\n// (unless you're listening on `\"all\"`, which will cause your callback to\n// receive the true name of the event as the first argument).\nEvents.trigger = function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n};\n\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function(objEvents, name, callback, args) {\n    if (objEvents) {\n        var events = objEvents[name];\n        var allEvents = objEvents.all;\n        if (events && allEvents) allEvents = allEvents.slice();\n        if (events) triggerEvents(events, args);\n        if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// events have 3 arguments).\nvar triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n};\n\n// A listening class that tracks and cleans up memory bindings\n// when all callbacks have been offed.\nvar Listening = function(listener, obj) {\n    this.id = listener._listenId;\n    this.listener = listener;\n    this.obj = obj;\n    this.interop = true;\n    this.count = 0;\n    this._events = void 0;\n};\n\nListening.prototype.on = Events.on;\n\n// Offs a callback (or several).\n// Uses an optimized counter if the listenee uses Events.\n// Otherwise, falls back to manual tracking to support events\n// library interop.\nListening.prototype.off = function(name, callback) {\n    var cleanup;\n    if (this.interop) {\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: void 0,\n            listeners: void 0\n        });\n        cleanup = !this._events;\n    } else {\n        this.count--;\n        cleanup = this.count === 0;\n    }\n    if (cleanup) this.cleanup();\n};\n\n// Cleans up memory bindings between the listener and the listenee.\nListening.prototype.cleanup = function() {\n    delete this.listener._listeningTo[this.obj._listenId];\n    if (!this.interop) delete this.obj._listeners[this.id];\n};\n\n// Aliases for backwards compatibility.\nEvents.bind   = Events.on;\nEvents.unbind = Events.off;\n", "import {\n    assign,\n    forIn,\n    has,\n    isFunction,\n    isObject,\n    isString\n} from '../util/util.mjs';\nimport { matches } from '../util/utilHelpers.mjs';\n\n// Helpers\n// -------\n\n// Helper function to correctly set up the prototype chain for subclasses.\n// Similar to `goog.inherits`, but uses a hash of prototype properties and\n// class properties to be extended.\nexport var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent constructor.\n    if (protoProps && has(protoProps, 'constructor')) {\n        child = protoProps.constructor;\n    } else {\n        child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    assign(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function and add the prototype properties.\n    child.prototype = Object.assign(Object.create(parent.prototype), protoProps);\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n};\n\n// Proxy class methods to functions, wrapping the model's\n// `attributes` object or collection's `models` array behind the scenes.\n//\n// `Function#apply` can be slow so we use the method's arg count, if we know it.\nvar addMethod = function(base, length, method, attribute) {\n    switch (length) {\n        case 1: return function() {\n            return base[method](this[attribute]);\n        };\n        case 2: return function(value) {\n            return base[method](this[attribute], value);\n        };\n        case 3: return function(iteratee, context) {\n            return base[method](this[attribute], cb(iteratee, this), context);\n        };\n        case 4: return function(iteratee, defaultVal, context) {\n            return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n        };\n        default: return function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(this[attribute]);\n            return base[method].apply(base, args);\n        };\n    }\n};\n\nexport var addMethodsUtil = function(Class, base, methods, attribute) {\n    forIn(methods, function(length, method) {\n        if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n    });\n};\n\n// Support `collection.sortBy('attr')`.\nvar cb = function(iteratee, instance) {\n    if (isFunction(iteratee)) return iteratee;\n    if (isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if (isString(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n};\n\nvar modelMatcher = function(attrs) {\n    var matcher = matches(attrs);\n    return function(model) {\n        return matcher(model.attributes);\n    };\n};\n", "import { Events } from './Events.mjs';\nimport { extend } from './mvcUtils.mjs';\nimport {\n    assign,\n    clone,\n    defaults,\n    has,\n    isEqual,\n    isEmpty,\n    result,\n    uniqueId\n} from '../util/util.mjs';\n\n// Model\n// --------------\n\n// **Models** are the basic data object in the framework --\n// frequently representing a row in a table in a database on your server.\n// A discrete chunk of data and a bunch of useful, related methods for\n// performing computations and transformations on that data.\n\n// Create a new model with the specified attributes. A client id (`cid`)\n// is automatically generated and assigned for you.\n\nexport var Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    this.cid = uniqueId(this.cidPrefix);\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    var attributeDefaults = result(this, 'defaults');\n\n    // Just _.defaults would work fine, but the additional _.extends\n    // is in there for historical reasons. See #3843.\n    attrs = defaults(assign({}, attributeDefaults, attrs), attributeDefaults);\n\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n};\n\n// Attach all inheritable methods to the Model prototype.\nassign(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // The prefix is used to create the client id which is used to identify models locally.\n    // You may want to override this if you're experiencing name clashes with model ids.\n    cidPrefix: 'c',\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Model.\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n        return clone(this.attributes);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n        return this.attributes[attr];\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n        return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n        if (key == null) return this;\n\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\n        var attrs;\n        if (typeof key === 'object') {\n            attrs = key;\n            options = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        options || (options = {});\n\n        // Run validation.\n        if (!this._validate(attrs, options)) return false;\n\n        // Extract attributes and options.\n        var unset      = options.unset;\n        var silent     = options.silent;\n        var changes    = [];\n        var changing   = this._changing;\n        this._changing = true;\n\n        if (!changing) {\n            this._previousAttributes = clone(this.attributes);\n            this.changed = {};\n        }\n\n        var current = this.attributes;\n        var changed = this.changed;\n        var prev    = this._previousAttributes;\n\n        // For each `set` attribute, update or delete the current value.\n        for (var attr in attrs) {\n            val = attrs[attr];\n            if (!isEqual(current[attr], val)) changes.push(attr);\n            if (!isEqual(prev[attr], val)) {\n                changed[attr] = val;\n            } else {\n                delete changed[attr];\n            }\n            unset ? delete current[attr] : current[attr] = val;\n        }\n\n        // Update the `id`.\n        if (this.idAttribute in attrs) {\n            var prevId = this.id;\n            this.id = this.get(this.idAttribute);\n            this.trigger('changeId', this, prevId, options);\n        }\n\n        // Trigger all relevant attribute changes.\n        if (!silent) {\n            if (changes.length) this._pending = options;\n            for (var i = 0; i < changes.length; i++) {\n                this.trigger('change:' + changes[i], this, current[changes[i]], options);\n            }\n        }\n\n        // You might be wondering why there's a `while` loop here. Changes can\n        // be recursively nested within `\"change\"` events.\n        if (changing) return this;\n        if (!silent) {\n            while (this._pending) {\n                options = this._pending;\n                this._pending = false;\n                this.trigger('change', this, options);\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n        return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n        return this.set(attr, void 0, assign({}, options, { unset: true }));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n        var attrs = {};\n        for (var key in this.attributes) attrs[key] = void 0;\n        return this.set(attrs, assign({}, options, { unset: true }));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n        if (attr == null) return !isEmpty(this.changed);\n        return has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n        if (!diff) return this.hasChanged() ? clone(this.changed) : false;\n        var old = this._changing ? this._previousAttributes : this.attributes;\n        var changed = {};\n        var hasChanged;\n        for (var attr in diff) {\n            var val = diff[attr];\n            if (isEqual(old[attr], val)) continue;\n            changed[attr] = val;\n            hasChanged = true;\n        }\n        return hasChanged ? changed : false;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n        if (attr == null || !this._previousAttributes) return null;\n        return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n        return clone(this._previousAttributes);\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n        return new this.constructor(this.attributes);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n        return this._validate({}, assign({}, options, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n        if (!options.validate || !this.validate) return true;\n        attrs = assign({}, this.attributes, attrs);\n        var error = this.validationError = this.validate(attrs, options) || null;\n        if (!error) return true;\n        this.trigger('invalid', this, error, assign(options, { validationError: error }));\n        return false;\n    }\n\n});\n\n// Set up inheritance for the model.\nModel.extend = extend;\n", "import { uniq, toArray, isEmpty } from './util.mjs';\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nexport function cloneCells(cells) {\n\n    cells = uniq(cells);\n\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = toArray(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n\n    toArray(cells).forEach(function(cell) {\n\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop('source/id', cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop('target/id', cloneMap[target.id].id);\n            }\n        }\n\n        // Find the parent of the original cell\n        const parent = cell.get('parent');\n        if (parent && cloneMap[parent]) {\n            clone.set('parent', cloneMap[parent].id);\n        }\n\n        // Find the embeds of the original cell\n        const embeds = toArray(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n\n        if (!isEmpty(embeds)) {\n            clone.set('embeds', embeds);\n        }\n    });\n\n    return cloneMap;\n}\n\n", "import { isPlainObject } from '../../util/util.mjs';\n\nconst validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];\n\nconst validProperties = validPropertiesList.reduce((acc, key) => {\n    acc[key] = true;\n    return acc;\n}, {});\n\nconst props = {\n    qualify: function(properties) {\n        return isPlainObject(properties);\n    },\n    set: function(properties, _, node) {\n        Object.keys(properties).forEach(function(key) {\n            if (validProperties[key] && key in node) {\n                const value = properties[key];\n                if (node.tagName === 'SELECT' && Array.isArray(value)) {\n                    Array.from(node.options).forEach(function(option, index) {\n                        option.selected = value.includes(option.value);\n                    });\n                } else {\n                    node[key] = value;\n                }\n            }\n        });\n    }\n};\n\nexport default props;\n", "import { Point } from '../../g/index.mjs';\nimport { isPercentage } from '../../util/util.mjs';\n\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n\n        var point = Point();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n\n        return attrs;\n    };\n}\n\nconst legacyAttributesNS = {\n\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n    'ref-x': {\n        position: positionWrapper('x', 'width', 'origin')\n    },\n\n    'ref-y': {\n        position: positionWrapper('y', 'height', 'origin')\n    },\n\n    // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom\n    // coordinate of the reference element.\n\n    'ref-dx': {\n        position: positionWrapper('x', 'width', 'corner')\n    },\n\n    'ref-dy': {\n        position: positionWrapper('y', 'height', 'corner')\n    },\n\n    // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n    'ref-width': {\n        set: setWrapper('width', 'width')\n    },\n\n    'ref-height': {\n        set: setWrapper('height', 'height')\n    },\n\n    'ref-rx': {\n        set: setWrapper('rx', 'width')\n    },\n\n    'ref-ry': {\n        set: setWrapper('ry', 'height')\n    },\n\n    'ref-cx': {\n        set: setWrapper('cx', 'width')\n    },\n\n    'ref-cy': {\n        set: setWrapper('cy', 'height')\n    },\n\n    'ref-r-inscribed': {\n        set: (function(attrName) {\n            var widthFn = setWrapper(attrName, 'width');\n            var heightFn = setWrapper(attrName, 'height');\n            return function(value, refBBox) {\n                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        })('r')\n    },\n\n    'ref-r-circumscribed': {\n        set: function(value, refBBox) {\n            var isValuePercentage = isPercentage(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n\n            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n\n            return { r: rValue };\n        }\n    },\n};\n\n// NOTE: refX & refY are SVG attributes that define the reference point of the marker.\n// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).\nlegacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];\nlegacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nlegacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];\nlegacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];\nlegacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];\nlegacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];\n\n// Aliases\nlegacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];\n\nexport default legacyAttributesNS;\n", "const props = {\n    x: 'x',\n    y: 'y',\n    width: 'w',\n    height: 'h',\n    minimum: 's',\n    maximum: 'l',\n    diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseFormulaRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\n\nfunction throwInvalid(expression) {\n    throw new Error(`Invalid calc() expression: ${expression}`);\n}\n\n/*\n* Evaluate the given calc formula.\n* e.g. 'w + 10' in a rect 100x100 -> 110\n*/\nexport function evalCalcFormula(formula, rect) {\n    const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ''));\n    if (!match) throwInvalid(formula);\n    parseFormulaRegExp.lastIndex = 0; // reset regex results for the next run\n    const [,multiply, property, divide, add] = match;\n    const { x, y, width, height } = rect;\n    let value = 0;\n    switch (property) {\n        case props.width: {\n            value = width;\n            break;\n        }\n        case props.height: {\n            value = height;\n            break;\n        }\n        case props.x: {\n            value = x;\n            break;\n        }\n        case props.y: {\n            value = y;\n            break;\n        }\n        case props.minimum: {\n            value = Math.min(height, width);\n            break;\n        }\n        case props.maximum: {\n            value = Math.max(height, width);\n            break;\n        }\n        case props.diagonal: {\n            value = Math.sqrt((height * height) + (width * width));\n            break;\n        }\n    }\n    if (multiply) {\n        // e.g \"2*\"\n        value *= parseFloat(multiply);\n    }\n    if (divide) {\n        // e.g \"/2\"\n        value /= parseFloat(divide.slice(1));\n    }\n    if (add) {\n        value += evalAddExpression(add);\n    }\n    return value;\n}\n\nfunction evalAddExpression(addExpression) {\n    if (!addExpression) return 0;\n    const [sign] = addExpression;\n    switch (sign) {\n        case '+': {\n            return parseFloat(addExpression.substr(1));\n        }\n        case '-': {\n            return -parseFloat(addExpression.substr(1));\n        }\n    }\n    return parseFloat(addExpression);\n}\n\n/*\n* Check if the given value is a calc expression.\n* e.g. 'calc(10 + 100)' -> true\n*/\nexport function isCalcExpression(value) {\n    return typeof value === 'string' && value.includes('calc');\n}\n\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\n\n/*\n* Evaluate all calc formulas in the given expression.\n* e.g. 'calc(w + 10)' in rect 100x100 -> '110'\n*/\nexport function evalCalcExpression(expression, rect) {\n    let value = expression;\n    let startSearchIndex = 0;\n    do {\n        let calcIndex = value.indexOf(calcStart, startSearchIndex);\n        if (calcIndex === -1) return value;\n        let calcEndIndex = calcIndex + calcStartOffset;\n        let brackets = 1;\n        findClosingBracket: do {\n            switch (value[calcEndIndex]) {\n                case '(': {\n                    brackets++;\n                    break;\n                }\n                case ')': {\n                    brackets--;\n                    if (brackets === 0) break findClosingBracket;\n                    break;\n                }\n                case undefined: {\n                    // Could not find the closing bracket.\n                    throwInvalid(value);\n                }\n            }\n            calcEndIndex++;\n        } while (true);\n        // Get the calc() expression without nested calcs (recursion)\n        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n        if (isCalcExpression(expression)) {\n            expression = evalCalcExpression(expression, rect);\n        }\n        // Eval the calc() expression without nested calcs.\n        const calcValue = String(evalCalcFormula(expression, rect));\n        // Replace the calc() expression and continue search\n        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n        startSearchIndex = calcIndex + calcValue.length;\n    } while (true);\n}\n", "import { assign, isPlainObject, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcExpression, evalCalcExpression } from '../../util/calc.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\n\nconst textAttributesNS = {\n\n    'line-height': {\n        qualify: isTextInUse\n    },\n\n    'text-vertical-anchor': {\n        qualify: isTextInUse\n    },\n\n    'text-path': {\n        qualify: isTextInUse\n    },\n\n    'annotations': {\n        qualify: isTextInUse\n    },\n\n    'eol': {\n        qualify: isTextInUse\n    },\n\n    'display-empty': {\n        qualify: isTextInUse\n    },\n\n    'text': {\n        qualify: function(_text, _node, attrs) {\n            const textWrap = attrs['text-wrap'];\n            return !textWrap || !isPlainObject(textWrap);\n        },\n        unset: function(node) {\n            node.textContent = '';\n        },\n        set: function(text, refBBox, node, attrs) {\n            const cacheName = 'joint-text';\n            const cache = $.data.get(node, cacheName);\n            const lineHeight = attrs['line-height'];\n            const textVerticalAnchor = attrs['text-vertical-anchor'];\n            const displayEmpty = attrs['display-empty'];\n            const fontSize = attrs['font-size'];\n            const annotations = attrs.annotations;\n            const eol = attrs.eol;\n            const x = attrs.x;\n            let textPath = attrs['text-path'];\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // <tspan> positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                if (isObject(textPath)) {\n                    const pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        const pathNode = this.findNode(pathSelector);\n                        if (pathNode instanceof SVGPathElement) {\n                            textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                V(node).text('' + text, {\n                    lineHeight,\n                    annotations,\n                    textPath,\n                    x,\n                    textVerticalAnchor,\n                    eol,\n                    displayEmpty\n                });\n                $.data.set(node, cacheName, textHash);\n            }\n        }\n    },\n\n    'text-wrap': {\n        qualify: isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if (isPercentage(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if (isCalcExpression(width)) {\n                size.width = Number(evalCalcExpression(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if (isPercentage(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if (isCalcExpression(height)) {\n                size.height = Number(evalCalcExpression(height, refBBox));\n            } else {\n                if (value.height === null) {\n                    // if height is not specified breakText() does not\n                    // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n\n                const breakTextFn = value.breakText || breakText;\n                const computedStyles = getComputedStyle(node);\n                const wrapFontAttributes = {};\n                // The font size attributes must be set on the node\n                // to get the correct text wrapping.\n                // TODO: set the native SVG attributes before special attributes\n                for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n                    const name = FONT_ATTRIBUTES[i];\n                    if (name in attrs) {\n                        node.setAttribute(name, attrs[name]);\n                    }\n                    // Note: computedStyles is a live object\n                    // i.e. the properties are evaluated when accessed.\n                    wrapFontAttributes[name] = computedStyles[name];\n                }\n\n                // The `line-height` attribute in SVG is JoinJS specific.\n                // TODO: change the `lineHeight` to breakText option.\n                wrapFontAttributes.lineHeight = attrs['line-height'];\n\n                wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    separator: value.separator,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = '';\n            }\n            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        },\n        // We expose the font attributes list to allow\n        // the user to take other custom font attributes into account\n        // when wrapping the text.\n        FONT_ATTRIBUTES\n    },\n\n    'title': {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        unset: function(node) {\n            $.data.remove(node, 'joint-title');\n            const titleNode = node.firstElementChild;\n            if (titleNode) {\n                titleNode.remove();\n            }\n        },\n        set: function(title, refBBox, node) {\n            var cacheName = 'joint-title';\n            var cache = $.data.get(node, cacheName);\n            if (cache === undefined || cache !== title) {\n                $.data.set(node, cacheName, title);\n                if (node.tagName === 'title') {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === 'title') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n};\n\nexport default textAttributesNS;\n", "import { Point } from '../../g/index.mjs';\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nconst connectionAttributesNS = {\n\n    'connection': {\n        qualify: isLinkView,\n        unset: 'd',\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const segmentSubdivisions = this.getConnectionSubdivisions();\n                const sourceParts = path.divideAtLength(offset, { segmentSubdivisions });\n                const targetParts = path.divideAtLength(-offset, { segmentSubdivisions });\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    'at-connection-length-keep-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    'at-connection-length-ignore-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    'at-connection-ratio-keep-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    'at-connection-ratio-ignore-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n\n};\n\nconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\nconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\n\nexport default connectionAttributesNS;\n", "import { Path, Polyline } from '../../g/index.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\n\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = 'joint-shape';\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var cache = $.data.get(node, cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            $.data.set(node, cacheName, cache);\n        }\n\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n\n        return shape;\n    };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new Path(V.normalizePathData(value));\n    }\n\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\n\nconst shapeAttributesNS = {\n\n    'ref-d-reset-offset': {\n        unset: 'd',\n        set: dWrapper({ resetOffset: true })\n    },\n\n    'ref-d-keep-offset': {\n        unset: 'd',\n        set: dWrapper({ resetOffset: false })\n    },\n\n    'ref-points-reset-offset': {\n        unset: 'points',\n        set: pointsWrapper({ resetOffset: true })\n    },\n\n    'ref-points-keep-offset': {\n        unset: 'points',\n        set: pointsWrapper({ resetOffset: false })\n    },\n};\n\n// Aliases\nshapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];\nshapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];\n\nexport default shapeAttributesNS;\n", "import { assign, isPlainObject } from '../../util/util.mjs';\n\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregarded here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === 'string') {\n        marker['stroke'] = stroke;\n        marker['fill'] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context['stroke-opacity'];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker['stroke-opacity'] = strokeOpacity;\n        marker['fill-opacity'] = strokeOpacity;\n    }\n    return marker;\n}\n\nfunction setPaintURL(def) {\n    const { paper } = this;\n    const url = (def.type === 'pattern')\n        ? paper.definePattern(def)\n        : paper.defineGradient(def);\n    return `url(#${url})`;\n}\n\nconst defsAttributesNS = {\n\n    'source-marker': {\n        qualify: isPlainObject,\n        unset: 'marker-start',\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'target-marker': {\n        qualify: isPlainObject,\n        unset: 'marker-end',\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'vertex-marker': {\n        qualify: isPlainObject,\n        unset: 'marker-mid',\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'fill': {\n        qualify: isPlainObject,\n        set: setPaintURL\n    },\n\n    'stroke': {\n        qualify: isPlainObject,\n        set: setPaintURL\n    },\n\n    'filter': {\n        qualify: isPlainObject,\n        set: function(filter) {\n            return 'url(#' + this.paper.defineFilter(filter) + ')';\n        }\n    },\n};\n\nexport default defsAttributesNS;\n", "\n// Offset attributes require the cell view to be rendered before they can be applied\n// (they must be appended to the DOM).\n\nimport { Point } from '../../g/index.mjs';\nimport { isPercentage } from '../../util/util.mjs';\n\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === 'middle') {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n        } else if (isPercentage(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n\n        var point = new Point();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\n\nconst offsetAttributesNS = {\n\n    // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n    'x-alignment': {\n        offset: offsetWrapper('x', 'width', 'right')\n    },\n\n    // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n    'y-alignment': {\n        offset: offsetWrapper('y', 'height', 'bottom')\n    },\n\n    'reset-offset': {\n        offset: function(val, nodeBBox) {\n            return (val)\n                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n                : { x: 0, y: 0 };\n        }\n    },\n};\n\nexport default offsetAttributesNS;\n", "import { assign, isPlainObject } from '../../util/util.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\n\nimport props from './props.mjs';\nimport legacyAttributesNS from './legacy.mjs';\nimport textAttributesNS from './text.mjs';\nimport connectionAttributesNS from './connection.mjs';\nimport shapeAttributesNS from './shape.mjs';\nimport defsAttributesNS from './defs.mjs';\nimport offsetAttributesNS from './offset.mjs';\n\nfunction setIfChangedWrapper(attribute) {\n    return function setIfChanged(value, _, node) {\n        const vel = V(node);\n        if (vel.attr(attribute) === value) return;\n        vel.attr(attribute, value);\n    };\n}\n\nconst attributesNS = {\n\n    'ref': {\n        // We do not set `ref` attribute directly on an element.\n        // The attribute itself does not qualify for relative positioning.\n    },\n\n    'href': {\n        set: setIfChangedWrapper('href')\n    },\n\n    'xlink:href': {\n        set: setIfChangedWrapper('xlink:href')\n    },\n\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    'port': {\n        set: function(port) {\n            return (port === null || port.id === undefined) ? port : port.id;\n        }\n    },\n\n    // `style` attribute is special in the sense that it sets the CSS style of the sub-element.\n    'style': {\n        qualify: isPlainObject,\n        set: function(styles, refBBox, node) {\n            $(node).css(styles);\n        }\n    },\n\n    'html': {\n        unset: function(node) {\n            $(node).empty();\n        },\n        set: function(html, refBBox, node) {\n            $(node).html(html + '');\n        }\n    },\n\n    // Properties setter (set various properties on the node)\n    props,\n};\n\nassign(attributesNS, legacyAttributesNS);\nassign(attributesNS, textAttributesNS);\nassign(attributesNS, connectionAttributesNS);\nassign(attributesNS, shapeAttributesNS);\nassign(attributesNS, defsAttributesNS);\nassign(attributesNS, offsetAttributesNS);\n\nexport const attributes = attributesNS;\n\n", "import {\n    uniqueId,\n    union,\n    result,\n    merge,\n    forIn,\n    isObject,\n    isEqual,\n    isString,\n    cloneDeep,\n    omit,\n    uuid,\n    isEmpty,\n    assign,\n    uniq,\n    toArray,\n    setByPath,\n    unsetByPath,\n    getByPath,\n    timing,\n    interpolate,\n    nextFrame,\n    without,\n    cancelFrame,\n    defaultsDeep,\n    has,\n    sortBy,\n    defaults,\n    objectDifference\n} from '../util/util.mjs';\nimport { Model } from '../mvc/Model.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes/index.mjs';\nimport * as g from '../g/index.mjs';\n\n\n// Cell base model.\n// --------------------------\n\nconst attributesMerger = function(a, b) {\n    if (Array.isArray(a)) {\n        return b;\n    }\n};\n\nfunction removeEmptyAttributes(obj) {\n\n    // Remove toplevel empty attributes\n    for (const key in obj) {\n\n        const objValue = obj[key];\n        const isRealObject = isObject(objValue) && !Array.isArray(objValue);\n\n        if (!isRealObject) continue;\n\n        if (isEmpty(objValue)) {\n            delete obj[key];\n        }\n    }\n}\n\nexport const Cell = Model.extend({\n\n    // This is the same as mvc.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n\n        var defaults;\n        var attrs = attributes || {};\n        if (typeof this.preinitialize === 'function') {\n            // Check to support an older version\n            this.preinitialize.apply(this, arguments);\n        }\n        this.cid = uniqueId('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if ((defaults = result(this, 'defaults'))) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            const customizer = (options && options.mergeArrays === true) ? false : attributesMerger;\n            attrs = merge({}, defaults, attrs, customizer);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        throw new Error('Must define a translate() method.');\n    },\n\n    toJSON: function(opt) {\n\n        const { ignoreDefaults, ignoreEmptyAttributes = false } = opt || {};\n        const defaults = result(this.constructor.prototype, 'defaults');\n\n        if (ignoreDefaults === false) {\n            // Return all attributes without omitting the defaults\n            const finalAttributes = cloneDeep(this.attributes);\n\n            if (!ignoreEmptyAttributes) return finalAttributes;\n\n            removeEmptyAttributes(finalAttributes);\n\n            return finalAttributes;\n        }\n\n        let defaultAttributes = {};\n        let attributes = cloneDeep(this.attributes);\n\n        if (ignoreDefaults === true) {\n            // Compare all attributes with the defaults\n            defaultAttributes = defaults;\n        } else {\n            // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified\n            const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ['attrs'];\n\n            differentiateKeys.forEach((key) => {\n                defaultAttributes[key] = defaults[key] || {};\n            });\n        }\n\n        // Omit `id` and `type` attribute from the defaults since it should be always present\n        const finalAttributes = objectDifference(attributes, omit(defaultAttributes, 'id', 'type'), { maxDepth: 4 });\n\n        if (ignoreEmptyAttributes) {\n            removeEmptyAttributes(finalAttributes);\n        }\n\n        return finalAttributes;\n    },\n\n    initialize: function(options) {\n\n        const idAttribute = this.getIdAttribute();\n        if (!options || options[idAttribute] === undefined) {\n            this.set(idAttribute, this.generateId(), { silent: true });\n        }\n\n        this._transitionIds = {};\n        this._scheduledTransitionIds = {};\n\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on('change:attrs', this.processPorts, this);\n    },\n\n    getIdAttribute: function() {\n        return this.idAttribute || 'id';\n    },\n\n    generateId: function() {\n        return uuid();\n    },\n\n    /**\n     * @deprecated\n     */\n    processPorts: function() {\n\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n\n        var previousPorts = this.ports;\n\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        forIn(this.get('attrs'), function(attrs, selector) {\n\n            if (attrs && attrs.port) {\n\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = { id: attrs.port };\n                }\n            }\n        });\n\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        forIn(previousPorts, function(port, id) {\n\n            if (!ports[id]) removedPorts[id] = true;\n        });\n\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !isEmpty(removedPorts)) {\n\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('source').port]) link.remove();\n            });\n        }\n\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n\n    remove: function(opt = {}) {\n\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common mvc collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n\n        graph.startBatch('remove');\n\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for (let i = 0, n = embeddedCells.length; i < n; i++) {\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n\n        this.trigger('remove', this, graph.attributes.cells, opt);\n\n        graph.stopBatch('remove');\n\n        return this;\n    },\n\n    toFront: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = defaults(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\n            const maxZ = graph.maxZIndex();\n            let z = maxZ - cells.length + 1;\n\n            const collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== (collection.length - cells.length));\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-front');\n\n                z = z + cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-front');\n            }\n        }\n\n        return this;\n    },\n\n    toBack: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = defaults(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\n            let z = graph.minZIndex();\n\n            var collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== 0);\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-back');\n\n                z -= cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-back');\n            }\n        }\n\n        return this;\n    },\n\n    parent: function(parent, opt) {\n\n        // getter\n        if (parent === undefined) return this.get('parent');\n        // setter\n        return this.set('parent', parent, opt);\n    },\n\n    embed: function(cell, opt = {}) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        if (!this.canEmbed(cells)) {\n            throw new Error('Recursive embedding not allowed.');\n        }\n        if (opt.reparent) {\n            const parents = uniq(cells.map(c => c.getParentCell()));\n\n            // Unembed cells from their current parents.\n            parents.forEach((parent) => {\n                // Cell doesn't have to be embedded.\n                if (!parent) return;\n\n                // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases\n                // where not all elements of `cells` are embedded in the same parent.\n                parent._unembedCells(cells, opt);\n            });\n\n        } else if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n            throw new Error('Embedding of already embedded cells is not allowed.');\n        }\n        this._embedCells(cells, opt);\n        return this;\n    },\n\n    unembed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        this._unembedCells(cells, opt);\n        return this;\n    },\n\n    canEmbed: function(cell) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n    },\n\n    _embedCells: function(cells, opt) {\n        const batchName = 'embed';\n        this.startBatch(batchName);\n        const embeds = assign([], this.get('embeds'));\n        cells.forEach(cell => {\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n            cell.parent(this.id, opt);\n        });\n        this.set('embeds', uniq(embeds), opt);\n        this.stopBatch(batchName);\n    },\n\n    _unembedCells: function(cells, opt) {\n        const batchName = 'unembed';\n        this.startBatch(batchName);\n        cells.forEach(cell => cell.unset('parent', opt));\n        this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n        this.stopBatch(batchName);\n    },\n\n    getParentCell: function() {\n\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n\n        return (parentId && graph && graph.getCell(parentId)) || null;\n    },\n\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n\n        var ancestors = [];\n\n        if (!this.graph) {\n            return ancestors;\n        }\n\n        var parentCell = this.getParentCell();\n        while (parentCell) {\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n\n        return ancestors;\n    },\n\n    getEmbeddedCells: function(opt) {\n\n        opt = opt || {};\n\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (!this.graph) {\n            return [];\n        }\n\n        if (opt.deep) {\n            if (opt.breadthFirst) {\n                return this._getEmbeddedCellsBfs(opt.sortSiblings);\n            } else {\n                return this._getEmbeddedCellsDfs(opt.sortSiblings);\n            }\n        }\n\n        const embeddedIds = this.get('embeds');\n        if (isEmpty(embeddedIds)) {\n            return [];\n        }\n\n        let cells = embeddedIds.map(this.graph.getCell, this.graph);\n        if (opt.sortSiblings) {\n            cells = sortBy(cells, cell => cell.z());\n        }\n\n        return cells;\n    },\n\n    _getEmbeddedCellsBfs: function(sortSiblings) {\n        const cells = [];\n\n        const queue = [];\n        queue.push(this);\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            queue.push(...embeddedCells);\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    _getEmbeddedCellsDfs: function(sortSiblings) {\n        const cells = [];\n\n        const stack = [];\n        stack.push(this);\n\n        while (stack.length > 0) {\n            const current = stack.pop();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            // When using the stack, cells that are embedded last are processed first.\n            // To maintain the original order, we need to push the cells in reverse order\n            for (let i = embeddedCells.length - 1; i >= 0; --i) {\n                stack.push(embeddedCells[i]);\n            }\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    isEmbeddedIn: function(cell, opt) {\n\n        var cellId = isString(cell) ? cell : cell.id;\n        var parentId = this.parent();\n\n        opt = assign({ deep: true }, opt);\n\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n\n            while (parentId) {\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n\n            return false;\n\n        } else {\n\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n\n        return !!this.parent();\n    },\n\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n\n        opt = opt || {};\n\n        if (!opt.deep) {\n            // Shallow cloning.\n\n            var clone = Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set(this.getIdAttribute(), this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset('embeds');\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset('parent');\n\n            return clone;\n\n        } else {\n            // Deep cloning.\n\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return toArray(cloneCells([this].concat(this.getEmbeddedCells({ deep: true }))));\n        }\n    },\n\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n\n        var delim = '/';\n        var _isString = isString(props);\n\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (arguments.length > 1) {\n\n                var path;\n                var pathArray;\n\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split('/');\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n\n                const options = opt || {};\n                options.propertyPath = path;\n                options.propertyValue = value;\n                options.propertyPathArray = pathArray;\n                if (!('rewrite' in options)) {\n                    options.rewrite = false;\n                }\n\n                var update = {};\n                // Initialize the nested object. Sub-objects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n\n                for (var i = 1; i < pathArrayLength; i++) {\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n\n                // Fill update with the `value` on `path`.\n                update = setByPath(update, pathArray, value, '/');\n\n                var baseAttributes = merge({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                options.rewrite && unsetByPath(baseAttributes, path, '/');\n\n                // Merge update with the model attributes.\n                var attributes = merge(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], options);\n\n            } else {\n\n                return getByPath(this.attributes, props, delim);\n            }\n        }\n\n        const options = value || {};\n        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n        options.propertyPath = null;\n        options.propertyValue = props;\n        options.propertyPathArray = [];\n        if (!('rewrite' in options)) {\n            options.rewrite = false;\n        }\n\n        // Create a new object containing only the changed attributes.\n        const changedAttributes = {};\n        for (const key in props) {\n            // Merging the values of changed attributes with the current ones.\n            const { changedValue } = merge({}, { changedValue: this.attributes[key] }, { changedValue: props[key] });\n            changedAttributes[key] = changedValue;\n        }\n\n        return this.set(changedAttributes, options);\n    },\n\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n\n        opt = opt || {};\n\n        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === 'attrs') opt.dirty = true;\n\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = this.get(property);\n        if (propertyValue === undefined || propertyValue === null) return this;\n        propertyValue = cloneDeep(propertyValue);\n\n        unsetByPath(propertyValue, nestedPath, '/');\n\n        return this.set(property, propertyValue, opt);\n    },\n\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get('attrs');\n        }\n\n        if (Array.isArray(attrs)) {\n            args[0] = ['attrs'].concat(attrs);\n        } else if (isString(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = 'attrs/' + attrs;\n\n        } else {\n\n            args[0] = { 'attrs' : attrs };\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n\n        if (Array.isArray(path)) {\n\n            return this.removeProp(['attrs'].concat(path));\n        }\n\n        return this.removeProp('attrs/' + path, opt);\n    },\n\n    transition: function(path, value, opt, delim) {\n\n        delim = delim || '/';\n\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: timing.linear,\n            valueFunction: interpolate.number\n        };\n\n        opt = assign(defaults, opt);\n\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n\n        var setter = function(runtime) {\n\n            var id, progress, propertyValue;\n\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n\n            if (progress < 1) {\n                this._transitionIds[path] = id = nextFrame(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n            opt.transitionId = id;\n\n            this.prop(path, propertyValue, opt);\n\n            if (!id) this.trigger('transition:end', this, path);\n\n        }.bind(this);\n\n        const { _scheduledTransitionIds } = this;\n        let initialId;\n\n        var initiator = (callback) => {\n\n            if (_scheduledTransitionIds[path]) {\n                _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n                if (_scheduledTransitionIds[path].length === 0) {\n                    delete _scheduledTransitionIds[path];\n                }\n            }\n\n            this.stopPendingTransitions(path, delim);\n\n            interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\n            this._transitionIds[path] = nextFrame(callback);\n\n            this.trigger('transition:start', this, path);\n\n        };\n\n        initialId = setTimeout(initiator, opt.delay, setter);\n\n        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n        _scheduledTransitionIds[path].push(initialId);\n\n        return initialId;\n    },\n\n    getTransitions: function() {\n        return union(\n            Object.keys(this._transitionIds),\n            Object.keys(this._scheduledTransitionIds)\n        );\n    },\n\n    stopScheduledTransitions: function(path, delim = '/') {\n        const { _scheduledTransitionIds = {}} = this;\n        let transitions = Object.keys(_scheduledTransitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionIds = _scheduledTransitionIds[key];\n            // stop the initiator\n            transitionIds.forEach(transitionId => clearTimeout(transitionId));\n            delete _scheduledTransitionIds[key];\n            // Note: we could trigger transition:cancel` event here\n        });\n        return this;\n    },\n\n    stopPendingTransitions(path, delim = '/') {\n        const { _transitionIds = {}} = this;\n        let transitions = Object.keys(_transitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionId = _transitionIds[key];\n            // stop the setter\n            cancelFrame(transitionId);\n            delete _transitionIds[key];\n            this.trigger('transition:end', this, key);\n        });\n    },\n\n    stopTransitions: function(path, delim = '/') {\n        this.stopScheduledTransitions(path, delim);\n        this.stopPendingTransitions(path, delim);\n        return this;\n    },\n\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n    addTo: function(graph, opt) {\n\n        graph.addCell(this, opt);\n        return this;\n    },\n\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n\n        return paper.findViewByModel(this);\n    },\n\n    isElement: function() {\n\n        return false;\n    },\n\n    isLink: function() {\n\n        return false;\n    },\n\n    startBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.startBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    stopBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.stopBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    getChangeFlag: function(attributes) {\n\n        var flag = 0;\n        if (!attributes) return flag;\n        for (var key in attributes) {\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n\n    angle: function() {\n\n        // To be overridden.\n        return 0;\n    },\n\n    position: function() {\n\n        // To be overridden.\n        return new g.Point(0, 0);\n    },\n\n    z: function() {\n        return this.get('z') || 0;\n    },\n\n    getPointFromConnectedLink: function() {\n\n        // To be overridden\n        return new g.Point();\n    },\n\n    getBBox: function() {\n\n        // To be overridden\n        return new g.Rect(0, 0, 0, 0);\n    },\n\n    getPointRotatedAroundCenter(angle, x, y) {\n        const point = new g.Point(x, y);\n        if (angle) point.rotate(this.getBBox().center(), angle);\n        return point;\n    },\n\n    getAbsolutePointFromRelative(x, y) {\n        // Rotate the position to take the model angle into account\n        return this.getPointRotatedAroundCenter(\n            -this.angle(),\n            // Transform the relative position to absolute\n            this.position().offset(x, y)\n        );\n    },\n\n    getRelativePointFromAbsolute(x, y) {\n        return this\n            // Rotate the coordinates to mitigate the element's rotation.\n            .getPointRotatedAroundCenter(this.angle(), x, y)\n            // Transform the absolute position into relative\n            .difference(this.position());\n    }\n\n}, {\n\n    getAttributeDefinition: function(attrName) {\n\n        var defNS = this.attributes;\n        var globalDefNS = attributes;\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n    },\n\n    define: function(type, defaults, protoProps, staticProps) {\n\n        protoProps = assign({\n            defaults: defaultsDeep({ type: type }, defaults, this.prototype.defaults)\n        }, protoProps);\n\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* eslint-disable no-undef */\n        if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            setByPath(joint.shapes, type, Cell, '.');\n        }\n        /* eslint-enable no-undef */\n        return Cell;\n    }\n});\n\n", "export * from './wrappers.mjs';\nexport * from './util.mjs';\nexport * from './cloneCells.mjs';\nexport * from './svgTagTemplate.mjs';\nexport * from './calc.mjs';\nexport { getRectPoint } from './getRectPoint.mjs';\n", "import { Cell } from '../dia/Cell.mjs';\nimport { isFunction, isString, toArray } from './util.mjs';\n\nexport const wrapWith = function(object, methods, wrapper) {\n\n    if (isString(wrapper)) {\n\n        if (!wrappers[wrapper]) {\n            throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n        }\n\n        wrapper = wrappers[wrapper];\n    }\n\n    if (!isFunction(wrapper)) {\n        throw new Error('Wrapper must be a function.');\n    }\n\n    toArray(methods).forEach(function(method) {\n        object[method] = wrapper(object[method]);\n    });\n};\n\nexport const wrappers = {\n\n    cells: function(fn) {\n\n        return function() {\n\n            var args = Array.from(arguments);\n            var n = args.length;\n            var cells = n > 0 && args[0] || [];\n            var opt = n > 1 && args[n - 1] || {};\n\n            if (!Array.isArray(cells)) {\n\n                if (opt instanceof Cell) {\n                    cells = args;\n                } else if (cells instanceof Cell) {\n                    if (args.length > 1) {\n                        args.pop();\n                    }\n                    cells = args;\n                }\n            }\n\n            if (opt instanceof Cell) {\n                opt = {};\n            }\n\n            return fn.call(this, cells, opt);\n        };\n    }\n\n};\n\n", "import V from '../V/index.mjs';\n\nexport function svg(strings, ...expressions) {\n    const svgParts = [];\n    strings.forEach((part, index) => {\n        svgParts.push(part);\n        if (index in expressions) {\n            svgParts.push(expressions[index]);\n        }\n    });\n    const markup = parseFromSVGString(svgParts.join(''));\n    return markup;\n}\n\nfunction parseFromSVGString(str) {\n    const parser = new DOMParser();\n    const markupString = `<svg>${str.trim()}</svg>`;\n    const xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');\n    if (xmldocument.getElementsByTagName('parsererror')[0]) {\n        throw new Error('Invalid SVG markup');\n    }\n    const document = parser.parseFromString(markupString, 'text/html');\n    const svg = document.querySelector('svg');\n    return build(svg);\n}\n\nfunction buildNode(node) {\n    const markupNode = {};\n    const { tagName, attributes, namespaceURI, style, childNodes } = node;\n\n    markupNode.namespaceURI = namespaceURI;\n    markupNode.tagName = (namespaceURI === V.namespace.xhtml)\n        // XHTML documents must use lower case for all HTML element and attribute names.\n        // The tagName property returns upper case value for HTML elements.\n        // e.g. <DIV> vs.<div/>\n        ? tagName.toLowerCase()\n        : tagName;\n\n    const stylesObject = {};\n    for (var i = style.length; i--;) {\n        var nameString = style[i];\n        stylesObject[nameString] = style.getPropertyValue(nameString);\n    }\n    markupNode.style = stylesObject;\n\n    // selector fallbacks to tagName\n    const selectorAttribute = attributes.getNamedItem('@selector');\n    if (selectorAttribute) {\n        markupNode.selector = selectorAttribute.value;\n        attributes.removeNamedItem('@selector');\n    }\n\n    const groupSelectorAttribute = attributes.getNamedItem('@group-selector');\n    if (groupSelectorAttribute) {\n        const groupSelectors = groupSelectorAttribute.value.split(',');\n        markupNode.groupSelector = groupSelectors.map(s => s.trim());\n\n        attributes.removeNamedItem('@group-selector');\n    }\n\n    const className = attributes.getNamedItem('class');\n    if (className) {\n        markupNode.className = className.value;\n    }\n\n    const children = [];\n    childNodes.forEach(node => {\n        switch (node.nodeType) {\n            case Node.TEXT_NODE: {\n                const trimmedText = node.data.replace(/\\s\\s+/g, ' ');\n                if (trimmedText.trim()) {\n                    children.push(trimmedText);\n                }\n                break;\n            }\n            case Node.ELEMENT_NODE: {\n                children.push(buildNode(node));\n                break;\n            }\n            default:\n                break;\n        }\n    });\n    if (children.length) {\n        markupNode.children = children;\n    }\n\n    const nodeAttrs = {};\n\n    Array.from(attributes).forEach(nodeAttribute => {\n        const { name, value } = nodeAttribute;\n        nodeAttrs[name] = value;\n    });\n\n    if (Object.keys(nodeAttrs).length > 0) {\n        markupNode.attributes = nodeAttrs;\n    }\n\n    return markupNode;\n}\n\nfunction build(root) {\n    const markup = [];\n\n    Array.from(root.children).forEach(node => {\n        markup.push(buildNode(node));\n    });\n\n    return markup;\n}\n", "import * as g from '../g/index.mjs';\n\nexport const Positions = {\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right',\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    CENTER: 'center',\n};\n\nexport function getRectPoint(rect, position) {\n    const r = new g.Rect(rect);\n    switch (position) {\n        case undefined:\n            throw new Error('Position required');\n\n        // Middle Points\n        case Positions.LEFT:\n        case 'leftMiddle':\n            return r.leftMiddle();\n\n        case Positions.RIGHT:\n        case 'rightMiddle':\n            return r.rightMiddle();\n\n        case Positions.TOP:\n        case 'topMiddle':\n            return r.topMiddle();\n\n        case Positions.BOTTOM:\n        case 'bottomMiddle':\n            return r.bottomMiddle();\n\n        // Corners\n        case Positions.TOP_LEFT:\n        case 'topLeft':\n        case 'origin':\n            return r.topLeft();\n\n        case Positions.TOP_RIGHT:\n        case 'topRight':\n            return r.topRight();\n\n        case Positions.BOTTOM_LEFT:\n        case 'bottomLeft':\n            return r.bottomLeft();\n\n        case Positions.BOTTOM_RIGHT:\n        case 'bottomRight':\n        case 'corner':\n            return r.bottomRight();\n\n        // Center\n        case Positions.CENTER:\n            return r.center();\n\n        // TODO: calc(), percentage etc.\n        default:\n            throw new Error(`Unknown position: ${position}`);\n    }\n}\n", "import * as g from '../../g/index.mjs';\nimport * as util from '../../util/index.mjs';\n\nfunction portTransformAttrs(point, angle, opt) {\n\n    var trans = point.toJSON();\n\n    trans.angle = angle || 0;\n\n    return util.defaults({}, opt, trans);\n}\n\nfunction lineLayout(ports, p1, p2, elBBox) {\n    return ports.map(function(port, index, ports) {\n        var p = this.pointAt(((index + 0.5) / ports.length));\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p.offset(port.dx || 0, port.dy || 0);\n        }\n        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n    }, g.line(p1, p2));\n}\n\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n    var center = elBBox.center();\n    var ratio = elBBox.width / elBBox.height;\n    var p1 = elBBox.topMiddle();\n\n    var ellipse = g.Ellipse.fromRect(elBBox);\n\n    return ports.map(function(port, index, ports) {\n\n        var angle = startAngle + stepFn(index, ports.length);\n        var p2 = p1.clone()\n            .rotate(center, -angle)\n            .scale(ratio, 1, center);\n\n        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p2.offset(port.dx || 0, port.dy || 0);\n        }\n\n        // `dr` delta radius option\n        if (port.dr) {\n            p2.move(center, port.dr);\n        }\n\n        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n    });\n}\n\n\nfunction argTransform(bbox, args) {\n    let { x, y, angle } = args;\n    if (util.isPercentage(x)) {\n        x = parseFloat(x) / 100 * bbox.width;\n    } else if (util.isCalcExpression(x)) {\n        x = Number(util.evalCalcExpression(x, bbox));\n    }\n    if (util.isPercentage(y)) {\n        y = parseFloat(y) / 100 * bbox.height;\n    } else if (util.isCalcExpression(y)) {\n        y = Number(util.evalCalcExpression(y, bbox));\n    }\n    return { x, y, angle };\n}\n\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n    const { x, y } = argTransform(bbox, args);\n    return new g.Point(x || 0, y || 0);\n}\n\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const absolute = function(ports, elBBox) {\n    return ports.map(port => {\n        const transformation = argPoint(elBBox, port).round().toJSON();\n        transformation.angle = port.angle || 0;\n        return transformation;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const fn = function(ports, elBBox, opt) {\n    return opt.fn(ports, elBBox, opt);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const line = function(ports, elBBox, opt) {\n\n    var start = argPoint(elBBox, opt.start || elBBox.origin());\n    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n    return lineLayout(ports, start, end, elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const left = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const right = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const top = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const bottom = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipseSpread = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 360 / ports.length;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n        return index * stepAngle;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipse = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 20;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n        return (index + 0.5 - count / 2) * stepAngle;\n    });\n};\n\n", "import * as g from '../../g/index.mjs';\nimport * as util from '../../util/index.mjs';\n\nfunction labelAttributes(opt1, opt2) {\n\n    // use value from `opt2` if it is missing in `opt1`\n    // use value from this object if it is missing in `opt2` as well\n    return util.defaultsDeep({}, opt1, opt2, {\n        x: 0,\n        y: 0,\n        angle: 0,\n        attrs: {}\n    });\n}\n\nfunction getBBoxAngles(elBBox) {\n\n    var center = elBBox.center();\n\n    var tl = center.theta(elBBox.origin());\n    var bl = center.theta(elBBox.bottomLeft());\n    var br = center.theta(elBBox.corner());\n    var tr = center.theta(elBBox.topRight());\n\n    return [tl, tr, br, bl];\n}\n\nfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = util.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = util.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\n    opt = util.defaults({}, opt, { offset: 20 });\n\n    var origin = g.point(0, 0);\n    var angle = -portCenterOffset.theta(origin);\n    var orientAngle = angle;\n    var offset = portCenterOffset.clone()\n        .move(origin, opt.offset)\n        .difference(portCenterOffset)\n        .round();\n\n    var y = '.3em';\n    var textAnchor;\n\n    if ((angle + 90) % 180 === 0) {\n        textAnchor = autoOrient ? 'end' : 'middle';\n        if (!autoOrient && angle === -270) {\n            y = '0em';\n        }\n    } else if (angle > -270 && angle < -90) {\n        textAnchor = 'start';\n        orientAngle = angle - 180;\n    } else {\n        textAnchor = 'end';\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(offset.x),\n        y: round(offset.y),\n        angle: ((autoOrient) ? orientAngle : 0),\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nexport const manual = function(_portPosition, _elBBox, opt) {\n    return labelAttributes(opt);\n};\n\nexport const left = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: -15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'end' }},\n    });\n};\n\nexport const right = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: 15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'start' }},\n    });\n};\n\nexport const top = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: -15,\n        attrs: { labelText: { y: '0', textAnchor: 'middle' }},\n    });\n};\n\nexport const bottom = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: 15,\n        attrs: { labelText: { y: '.6em', textAnchor: 'middle' }},\n    });\n};\n\nexport const outsideOriented = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, true, opt);\n};\n\nexport const outside = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, false, opt);\n};\n\nexport const insideOriented = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, true, opt);\n};\n\nexport const inside = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, false, opt);\n};\n\nexport const radial = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n};\n\nexport const radialOriented = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n};\n", "import * as util from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { Rect, Point } from '../g/index.mjs';\nimport * as Port from '../layout/ports/port.mjs';\nimport * as PortLabel from '../layout/ports/portLabel.mjs';\n\nvar PortData = function(data) {\n\n    var clonedData = util.cloneDeep(data) || {};\n    this.ports = [];\n    this.groups = {};\n    this.portLayoutNamespace = Port;\n    this.portLabelLayoutNamespace = PortLabel;\n\n    this._init(clonedData);\n};\n\nPortData.prototype = {\n\n    getPorts: function() {\n        return this.ports;\n    },\n\n    getGroup: function(name) {\n        return this.groups[name] || {};\n    },\n\n    getPortsByGroup: function(groupName) {\n\n        return this.ports.filter(function(port) {\n            return port.group === groupName;\n        });\n    },\n\n    getGroupPortsMetrics: function(groupName, elBBox) {\n\n        var group = this.getGroup(groupName);\n        var ports = this.getPortsByGroup(groupName);\n\n        var groupPosition = group.position || {};\n        var groupPositionName = groupPosition.name;\n        var namespace = this.portLayoutNamespace;\n        if (!namespace[groupPositionName]) {\n            groupPositionName = 'left';\n        }\n\n        var groupArgs = groupPosition.args || {};\n        var portsArgs = ports.map(function(port) {\n            return port && port.position && port.position.args;\n        });\n        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n\n        var accumulator = {\n            ports: ports,\n            result: []\n        };\n\n        util.toArray(groupPortTransformations).reduce(function(res, portTransformation, index) {\n            var port = res.ports[index];\n            res.result.push({\n                portId: port.id,\n                portTransformation: portTransformation,\n                labelTransformation: this._getPortLabelLayout(port, Point(portTransformation), elBBox),\n                portAttrs: port.attrs,\n                portSize: port.size,\n                labelSize: port.label.size\n            });\n            return res;\n        }.bind(this), accumulator);\n\n        return accumulator.result;\n    },\n\n    _getPortLabelLayout: function(port, portPosition, elBBox) {\n\n        var namespace = this.portLabelLayoutNamespace;\n        var labelPosition = port.label.position.name || 'left';\n\n        if (namespace[labelPosition]) {\n            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n        }\n\n        return null;\n    },\n\n    _init: function(data) {\n\n        // prepare groups\n        if (util.isObject(data.groups)) {\n            var groups = Object.keys(data.groups);\n            for (var i = 0, n = groups.length; i < n; i++) {\n                var key = groups[i];\n                this.groups[key] = this._evaluateGroup(data.groups[key]);\n            }\n        }\n\n        // prepare ports\n        var ports = util.toArray(data.items);\n        for (var j = 0, m = ports.length; j < m; j++) {\n            this.ports.push(this._evaluatePort(ports[j]));\n        }\n    },\n\n    _evaluateGroup: function(group) {\n\n        return util.merge(group, {\n            position: this._getPosition(group.position, true),\n            label: this._getLabel(group, true)\n        });\n    },\n\n    _evaluatePort: function(port) {\n\n        var evaluated = util.assign({}, port);\n\n        var group = this.getGroup(port.group);\n\n        evaluated.markup = evaluated.markup || group.markup;\n        evaluated.attrs = util.merge({}, group.attrs, evaluated.attrs);\n        evaluated.position = this._createPositionNode(group, evaluated);\n        evaluated.label = util.merge({}, group.label, this._getLabel(evaluated));\n        evaluated.z = this._getZIndex(group, evaluated);\n        evaluated.size = util.assign({}, group.size, evaluated.size);\n\n        return evaluated;\n    },\n\n    _getZIndex: function(group, port) {\n\n        if (util.isNumber(port.z)) {\n            return port.z;\n        }\n        if (util.isNumber(group.z) || group.z === 'auto') {\n            return group.z;\n        }\n        return 'auto';\n    },\n\n    _createPositionNode: function(group, port) {\n\n        return util.merge({\n            name: 'left',\n            args: {}\n        }, group.position, { args: port.args });\n    },\n\n    _getPosition: function(position, setDefault) {\n\n        var args = {};\n        var positionName;\n\n        if (util.isFunction(position)) {\n            positionName = 'fn';\n            args.fn = position;\n        } else if (util.isString(position)) {\n            positionName = position;\n        } else if (position === undefined) {\n            positionName = setDefault ? 'left' : null;\n        } else if (Array.isArray(position)) {\n            positionName = 'absolute';\n            args.x = position[0];\n            args.y = position[1];\n        } else if (util.isObject(position)) {\n            positionName = position.name;\n            util.assign(args, position.args);\n        }\n\n        var result = { args: args };\n\n        if (positionName) {\n            result.name = positionName;\n        }\n        return result;\n    },\n\n    _getLabel: function(item, setDefaults) {\n\n        var label = item.label || {};\n\n        var ret = label;\n        ret.position = this._getPosition(label.position, setDefaults);\n\n        return ret;\n    }\n};\n\nexport const elementPortPrototype = {\n\n    _initializePorts: function() {\n\n        this._createPortData();\n        this.on('change:ports', function() {\n\n            this._processRemovedPort();\n            this._createPortData();\n        }, this);\n    },\n\n    /**\n     * remove links tied wiht just removed element\n     * @private\n     */\n    _processRemovedPort: function() {\n\n        var current = this.get('ports') || {};\n        var currentItemsMap = {};\n\n        util.toArray(current.items).forEach(function(item) {\n            currentItemsMap[item.id] = true;\n        });\n\n        var previous = this.previous('ports') || {};\n        var removed = {};\n\n        util.toArray(previous.items).forEach(function(item) {\n            if (!currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n\n        var graph = this.graph;\n        if (graph && !util.isEmpty(removed)) {\n\n            var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removed[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removed[link.get('source').port]) link.remove();\n            });\n        }\n    },\n\n    /**\n     * @returns {boolean}\n     */\n    hasPorts: function() {\n\n        var ports = this.prop('ports/items');\n        return Array.isArray(ports) && ports.length > 0;\n    },\n\n    /**\n     * @param {string} id\n     * @returns {boolean}\n     */\n    hasPort: function(id) {\n\n        return this.getPortIndex(id) !== -1;\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getPorts: function() {\n\n        return util.cloneDeep(this.prop('ports/items')) || [];\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getGroupPorts: function(groupName) {\n        const groupPorts = util.toArray(this.prop(['ports','items'])).filter(port => port.group === groupName);\n        return util.cloneDeep(groupPorts);\n    },\n\n    /**\n     * @param {string} id\n     * @returns {object}\n     */\n    getPort: function(id) {\n\n        return util.cloneDeep(util.toArray(this.prop('ports/items')).find(function(port) {\n            return port.id && port.id === id;\n        }));\n    },\n\n    getPortGroupNames: function() {\n        return Object.keys(this._portSettingsData.groups);\n    },\n\n    /**\n     * @param {string} groupName\n     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n     */\n    getPortsPositions: function(groupName) {\n\n        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, Rect(this.size()));\n\n        return portsMetrics.reduce(function(positions, metrics) {\n            var transformation = metrics.portTransformation;\n            positions[metrics.portId] = {\n                x: transformation.x,\n                y: transformation.y,\n                angle: transformation.angle\n            };\n            return positions;\n        }, {});\n    },\n\n    /**\n     * @param {string|Port} port port id or port\n     * @returns {number} port index\n     */\n    getPortIndex: function(port) {\n\n        var id = util.isObject(port) ? port.id : port;\n\n        if (!this._isValidPortId(id)) {\n            return -1;\n        }\n\n        return util.toArray(this.prop('ports/items')).findIndex(function(item) {\n            return item.id === id;\n        });\n    },\n\n    /**\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    addPort: function(port, opt) {\n\n        if (!util.isObject(port) || Array.isArray(port)) {\n            throw new Error('Element: addPort requires an object.');\n        }\n\n        var ports = util.assign([], this.prop('ports/items'));\n        ports.push(port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string|Port|number} before\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    insertPort: function(before, port, opt) {\n        const index = (typeof before === 'number') ? before : this.getPortIndex(before);\n\n        if (!util.isObject(port) || Array.isArray(port)) {\n            throw new Error('dia.Element: insertPort requires an object.');\n        }\n\n        const ports = util.assign([], this.prop('ports/items'));\n        ports.splice(index, 0, port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string} portId\n     * @param {string|object=} path\n     * @param {*=} value\n     * @param {object=} opt\n     * @returns {joint.dia.Element}\n     */\n    portProp: function(portId, path, value, opt) {\n\n        var index = this.getPortIndex(portId);\n\n        if (index === -1) {\n            throw new Error('Element: unable to find port with id ' + portId);\n        }\n\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (Array.isArray(path)) {\n            args[0] = ['ports', 'items', index].concat(path);\n        } else if (util.isString(path)) {\n\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = ['ports/items/', index, '/', path].join('');\n\n        } else {\n\n            args = ['ports/items/' + index];\n            if (util.isPlainObject(path)) {\n                args.push(path);\n                args.push(value);\n            }\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    _validatePorts: function() {\n\n        var portsAttr = this.get('ports') || {};\n\n        var errorMessages = [];\n        portsAttr = portsAttr || {};\n        var ports = util.toArray(portsAttr.items);\n\n        ports.forEach(function(p) {\n\n            if (typeof p !== 'object') {\n                errorMessages.push('Element: invalid port ', p);\n            }\n\n            if (!this._isValidPortId(p.id)) {\n                p.id = this.generatePortId();\n            }\n        }, this);\n\n        if (util.uniq(ports, 'id').length !== ports.length) {\n            errorMessages.push('Element: found id duplicities in ports.');\n        }\n\n        return errorMessages;\n    },\n\n    generatePortId: function() {\n        return this.generateId();\n    },\n\n    /**\n     * @param {string} id port id\n     * @returns {boolean}\n     * @private\n     */\n    _isValidPortId: function(id) {\n\n        return id !== null && id !== undefined && !util.isObject(id);\n    },\n\n    addPorts: function(ports, opt) {\n\n        if (ports.length) {\n            this.prop('ports/items', util.assign([], this.prop('ports/items')).concat(ports), opt);\n        }\n\n        return this;\n    },\n\n    removePort: function(port, opt) {\n        const options = opt || {};\n        const index = this.getPortIndex(port);\n        if (index !== -1) {\n            const ports = util.assign([], this.prop(['ports', 'items']));\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.startBatch('port-remove');\n            this.prop(['ports', 'items'], ports, options);\n            this.stopBatch('port-remove');\n        }\n        return this;\n    },\n\n    removePorts: function(portsForRemoval, opt) {\n        let options, newPorts;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length === 0) return this.this;\n            const currentPorts = util.assign([], this.prop(['ports', 'items']));\n            newPorts = currentPorts.filter(function(cp) {\n                return !portsForRemoval.some(function(rp) {\n                    const rpId = util.isObject(rp) ? rp.id : rp;\n                    return cp.id === rpId;\n                });\n            });\n        } else {\n            options = portsForRemoval || {};\n            newPorts = [];\n        }\n        this.startBatch('port-remove');\n        options.rewrite = true;\n        this.prop(['ports', 'items'], newPorts, options);\n        this.stopBatch('port-remove');\n        return this;\n    },\n\n    /**\n     * @private\n     */\n    _createPortData: function() {\n\n        var err = this._validatePorts();\n\n        if (err.length > 0) {\n            this.set('ports', this.previous('ports'));\n            throw new Error(err.join(' '));\n        }\n\n        var prevPortData;\n\n        if (this._portSettingsData) {\n\n            prevPortData = this._portSettingsData.getPorts();\n        }\n\n        this._portSettingsData = new PortData(this.get('ports'));\n\n        var curPortData = this._portSettingsData.getPorts();\n\n        if (prevPortData) {\n\n            var added = curPortData.filter(function(item) {\n                if (!prevPortData.find(function(prevPort) {\n                    return prevPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            var removed = prevPortData.filter(function(item) {\n                if (!curPortData.find(function(curPort) {\n                    return curPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            if (removed.length > 0) {\n                this.trigger('ports:remove', this, removed);\n            }\n\n            if (added.length > 0) {\n                this.trigger('ports:add', this, added);\n            }\n        }\n    }\n};\n\nexport const elementViewPortPrototype = {\n\n    portContainerMarkup: 'g',\n    portMarkup: [{\n        tagName: 'circle',\n        selector: 'circle',\n        attributes: {\n            'r': 10,\n            'fill': '#FFFFFF',\n            'stroke': '#000000'\n        }\n    }],\n    portLabelMarkup: [{\n        tagName: 'text',\n        selector: 'text',\n        attributes: {\n            'fill': '#000000'\n        }\n    }],\n    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n    _portElementsCache: null,\n\n    /**\n     * @private\n     */\n    _initializePorts: function() {\n        this._cleanPortsCache();\n    },\n\n    /**\n     * @typedef {Object} Port\n     *\n     * @property {string} id\n     * @property {Object} position\n     * @property {Object} label\n     * @property {Object} attrs\n     * @property {string} markup\n     * @property {string} group\n     */\n\n    /**\n     * @private\n     */\n    _refreshPorts: function() {\n\n        this._removePorts();\n        this._cleanPortsCache();\n        this._renderPorts();\n    },\n\n    _cleanPortsCache: function() {\n        this._portElementsCache = {};\n    },\n\n    /**\n     * @private\n     */\n    _renderPorts: function() {\n\n        // references to rendered elements without z-index\n        var elementReferences = [];\n        var elem = this._getContainerElement();\n\n        for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n            elementReferences.push(elem.node.childNodes[i]);\n        }\n\n        var portsGropsByZ = util.groupBy(this.model._portSettingsData.getPorts(), 'z');\n        var withoutZKey = 'auto';\n\n        // render non-z first\n        util.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n            var portElement = this._getPortElement(port);\n            elem.append(portElement);\n            elementReferences.push(portElement);\n        }, this);\n\n        var groupNames = Object.keys(portsGropsByZ);\n        for (var k = 0; k < groupNames.length; k++) {\n            var groupName = groupNames[k];\n            if (groupName !== withoutZKey) {\n                var z = parseInt(groupName, 10);\n                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n            }\n        }\n\n        this._updatePorts();\n    },\n\n    /**\n     * @returns {V}\n     * @private\n     */\n    _getContainerElement: function() {\n\n        return this.rotatableNode || this.vel;\n    },\n\n    /**\n     * @param {Array<Port>}ports\n     * @param {number} z\n     * @param refs\n     * @private\n     */\n    _appendPorts: function(ports, z, refs) {\n\n        var containerElement = this._getContainerElement();\n        var portElements = util.toArray(ports).map(this._getPortElement, this);\n\n        if (refs[z] || z < 0) {\n            V(refs[Math.max(z, 0)]).before(portElements);\n        } else {\n            containerElement.append(portElements);\n        }\n    },\n\n    /**\n     * Try to get element from cache,\n     * @param port\n     * @returns {*}\n     * @private\n     */\n    _getPortElement: function(port) {\n\n        if (this._portElementsCache[port.id]) {\n            return this._portElementsCache[port.id].portElement;\n        }\n        return this._createPortElement(port);\n    },\n\n    findPortNodes: function(portId, selector) {\n        const portCache = this._portElementsCache[portId];\n        if (!portCache) return [];\n        if (!selector) return [portCache.portContentElement.node];\n        const portRoot = portCache.portElement.node;\n        const portSelectors = portCache.portSelectors;\n        return this.findBySelector(selector, portRoot, portSelectors);\n    },\n\n    findPortNode: function(portId, selector) {\n        const [node = null] = this.findPortNodes(portId, selector);\n        return node;\n    },\n\n    /**\n     * @private\n     */\n    _updatePorts: function() {\n\n        // layout ports without group\n        this._updatePortGroup(undefined);\n        // layout ports with explicit group\n        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n        groupsNames.forEach(this._updatePortGroup, this);\n    },\n\n    /**\n     * @private\n     */\n    _removePorts: function() {\n        util.invoke(this._portElementsCache, 'portElement.remove');\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {V}\n     * @private\n     */\n    _createPortElement: function(port) {\n\n        let portElement;\n        let labelElement;\n        let labelSelectors;\n        let portSelectors;\n\n        var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n\n        var portMarkup = this._getPortMarkup(port);\n        if (Array.isArray(portMarkup)) {\n            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n            var portFragment = portDoc.fragment;\n            if (portFragment.childNodes.length > 1) {\n                portElement = V('g').append(portFragment);\n            } else {\n                portElement = V(portFragment.firstChild);\n            }\n            portSelectors = portDoc.selectors;\n        } else {\n            portElement = V(portMarkup);\n            if (Array.isArray(portElement)) {\n                portElement = V('g').append(portElement);\n            }\n        }\n\n        if (!portElement) {\n            throw new Error('ElementView: Invalid port markup.');\n        }\n\n        portElement.attr({\n            'port': port.id,\n            'port-group': port.group\n        });\n\n        // If the port ID is a number, we need to add\n        // extra information to the port element to distinguish\n        // between ports with the same ID but different types.\n        if (util.isNumber(port.id)) {\n            portElement.attr('port-id-type', 'number');\n        }\n\n        const labelMarkupDef = this._getPortLabelMarkup(port.label);\n        if (Array.isArray(labelMarkupDef)) {\n            // JSON Markup\n            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n            const childCount = fragment.childNodes.length;\n            if (childCount > 0) {\n                labelSelectors = selectors;\n                labelElement = (childCount === 1) ? V(fragment.firstChild) : V('g').append(fragment);\n            }\n        } else {\n            // String Markup\n            labelElement = V(labelMarkupDef);\n            if (Array.isArray(labelElement)) {\n                labelElement = V('g').append(labelElement);\n            }\n        }\n\n        var portContainerSelectors;\n        if (portSelectors && labelSelectors) {\n            for (var key in labelSelectors) {\n                if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n            }\n            portContainerSelectors = util.assign({}, portSelectors, labelSelectors);\n        } else {\n            portContainerSelectors = portSelectors || labelSelectors || {};\n        }\n\n        // The `portRootSelector` points to the root SVGNode of the port.\n        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n        // Or the single SVGNode of the port.\n        const portRootSelector = 'portRoot';\n        // The `labelRootSelector` points to the root SVGNode of the label.\n        const labelRootSelector = 'labelRoot';\n        // The `labelTextSelector` points to all text SVGNodes of the label.\n        const labelTextSelector = 'labelText';\n\n        if (!(portRootSelector in portContainerSelectors)) {\n            portContainerSelectors[portRootSelector] = portElement.node;\n        }\n\n        if (labelElement) {\n            const labelNode = labelElement.node;\n            if (!(labelRootSelector in portContainerSelectors)) {\n                portContainerSelectors[labelRootSelector] = labelNode;\n            }\n            if (!(labelTextSelector in portContainerSelectors)) {\n                // If the label is a <text> element, we can use it directly.\n                // Otherwise, we need to find the <text> element within the label.\n                const labelTextNode = (labelElement.tagName() === 'TEXT')\n                    ? labelNode\n                    : Array.from(labelNode.querySelectorAll('text'));\n                portContainerSelectors[labelTextSelector] = labelTextNode;\n                if (!labelSelectors) labelSelectors = {};\n                labelSelectors[labelTextSelector] = labelTextNode;\n            }\n        }\n\n        portContainerElement.append(portElement.addClass('joint-port-body'));\n        if (labelElement) {\n            portContainerElement.append(labelElement.addClass('joint-port-label'));\n        }\n\n        this._portElementsCache[port.id] = {\n            portElement: portContainerElement,\n            portLabelElement: labelElement,\n            portSelectors: portContainerSelectors,\n            portLabelSelectors: labelSelectors,\n            portContentElement: portElement,\n            portContentSelectors: portSelectors\n        };\n\n        return portContainerElement;\n    },\n\n    /**\n     * @param {string=} groupName\n     * @private\n     */\n    _updatePortGroup: function(groupName) {\n\n        var elementBBox = Rect(this.model.size());\n        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n\n        for (var i = 0, n = portsMetrics.length; i < n; i++) {\n            var metrics = portsMetrics[i];\n            var portId = metrics.portId;\n            var cached = this._portElementsCache[portId] || {};\n            var portTransformation = metrics.portTransformation;\n            var labelTransformation = metrics.labelTransformation;\n            if (labelTransformation && cached.portLabelElement) {\n                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n                    rootBBox: new Rect(metrics.labelSize),\n                    selectors: cached.portLabelSelectors\n                });\n                this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\n            }\n            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n                rootBBox: new Rect(metrics.portSize),\n                selectors: cached.portSelectors\n            });\n            this.applyPortTransform(cached.portElement, portTransformation);\n        }\n    },\n\n    /**\n     * @param {Vectorizer} element\n     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n     * @param {number=} initialAngle\n     * @constructor\n     */\n    applyPortTransform: function(element, transformData, initialAngle) {\n\n        var matrix = V.createSVGMatrix()\n            .rotate(initialAngle || 0)\n            .translate(transformData.x || 0, transformData.y || 0)\n            .rotate(transformData.angle || 0);\n\n        element.transform(matrix, { absolute: true });\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {string}\n     * @private\n     */\n    _getPortMarkup: function(port) {\n\n        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n    },\n\n    /**\n     * @param {Object} label\n     * @returns {string}\n     * @private\n     */\n    _getPortLabelMarkup: function(label) {\n\n        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n    }\n};\n\n", "import { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs';\n\n// Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n\n    defaults: {\n        position: { x: 0, y: 0 },\n        size: { width: 1, height: 1 },\n        angle: 0\n    },\n\n    initialize: function() {\n\n        this._initializePorts();\n        Cell.prototype.initialize.apply(this, arguments);\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    _refreshPorts: function() {\n        // implemented in ports.js\n    },\n\n    isElement: function() {\n\n        return true;\n    },\n\n    position: function(x, y, opt) {\n\n        const isSetter = isNumber(y);\n        opt = (isSetter ? opt : x) || {};\n        const { parentRelative, deep, restrictedArea } = opt;\n\n\n        // option `parentRelative` for setting the position relative to the element's parent.\n        let parentPosition;\n        if (parentRelative) {\n\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error('Element must be part of a graph.');\n\n            const parent = this.getParentCell();\n            if (parent && !parent.isLink()) {\n                parentPosition = parent.get('position');\n            }\n        }\n\n        if (isSetter) {\n\n            if (parentPosition) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n\n            if (deep || restrictedArea) {\n                const { x: x0, y: y0 } = this.get('position');\n                this.translate(x - x0, y - y0, opt);\n            } else {\n                this.set('position', { x, y }, opt);\n            }\n\n            return this;\n\n        } else { // Getter returns a geometry point.\n\n            const elementPosition = Point(this.get('position'));\n            return parentRelative\n                ? elementPosition.difference(parentPosition)\n                : elementPosition;\n        }\n    },\n\n    translate: function(tx, ty, opt) {\n\n        tx = tx || 0;\n        ty = ty || 0;\n\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n\n        var position = this.get('position') || { x: 0, y: 0 };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n\n            if (typeof ra === 'function') {\n\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n\n            } else  {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({ deep: true });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                ▓▓▓▓▓▓▓   |\n                //         ░░░░░░░▓▓▓▓▓▓▓\n                //         ░░░░░░░░░        |\n                //   ▓▓▓▓▓▓▓▓░░░░░░░\n                //   ▓▓▓▓▓▓▓▓               |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |   ░ translated element\n                //   <- - bbox.width - ->       ▓ embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n\n        if (opt.transition) {\n\n            if (!isObject(opt.transition)) opt.transition = {};\n\n            this.transition('position', translatedPosition, assign({}, opt.transition, {\n                valueFunction: interpolate.object\n            }));\n\n            // Recursively call `translate()` on all the embeds cells.\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n        } else {\n\n            this.startBatch('translate', opt);\n            this.set('position', translatedPosition, opt);\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n            this.stopBatch('translate', opt);\n        }\n\n        return this;\n    },\n\n    size: function(width, height, opt) {\n\n        var currentSize = this.get('size');\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if (isObject(width)) {\n            opt = height;\n            height = isNumber(width.height) ? width.height : currentSize.height;\n            width = isNumber(width.width) ? width.width : currentSize.width;\n        }\n\n        return this.resize(width, height, opt);\n    },\n\n    resize: function(width, height, opt) {\n\n        opt = opt || {};\n\n        this.startBatch('resize', opt);\n\n        if (opt.direction) {\n\n            var currentSize = this.get('size');\n\n            switch (opt.direction) {\n\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = normalizeAngle(this.get('angle') || 0);\n\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n\n            var origin;\n\n            if (angle) {\n\n                var quadrant = {\n                    'top-right': 0,\n                    'right': 0,\n                    'top-left': 1,\n                    'top': 1,\n                    'bottom-left': 2,\n                    'left': 2,\n                    'bottom-right': 3,\n                    'bottom': 3\n                }[opt.direction];\n\n                if (opt.absolute) {\n\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= toRad(angle);\n\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = Point(center).offset(width / -2, height / -2);\n\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n\n                switch (opt.direction) {\n                    case 'top':\n                    case 'top-right':\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case 'left':\n                    case 'bottom-left':\n                        origin.offset(bbox.width -width, 0);\n                        break;\n                    case 'top-left':\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n\n            // Resize the element (before re-positioning it).\n            this.set('size', { width: width, height: height }, opt);\n\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n\n        } else {\n\n            // Resize the element.\n            this.set('size', { width: width, height: height }, opt);\n        }\n\n        this.stopBatch('resize', opt);\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch('scale', opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch('scale');\n        return this;\n    },\n\n    fitEmbeds: function(opt) {\n\n        return this.fitToChildren(opt);\n    },\n\n    fitToChildren: function(opt = {}) {\n\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') holds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        const childElements = this.getEmbeddedCells().filter(cell => cell.isElement());\n        if (childElements.length === 0) return this;\n\n        this.startBatch('fit-embeds', opt);\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit to all descendants\".\n            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n            invoke(childElements, 'fitToChildren', opt);\n        }\n\n        // Set new size and position of this element, based on:\n        // - union of bboxes of all children\n        // - inflated by given `opt.padding`\n        this._fitToElements(Object.assign({ elements: childElements }, opt));\n\n        this.stopBatch('fit-embeds');\n\n        return this;\n    },\n\n    fitParent: function(opt = {}) {\n\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n        if (opt.deep && opt.terminator && ((opt.terminator === this) || (opt.terminator === this.id))) return this;\n\n        const parentElement = this.getParentCell();\n        if (!parentElement || !parentElement.isElement()) return this;\n\n        // Get all children of parent element (i.e. this element + any sibling elements).\n        const siblingElements = parentElement.getEmbeddedCells().filter(cell => cell.isElement());\n        if (siblingElements.length === 0) return this;\n\n        this.startBatch('fit-parent', opt);\n\n        // Set new size and position of parent element, based on:\n        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n        // - inflated by given `opt.padding`\n        parentElement._fitToElements(Object.assign({ elements: siblingElements }, opt));\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit all ancestors to their respective children\".\n            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n            parentElement.fitParent(opt);\n        }\n\n        this.stopBatch('fit-parent');\n\n        return this;\n    },\n\n    // Assumption: This element is part of a graph.\n    _fitToElements: function(opt = {}) {\n\n        const elementsBBox = this.graph.getCellsBBox(opt.elements);\n        // If no `opt.elements` were provided, do nothing.\n        if (!elementsBBox) return;\n\n        const { expandOnly, shrinkOnly } = opt;\n        // This combination is meaningless, do nothing.\n        if (expandOnly && shrinkOnly) return;\n\n        // Calculate new size and position of this element based on:\n        // - union of bboxes of `opt.elements`\n        // - inflated by `opt.padding` (if not provided, all four properties = 0)\n        let { x, y, width, height } = elementsBBox;\n        const { left, right, top, bottom } = normalizeSides(opt.padding);\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n        let resultBBox = new Rect(x, y, width, height);\n\n        if (expandOnly) {\n            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n            resultBBox = this.getBBox().union(resultBBox);\n\n        } else if (shrinkOnly) {\n            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n            const intersectionBBox = this.getBBox().intersect(resultBBox);\n            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n            if (!intersectionBBox) return;\n\n            resultBBox =  intersectionBBox;\n        }\n\n        // Set the new size and position of this element.\n        this.set({\n            position: { x: resultBBox.x, y: resultBBox.y },\n            size: { width: resultBBox.width, height: resultBBox.height }\n        }, opt);\n    },\n\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n\n        if (origin) {\n\n            var center = this.getBBox().center();\n            var size = this.get('size');\n            var position = this.get('position');\n            center.rotate(origin, this.get('angle') - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch('rotate');\n\n        } else {\n\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n        }\n\n        return this;\n    },\n\n    angle: function() {\n        return normalizeAngle(this.get('angle') || 0);\n    },\n\n    getBBox: function(opt = {}) {\n\n        const { graph, attributes } = this;\n        const { deep, rotate } = opt;\n\n        if (deep && graph) {\n            // Get all the embedded elements using breadth first algorithm.\n            const elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n            // Add the model itself.\n            elements.push(this);\n            // Note: the default of getCellsBBox() is rotate=true and can't be\n            // changed without a breaking change\n            return graph.getCellsBBox(elements, opt);\n        }\n\n        const { angle = 0, position: { x, y }, size: { width, height }} = attributes;\n        const bbox = new Rect(x, y, width, height);\n        if (rotate) {\n            bbox.rotateAroundCenter(angle);\n        }\n        return bbox;\n    },\n\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, ['group']);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n\nassign(Element.prototype, elementPortPrototype);\n\n", "import { Cell } from './Cell.mjs';\nimport { clone, isPlainObject, isFunction, isString, isNumber } from '../util/index.mjs';\nimport { Point, Polyline } from '../g/index.mjs';\n\n// Link base model.\n// --------------------------\n\nexport const Link = Cell.extend({\n\n    // may be overwritten by user to change default label (its markup, size, attrs, position)\n    defaultLabel: undefined,\n\n    // deprecated\n    // may be overwritten by user to change default label markup\n    // lower priority than defaultLabel.markup\n    labelMarkup: undefined,\n\n    // private\n    _builtins: {\n        defaultLabel: {\n            // builtin default markup:\n            // used if neither defaultLabel.markup\n            // nor label.markup is set\n            markup: [\n                {\n                    tagName: 'rect',\n                    selector: 'rect' // faster than tagName CSS selector\n                }, {\n                    tagName: 'text',\n                    selector: 'text' // faster than tagName CSS selector\n                }\n            ],\n            // builtin default attributes:\n            // applied only if builtin default markup is used\n            attrs: {\n                text: {\n                    fill: '#000000',\n                    fontSize: 14,\n                    textAnchor: 'middle',\n                    textVerticalAnchor: 'middle',\n                    pointerEvents: 'none'\n                },\n                rect: {\n                    ref: 'text',\n                    fill: '#ffffff',\n                    rx: 3,\n                    ry: 3,\n                    x: 'calc(x)',\n                    y: 'calc(y)',\n                    width: 'calc(w)',\n                    height: 'calc(h)'\n                }\n            },\n            // builtin default position:\n            // used if neither defaultLabel.position\n            // nor label.position is set\n            position: {\n                distance: 0.5\n            }\n        }\n    },\n\n    defaults: {\n        source: {},\n        target: {}\n    },\n\n    isLink: function() {\n\n        return true;\n    },\n\n    disconnect: function(opt) {\n\n        return this.set({\n            source: { x: 0, y: 0 },\n            target: { x: 0, y: 0 }\n        }, opt);\n    },\n\n    source: function(source, args, opt) {\n\n        // getter\n        if (source === undefined) {\n            return clone(this.get('source'));\n        }\n\n        // setter\n        var setSource;\n        var setOpt;\n\n        // `source` is a cell\n        // take only its `id` and combine with `args`\n        var isCellProvided = source instanceof Cell;\n        if (isCellProvided) { // three arguments\n            setSource = clone(args) || {};\n            setSource.id = source.id;\n            setOpt = opt;\n            return this.set('source', setSource, setOpt);\n        }\n\n        // `source` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !isPlainObject(source);\n        if (isPointProvided) { // three arguments\n            setSource = clone(args) || {};\n            setSource.x = source.x;\n            setSource.y = source.y;\n            setOpt = opt;\n            return this.set('source', setSource, setOpt);\n        }\n\n        // `source` is an object\n        // no checking\n        // two arguments\n        setSource = source;\n        setOpt = args;\n        return this.set('source', setSource, setOpt);\n    },\n\n    target: function(target, args, opt) {\n\n        // getter\n        if (target === undefined) {\n            return clone(this.get('target'));\n        }\n\n        // setter\n        var setTarget;\n        var setOpt;\n\n        // `target` is a cell\n        // take only its `id` argument and combine with `args`\n        var isCellProvided = target instanceof Cell;\n        if (isCellProvided) { // three arguments\n            setTarget = clone(args) || {};\n            setTarget.id = target.id;\n            setOpt = opt;\n            return this.set('target', setTarget, setOpt);\n        }\n\n        // `target` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !isPlainObject(target);\n        if (isPointProvided) { // three arguments\n            setTarget = clone(args) || {};\n            setTarget.x = target.x;\n            setTarget.y = target.y;\n            setOpt = opt;\n            return this.set('target', setTarget, setOpt);\n        }\n\n        // `target` is an object\n        // no checking\n        // two arguments\n        setTarget = target;\n        setOpt = args;\n        return this.set('target', setTarget, setOpt);\n    },\n\n    router: function(name, args, opt) {\n\n        // getter\n        if (name === undefined) {\n            var router = this.get('router');\n            if (!router) {\n                return null;\n            }\n            if (typeof router === 'object') return clone(router);\n            return router; // e.g. a function\n        }\n\n        // setter\n        var isRouterProvided = ((typeof name === 'object') || (typeof name === 'function'));\n        var localRouter = isRouterProvided ? name : { name: name, args: args };\n        var localOpt = isRouterProvided ? args : opt;\n\n        return this.set('router', localRouter, localOpt);\n    },\n\n    connector: function(name, args, opt) {\n\n        // getter\n        if (name === undefined) {\n            var connector = this.get('connector');\n            if (!connector) {\n                return null;\n            }\n            if (typeof connector === 'object') return clone(connector);\n            return connector; // e.g. a function\n        }\n\n        // setter\n        var isConnectorProvided = ((typeof name === 'object' || typeof name === 'function'));\n        var localConnector = isConnectorProvided ? name : { name: name, args: args };\n        var localOpt = isConnectorProvided ? args : opt;\n\n        return this.set('connector', localConnector, localOpt);\n    },\n\n    // Labels API\n\n    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n    label: function(idx, label, opt) {\n\n        var labels = this.labels();\n\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n        if (idx < 0) idx = labels.length + idx;\n\n        // getter\n        if (arguments.length <= 1) return this.prop(['labels', idx]);\n        // setter\n        return this.prop(['labels', idx], label, opt);\n    },\n\n    labels: function(labels, opt) {\n\n        // getter\n        if (arguments.length === 0) {\n            labels = this.get('labels');\n            if (!Array.isArray(labels)) return [];\n            return labels.slice();\n        }\n        // setter\n        if (!Array.isArray(labels)) labels = [];\n        return this.set('labels', labels, opt);\n    },\n\n    hasLabels: function() {\n        const { labels } = this.attributes;\n        return Array.isArray(labels) && labels.length > 0;\n    },\n\n    insertLabel: function(idx, label, opt) {\n\n        if (!label) throw new Error('dia.Link: no label provided');\n\n        var labels = this.labels();\n        var n = labels.length;\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n        if (idx < 0) idx = n + idx + 1;\n\n        labels.splice(idx, 0, label);\n        return this.labels(labels, opt);\n    },\n\n    // convenience function\n    // add label to end of labels array\n    appendLabel: function(label, opt) {\n\n        return this.insertLabel(-1, label, opt);\n    },\n\n    removeLabel: function(idx, opt) {\n\n        var labels = this.labels();\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n        labels.splice(idx, 1);\n        return this.labels(labels, opt);\n    },\n\n    // Vertices API\n\n    vertex: function(idx, vertex, opt) {\n\n        var vertices = this.vertices();\n\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n        if (idx < 0) idx = vertices.length + idx;\n\n        // getter\n        if (arguments.length <= 1) return this.prop(['vertices', idx]);\n\n        // setter\n        var setVertex = this._normalizeVertex(vertex);\n        return this.prop(['vertices', idx], setVertex, opt);\n    },\n\n    vertices: function(vertices, opt) {\n\n        // getter\n        if (arguments.length === 0) {\n            vertices = this.get('vertices');\n            if (!Array.isArray(vertices)) return [];\n            return vertices.slice();\n        }\n\n        // setter\n        if (!Array.isArray(vertices)) vertices = [];\n        var setVertices = [];\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            var setVertex = this._normalizeVertex(vertex);\n            setVertices.push(setVertex);\n        }\n        return this.set('vertices', setVertices, opt);\n    },\n\n    insertVertex: function(idx, vertex, opt) {\n\n        if (!vertex) throw new Error('dia.Link: no vertex provided');\n\n        var vertices = this.vertices();\n        var n = vertices.length;\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n        if (idx < 0) idx = n + idx + 1;\n\n        var setVertex = this._normalizeVertex(vertex);\n        vertices.splice(idx, 0, setVertex);\n        return this.vertices(vertices, opt);\n    },\n\n    removeVertex: function(idx, opt) {\n\n        var vertices = this.vertices();\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n        vertices.splice(idx, 1);\n        return this.vertices(vertices, opt);\n    },\n\n    _normalizeVertex: function(vertex) {\n\n        // is vertex a point-like object?\n        // for example, a g.Point\n        var isPointProvided = !isPlainObject(vertex);\n        if (isPointProvided) return { x: vertex.x, y: vertex.y };\n\n        // else: return vertex unchanged\n        return vertex;\n    },\n\n    // Transformations\n\n    translate: function(tx, ty, opt) {\n\n        // enrich the option object\n        opt = opt || {};\n        opt.translateBy = opt.translateBy || this.id;\n        opt.tx = tx;\n        opt.ty = ty;\n\n        return this.applyToPoints(function(p) {\n            return { x: (p.x || 0) + tx, y: (p.y || 0) + ty };\n        }, opt);\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        return this.applyToPoints(function(p) {\n            return Point(p).scale(sx, sy, origin).toJSON();\n        }, opt);\n    },\n\n    applyToPoints: function(fn, opt) {\n\n        if (!isFunction(fn)) {\n            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n        }\n\n        var attrs = {};\n\n        var { source, target } = this.attributes;\n        if (!source.id) {\n            attrs.source = fn(source);\n        }\n        if (!target.id) {\n            attrs.target = fn(target);\n        }\n\n        var vertices = this.vertices();\n        if (vertices.length > 0) {\n            attrs.vertices = vertices.map(fn);\n        }\n\n        return this.set(attrs, opt);\n    },\n\n    getSourcePoint: function() {\n        var sourceCell = this.getSourceCell();\n        if (!sourceCell) return new Point(this.source());\n        return sourceCell.getPointFromConnectedLink(this, 'source');\n    },\n\n    getTargetPoint: function() {\n        var targetCell = this.getTargetCell();\n        if (!targetCell) return new Point(this.target());\n        return targetCell.getPointFromConnectedLink(this, 'target');\n    },\n\n    getPointFromConnectedLink: function(/* link, endType */) {\n        return this.getPolyline().pointAt(0.5);\n    },\n\n    getPolyline: function() {\n        const points = [\n            this.getSourcePoint(),\n            ...this.vertices().map(Point),\n            this.getTargetPoint()\n        ];\n        return new Polyline(points);\n    },\n\n    getBBox: function() {\n        return this.getPolyline().bbox();\n    },\n\n    reparent: function(opt) {\n\n        var newParent;\n\n        if (this.graph) {\n\n            var source = this.getSourceElement();\n            var target = this.getTargetElement();\n            var prevParent = this.getParentCell();\n\n            if (source && target) {\n                if (source === target || source.isEmbeddedIn(target)) {\n                    newParent = target;\n                } else if (target.isEmbeddedIn(source)) {\n                    newParent = source;\n                } else {\n                    newParent = this.graph.getCommonAncestor(source, target);\n                }\n            }\n\n            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n                // Unembed the link if source and target has no common ancestor\n                // or common ancestor changed\n                prevParent.unembed(this, opt);\n            }\n\n            if (newParent) {\n                newParent.embed(this, opt);\n            }\n        }\n\n        return newParent;\n    },\n\n    hasLoop: function(opt) {\n\n        opt = opt || {};\n\n        var { source, target } = this.attributes;\n        var sourceId = source.id;\n        var targetId = target.id;\n\n        if (!sourceId || !targetId) {\n            // Link \"pinned\" to the paper does not have a loop.\n            return false;\n        }\n\n        var loop = sourceId === targetId;\n\n        // Note that there in the deep mode a link can have a loop,\n        // even if it connects only a parent and its embed.\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\n        if (!loop && opt.deep && this.graph) {\n\n            var sourceElement = this.getSourceCell();\n            var targetElement = this.getTargetCell();\n\n            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n        }\n\n        return loop;\n    },\n\n    // unlike source(), this method returns null if source is a point\n    getSourceCell: function() {\n\n        const { graph, attributes } = this;\n        var source = attributes.source;\n        return (source && source.id && graph && graph.getCell(source.id)) || null;\n    },\n\n    getSourceElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getSourceCell();\n        } while (cell && cell.isLink());\n        return cell;\n    },\n\n    // unlike target(), this method returns null if target is a point\n    getTargetCell: function() {\n\n        const { graph, attributes } = this;\n        var target = attributes.target;\n        return (target && target.id && graph && graph.getCell(target.id)) || null;\n    },\n\n    getTargetElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getTargetCell();\n        } while (cell && cell.isLink());\n        return cell;\n    },\n\n    // Returns the common ancestor for the source element,\n    // target element and the link itself.\n    getRelationshipAncestor: function() {\n\n        var connectionAncestor;\n\n        if (this.graph) {\n\n            var cells = [\n                this,\n                this.getSourceElement(), // null if source is a point\n                this.getTargetElement() // null if target is a point\n            ].filter(function(item) {\n                return !!item;\n            });\n\n            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n        }\n\n        return connectionAncestor || null;\n    },\n\n    // Is source, target and the link itself embedded in a given cell?\n    isRelationshipEmbeddedIn: function(cell) {\n\n        var cellId = (isString(cell) || isNumber(cell)) ? cell : cell.id;\n        var ancestor = this.getRelationshipAncestor();\n\n        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n    },\n\n    // Get resolved default label.\n    _getDefaultLabel: function() {\n\n        var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\n        var label = {};\n        label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n        label.position = defaultLabel.position;\n        label.attrs = defaultLabel.attrs;\n        label.size = defaultLabel.size;\n\n        return label;\n    }\n}, {\n\n    endsEqual: function(a, b) {\n\n        var portsEqual = a.port === b.port || !a.port && !b.port;\n        return a.id === b.id && portsEqual;\n    }\n});\n\n", "export const env = {\n\n    _results: {},\n\n    _tests: {\n\n        svgforeignobject: function() {\n            return !!document.createElementNS &&\n                /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n        },\n\n        // works for iOS browsers too\n        isSafari: function() {\n            return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);\n        }\n    },\n\n    addTest: function(name, fn) {\n\n        return this._tests[name] = fn;\n    },\n\n    test: function(name) {\n\n        var fn = this._tests[name];\n\n        if (!fn) {\n            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n        }\n\n        var result = this._results[name];\n\n        if (typeof result !== 'undefined') {\n            return result;\n        }\n\n        try {\n            result = fn();\n        } catch (error) {\n            result = false;\n        }\n\n        // Cache the test result.\n        this._results[name] = result;\n\n        return result;\n    }\n};\n", "export * from './straight.mjs';\nexport * from './jumpover.mjs';\nexport * from './normal.mjs';\nexport * from './rounded.mjs';\nexport * from './smooth.mjs';\nexport * from './curve.mjs';\n", "import * as g from '../g/index.mjs';\n\nconst CornerTypes = {\n    POINT: 'point',\n    CUBIC: 'cubic',\n    LINE: 'line',\n    GAP: 'gap'\n};\n\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\n\nexport const straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\n    const {\n        cornerType = CornerTypes.POINT,\n        cornerRadius = CORNER_RADIUS,\n        cornerPreserveAspectRatio = false,\n        precision = PRECISION,\n        raw = false\n    } = opt;\n\n    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n        // unknown `cornerType` provided => error\n        throw new Error('Invalid `cornerType` provided to `straight` connector.');\n    }\n\n    let path;\n\n    if ((cornerType === CornerTypes.POINT) || !cornerRadius) {\n        // default option => normal connector\n        // simply connect all points with straight lines\n        const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n        const polyline = new g.Polyline(points);\n        path = new g.Path(polyline);\n\n    } else {\n        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n        path = new g.Path();\n\n        // add initial gap segment = to source point\n        path.appendSegment(g.Path.createSegment('M', sourcePoint));\n\n        let nextDistance;\n        const routePointsLength = routePoints.length;\n        for (let i = 0; i < routePointsLength; i++) {\n\n            const curr = new g.Point(routePoints[i]);\n            const prev = (routePoints[i - 1] || sourcePoint);\n            const next = (routePoints[i + 1] || targetPoint);\n            const prevDistance = (nextDistance || (curr.distance(prev) / 2)); // try to re-use previously-computed `nextDistance`\n            nextDistance = (curr.distance(next) / 2);\n\n            let startMove, endMove;\n            if (!cornerPreserveAspectRatio) {\n                // `startMove` and `endMove` may be different\n                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                startMove = -Math.min(cornerRadius, prevDistance);\n                endMove = -Math.min(cornerRadius, nextDistance);\n            } else {\n                // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n            }\n\n            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n            // - find a point lying on the line `prev - startMove` such that...\n            // - ...the point lies `abs(startMove)` distance away from `curr`...\n            // - ...and its coordinates are rounded to whole numbers\n            const cornerStart = curr.clone().move(prev, startMove).round(precision);\n            const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n            // add in-between straight segment = from previous route point to corner start point\n            // (may have zero length)\n            path.appendSegment(g.Path.createSegment('L', cornerStart));\n\n            // add corner segment = from corner start point to corner end point\n            switch (cornerType) {\n                case CornerTypes.CUBIC: {\n                    // corner is rounded\n                    const _13 = (1 / 3);\n                    const _23 = (2 / 3);\n                    const control1 = new g.Point((_13 * cornerStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerStart.y));\n                    const control2 = new g.Point((_13 * cornerEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerEnd.y));\n                    path.appendSegment(g.Path.createSegment('C', control1, control2, cornerEnd));\n                    break;\n                }\n                case CornerTypes.LINE: {\n                    // corner has bevel\n                    path.appendSegment(g.Path.createSegment('L', cornerEnd));\n                    break;\n                }\n                case CornerTypes.GAP: {\n                    // corner has empty space\n                    path.appendSegment(g.Path.createSegment('M', cornerEnd));\n                    break;\n                }\n                // default: no segment is created\n            }\n        }\n\n        // add final straight segment = from last corner end point to target point\n        // (= or from start point to end point, if there are no route points)\n        // (may have zero length)\n        path.appendSegment(g.Path.createSegment('L', targetPoint));\n    }\n\n    return ((raw) ? path : path.serialize());\n};\n", "import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\nfunction sortPointsAscending(p1, p2) {\n\n    let { x: x1, y: y1 } = p1;\n    let { x: x2, y: y2 } = p2;\n\n    if (x1 > x2) {\n\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    if (y1 > y2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    return [new g.Point(x1, y1), new g.Point(x2, y2)];\n}\n\nfunction overlapExists(line1, line2) {\n\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);\n\n    const xMatch = x1 <= x4 && x3 <= x2;\n    const yMatch = y1 <= y4 && y3 <= y2;\n\n    return xMatch && yMatch;\n}\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = g.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return util.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = g.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            g.line(lastLine.start, jumpStart),\n            jumpLine,\n            g.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new g.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = g.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    util.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new g.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new g.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = g.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = g.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new g.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new g.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = g.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (util.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                const linkLinesToTest = linkLines[i].slice();\n                const overlapIndex = linkLinesToTest.findIndex((line) => overlapExists(thisLine, line));\n\n                // Overlap occurs and the end point of one segment lies on thisLine\n                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n                    // Remove the next segment because there will never be a jump\n                    linkLinesToTest.splice(overlapIndex + 1, 1);\n                }\n                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n", "import { straight } from './straight.mjs';\n\nexport const normal = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { raw } = opt;\n    const localOpt = {\n        cornerType: 'point',\n        raw\n    };\n\n    return straight(sourcePoint, targetPoint, route, localOpt);\n};\n", "import { straight } from './straight.mjs';\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 0;\n\nexport const rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { radius = CORNER_RADIUS, raw } = opt;\n    const localOpt = {\n        cornerType: 'cubic',\n        cornerRadius: radius,\n        precision: PRECISION,\n        raw\n    };\n\n    return straight(sourcePoint, targetPoint, route, localOpt);\n};\n", "import * as g from '../g/index.mjs';\n\nexport const smooth = function(sourcePoint, targetPoint, route, opt) {\n\n    var raw = opt && opt.raw;\n    var path;\n\n    if (route && route.length !== 0) {\n\n        var points = [sourcePoint].concat(route).concat([targetPoint]);\n        var curves = g.Curve.throughPoints(points);\n\n        path = new g.Path(curves);\n\n    } else {\n        // if we have no route, use a default cubic bezier curve\n        // cubic bezier requires two control points\n        // the control points have `x` midway between source and target\n        // this produces an S-like curve\n\n        path = new g.Path();\n\n        var segment;\n\n        segment = g.Path.createSegment('M', sourcePoint);\n        path.appendSegment(segment);\n\n        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n            segment = g.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        } else {\n            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n            segment = g.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        }\n    }\n\n    return (raw) ? path : path.serialize();\n};\n", "import { Path, Point, Curve } from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst TangentDirections = {\n    UP: 'up',\n    DOWN: 'down',\n    LEFT: 'left',\n    RIGHT: 'right',\n    AUTO: 'auto',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nexport const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n        rotate: Boolean(opt.rotate)\n    };\n    if (typeof opt.sourceDirection === 'string')\n        options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === 'number')\n        options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);\n    else\n        options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n\n    if (typeof opt.targetDirection === 'string')\n        options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === 'number')\n        options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);\n    else\n        options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n\n    const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));\n\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n    const path = new Path(bezierCurves).round(precision);\n\n    return (raw) ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.x > route[1].x)\n            sourceSide = 'right';\n        else\n            sourceSide = 'left';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.x > route[route.length - 2].x)\n            targetSide = 'left';\n        else\n            targetSide = 'right';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.y > route[1].y)\n            sourceSide = 'bottom';\n        else\n            sourceSide = 'top';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.y > route[route.length - 2].y)\n            targetSide = 'top';\n        else\n            targetSide = 'bottom';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new Point(0, 1);\n            break;\n        case 'right':\n            direction = new Point(1, 0);\n            break;\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new Point(0, 1);\n            break;\n        case 'right':\n            direction = new Point(1, 0);\n            break;\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch (options.sourceDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch (options.targetDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\n\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n\n    for (let i = 0; i < n; i++) {\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n\n    // The calculation of tangents of vertices\n    for (let i = 1; i < n; i++) {\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n\n        tangents[i] = [t1, t2];\n    }\n\n    // The building of a Catmull-Rom curve based of tangents of points\n    for (let i = 0; i < n; i++) {\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n\n        catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n    }\n    return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n\n    const bcp1 = new Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n    const bcp2 = new Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new Curve(\n        points[1],\n        bcp1,\n        bcp2,\n        points[2]\n    );\n}\n", "export * from './stroke.mjs';\nexport * from './mask.mjs';\nexport * from './opacity.mjs';\nexport * from './addClass.mjs';\nexport * from './list.mjs';\n", "export * from './View.mjs';\nexport * from './Listener.mjs';\nexport * from './Events.mjs';\nexport * from './Collection.mjs';\nexport * from './Model.mjs';\nexport * from './ViewBase.mjs';\nexport { default as Data } from './Data.mjs';\nexport { default as $ } from './Dom/index.mjs';\nexport * from './Dom/Event.mjs';\n", "import $ from './Dom/index.mjs';\n\nimport { Events } from './Events.mjs';\nimport { extend } from './mvcUtils.mjs';\nimport {\n    assign,\n    isFunction,\n    pick,\n    result,\n    uniqueId\n} from '../util/util.mjs';\n\n// ViewBase\n// -------------\n\n// ViewBases are almost more convention than they are actual code. A View\n// is simply a JavaScript object that represents a logical chunk of UI in the\n// DOM. This might be a single item, an entire list, a sidebar or panel, or\n// even the surrounding frame which wraps your whole app. Defining a chunk of\n// UI as a **View** allows you to define your DOM events declaratively, without\n// having to worry about render order ... and makes it easy for the view to\n// react to specific changes in the state of your models.\n\n// Creating a ViewBase creates its initial element outside of the DOM,\n// if an existing element is not provided...\nexport var ViewBase = function(options) {\n    this.cid = uniqueId('view');\n    this.preinitialize.apply(this, arguments);\n    assign(this, pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n};\n\n// Cached regex to split keys for `delegate`.\nvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n// List of view options to be set as properties.\n// TODO: `style` attribute is not supported in ViewBase class yet, but only in View class that extends ViewBase.\nvar viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events', 'style'];\n\n// Set up all inheritable **ViewBase** properties and methods.\nassign(ViewBase.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // mvc.$ delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n        return this.$el.find(selector);\n    },\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the View\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n        return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Events listeners.\n    remove: function() {\n        this._removeElement();\n        this.stopListening();\n        return this;\n    },\n\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function() {\n        this.$el.remove();\n    },\n\n    // Change the view's element (`this.el` property) and re-delegate the\n    // view's events on the new element.\n    setElement: function(element) {\n        this.undelegateEvents();\n        this._setElement(element);\n        this.delegateEvents();\n        return this;\n    },\n\n    // Creates the `this.el` and `this.$el` references for this view using the\n    // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$\n    // context or an element. Subclasses can override this to utilize an\n    // alternative DOM manipulation API and are only required to set the\n    // `this.el` property.\n    _setElement: function(el) {\n        this.$el = el instanceof $ ? el : $(el);\n        this.el = this.$el[0];\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    delegateEvents: function(events) {\n        events || (events = result(this, 'events'));\n        if (!events) return this;\n        this.undelegateEvents();\n        for (var key in events) {\n            var method = events[key];\n            if (!isFunction(method)) method = this[method];\n            if (!method) continue;\n            var match = key.match(delegateEventSplitter);\n            this.delegate(match[1], match[2], method.bind(this));\n        }\n        return this;\n    },\n\n    // Add a single event listener to the view's element (or a child element\n    // using `selector`). This only works for delegate-able events: not `focus`,\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n    delegate: function(eventName, selector, listener) {\n        this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n        return this;\n    },\n\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // viewbases attached to the same DOM element.\n    undelegateEvents: function() {\n        if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n        return this;\n    },\n\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\n    // `selector` and `listener` are both optional.\n    undelegate: function(eventName, selector, listener) {\n        this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n        return this;\n    },\n\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function(tagName) {\n        return document.createElement(tagName);\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n        if (!this.el) {\n            var attrs = assign({}, result(this, 'attributes'));\n            if (this.id) attrs.id = result(this, 'id');\n            if (this.className) attrs['class'] = result(this, 'className');\n            this.setElement(this._createElement(result(this, 'tagName')));\n            this._setAttributes(attrs);\n        } else {\n            this.setElement(result(this, 'el'));\n        }\n    },\n\n    // Set attributes from a hash on this view's element.  Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _setAttributes: function(attributes) {\n        this.$el.attr(attributes);\n    }\n\n});\n\n// Set up inheritance for the view.\nViewBase.extend = extend;\n", "import $ from './Dom/index.mjs';\nimport * as util from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { ViewBase } from './ViewBase.mjs';\nimport { config } from '../config/index.mjs';\n\nexport const views = {};\n\nexport const View = ViewBase.extend({\n\n    options: {},\n    theme: null,\n    themeClassNamePrefix: util.addClassNamePrefix('theme-'),\n    requireSetThemeOverride: false,\n    defaultTheme: config.defaultTheme,\n    children: null,\n    childNodes: null,\n\n    DETACHABLE: true,\n    UPDATE_PRIORITY: 2,\n    FLAG_INSERT: 1<<30,\n    FLAG_REMOVE: 1<<29,\n    FLAG_INIT: 1<<28,\n\n    constructor: function(options) {\n\n        this.requireSetThemeOverride = options && !!options.theme;\n        this.options = util.assign({}, this.options, options);\n\n        ViewBase.call(this, options);\n    },\n\n    initialize: function() {\n\n        views[this.cid] = this;\n\n        this.setTheme(this.options.theme || this.defaultTheme);\n        this.init();\n    },\n\n    unmount: function() {\n        if (this.svgElement) {\n            this.vel.remove();\n        } else {\n            this.$el.remove();\n        }\n    },\n\n    isMounted: function() {\n        return this.el.parentNode !== null;\n    },\n\n    renderChildren: function(children) {\n        children || (children = util.result(this, 'children'));\n        if (children) {\n            var isSVG = this.svgElement;\n            var namespace = V.namespace[isSVG ? 'svg' : 'xhtml'];\n            var doc = util.parseDOMJSON(children, namespace);\n            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n            this.childNodes = doc.selectors;\n        }\n        return this;\n    },\n\n    findAttributeNode: function(attributeName, node) {\n        let currentNode = node;\n        while (currentNode && currentNode.nodeType === 1) {\n            // attribute found\n            // (empty value does not count as attribute found)\n            if (currentNode.getAttribute(attributeName)) return currentNode;\n            // do not climb up the DOM\n            if (currentNode === this.el) return null;\n            // try parent node\n            currentNode = currentNode.parentNode;\n        }\n        return null;\n    },\n\n    findAttribute: function(attributeName, node) {\n        const matchedNode = this.findAttributeNode(attributeName, node);\n        return matchedNode && matchedNode.getAttribute(attributeName);\n    },\n\n    // Override the mvc ViewBase `_ensureElement()` method in order to create an\n    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n    // Expose class name setter as a separate method.\n    _ensureElement: function() {\n        if (!this.el) {\n            var tagName = util.result(this, 'tagName');\n            var attrs = util.assign({}, util.result(this, 'attributes'));\n            var style = util.assign({}, util.result(this, 'style'));\n            if (this.id) attrs.id = util.result(this, 'id');\n            this.setElement(this._createElement(tagName));\n            this._setAttributes(attrs);\n            this._setStyle(style);\n        } else {\n            this.setElement(util.result(this, 'el'));\n        }\n        this._ensureElClassName();\n    },\n\n    _setAttributes: function(attrs) {\n        if (this.svgElement) {\n            this.vel.attr(attrs);\n        } else {\n            this.$el.attr(attrs);\n        }\n    },\n\n    _setStyle: function(style) {\n        this.$el.css(style);\n    },\n\n    _createElement: function(tagName) {\n        if (this.svgElement) {\n            return document.createElementNS(V.namespace.svg, tagName);\n        } else {\n            return document.createElement(tagName);\n        }\n    },\n\n    // Utilize an alternative DOM manipulation API by\n    // adding an element reference wrapped in Vectorizer.\n    _setElement: function(el) {\n        this.$el = el instanceof $ ? el : $(el);\n        this.el = this.$el[0];\n        if (this.svgElement) this.vel = V(this.el);\n    },\n\n    _ensureElClassName: function() {\n        var className = util.result(this, 'className');\n        if (!className) return;\n        var prefixedClassName = util.addClassNamePrefix(className);\n        // Note: className removal here kept for backwards compatibility only\n        if (this.svgElement) {\n            this.vel.removeClass(className).addClass(prefixedClassName);\n        } else {\n            this.$el.removeClass(className).addClass(prefixedClassName);\n        }\n    },\n\n    init: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    onRender: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    confirmUpdate: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        return 0;\n    },\n\n    setTheme: function(theme, opt) {\n\n        opt = opt || {};\n\n        // Theme is already set, override is required, and override has not been set.\n        // Don't set the theme.\n        if (this.theme && this.requireSetThemeOverride && !opt.override) {\n            return this;\n        }\n\n        this.removeThemeClassName();\n        this.addThemeClassName(theme);\n        this.onSetTheme(this.theme/* oldTheme */, theme/* newTheme */);\n        this.theme = theme;\n\n        return this;\n    },\n\n    addThemeClassName: function(theme) {\n\n        theme = theme || this.theme;\n        if (!theme) return this;\n\n        var className = this.themeClassNamePrefix + theme;\n\n        if (this.svgElement) {\n            this.vel.addClass(className);\n        } else {\n            this.$el.addClass(className);\n        }\n\n        return this;\n    },\n\n    removeThemeClassName: function(theme) {\n\n        theme = theme || this.theme;\n\n        var className = this.themeClassNamePrefix + theme;\n\n        if (this.svgElement) {\n            this.vel.removeClass(className);\n        } else {\n            this.$el.removeClass(className);\n        }\n\n        return this;\n    },\n\n    onSetTheme: function(oldTheme, newTheme) {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    remove: function() {\n\n        this.onRemove();\n        this.undelegateDocumentEvents();\n\n        views[this.cid] = null;\n\n        ViewBase.prototype.remove.apply(this, arguments);\n\n        return this;\n    },\n\n    onRemove: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    getEventNamespace: function() {\n        // Returns a per-session unique namespace\n        return '.joint-event-ns-' + this.cid;\n    },\n\n    delegateElementEvents: function(element, events, data) {\n        if (!events) return this;\n        data || (data = {});\n        var eventNS = this.getEventNamespace();\n        for (var eventName in events) {\n            var method = events[eventName];\n            if (typeof method !== 'function') method = this[method];\n            if (!method) continue;\n            $(element).on(eventName + eventNS, data, method.bind(this));\n        }\n        return this;\n    },\n\n    undelegateElementEvents: function(element) {\n        $(element).off(this.getEventNamespace());\n        return this;\n    },\n\n    delegateDocumentEvents: function(events, data) {\n        events || (events = util.result(this, 'documentEvents'));\n        return this.delegateElementEvents(document, events, data);\n    },\n\n    undelegateDocumentEvents: function() {\n        return this.undelegateElementEvents(document);\n    },\n\n    eventData: function(evt, data) {\n        if (!evt) throw new Error('eventData(): event object required.');\n        var currentData = evt.data;\n        var key = '__' + this.cid + '__';\n        if (data === undefined) {\n            if (!currentData) return {};\n            return currentData[key] || {};\n        }\n        currentData || (currentData = evt.data = {});\n        currentData[key] || (currentData[key] = {});\n        util.assign(currentData[key], data);\n        return this;\n    },\n\n    stopPropagation: function(evt) {\n        this.eventData(evt, { propagationStopped: true });\n        return this;\n    },\n\n    isPropagationStopped: function(evt) {\n        return !!this.eventData(evt).propagationStopped;\n    }\n\n}, {\n\n    extend: function() {\n\n        var args = Array.from(arguments);\n\n        // Deep clone the prototype and static properties objects.\n        // This prevents unexpected behavior where some properties are overwritten outside of this function.\n        var protoProps = args[0] && util.assign({}, args[0]) || {};\n        var staticProps = args[1] && util.assign({}, args[1]) || {};\n\n        // Need the real render method so that we can wrap it and call it later.\n        var renderFn = protoProps.render || (this.prototype && this.prototype.render) || null;\n\n        /*\n            Wrap the real render method so that:\n                .. `onRender` is always called.\n                .. `this` is always returned.\n        */\n        protoProps.render = function() {\n\n            if (typeof renderFn === 'function') {\n                // Call the original render method.\n                renderFn.apply(this, arguments);\n            }\n\n            if (this.render.__render__ === renderFn) {\n                // Should always call onRender() method.\n                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n                this.onRender();\n            }\n\n            // Should always return itself.\n            return this;\n        };\n\n        protoProps.render.__render__ = renderFn;\n\n        return ViewBase.extend.call(this, protoProps, staticProps);\n    }\n});\n", "import { Events } from './Events.mjs';\n\nexport class Listener {\n    constructor(...callbackArguments) {\n        this.callbackArguments = callbackArguments;\n    }\n\n    listenTo(object, evt, ...args) {\n        const { callbackArguments } = this;\n        // signature 1 - (object, eventHashMap, context)\n        if (evt && typeof evt === 'object') {\n            const [context = null] = args;\n            Object.entries(evt).forEach(([eventName, cb]) => {\n                if (typeof cb !== 'function') return;\n                // Invoke the callback with callbackArguments passed first\n                if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n                Events.listenTo.call(this, object, eventName, cb);\n            });\n        }\n        // signature 2 - (object, event, callback, context)\n        else if (typeof evt === 'string' && typeof args[0] === 'function') {\n            let [cb, context = null] = args;\n            // Invoke the callback with callbackArguments passed first\n            if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n            Events.listenTo.call(this, object, evt, cb);\n        }\n    }\n\n    stopListening() {\n        Events.stopListening.call(this);\n    }\n}\n", "import { Events } from './Events.mjs';\nimport { Model } from './Model.mjs';\nimport { extend, addMethodsUtil } from './mvcUtils.mjs';\nimport {\n    assign,\n    clone,\n    isFunction,\n    isString,\n    sortBy,\n    toArray\n} from '../util/util.mjs';\n\n\n// Collection\n// -------------------\n\n// If models tend to represent a single row of data, a Collection is\n// more analogous to a table full of data ... or a small slice or page of that\n// table, or a collection of rows that belong together for a particular reason\n// -- all of the messages in this particular folder, all of the documents\n// belonging to this particular author, and so on. Collections maintain\n// indexes of their models, both in order, and for lookup by `id`.\n\n// Create a new **Collection**, perhaps to contain a specific type of `model`.\n// If a `comparator` is specified, the Collection will maintain\n// its models in sort order, as they're added and removed.\nexport var Collection = function(models, options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, assign({ silent: true }, options));\n};\n\n// Default options for `Collection#set`.\nvar setOptions = { add: true, remove: true, merge: true };\nvar addOptions = { add: true, remove: false };\n\n// Splices `insert` into `array` at index `at`.\nvar splice = function(array, insert, at) {\n    at = Math.min(Math.max(at, 0), array.length);\n    var tail = Array(array.length - at);\n    var length = insert.length;\n    var i;\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n};\n\n// Define the Collection's inheritable methods.\nassign(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n        return this.map(function(model) { return model.toJSON(options); });\n    },\n\n    // Add a model, or list of models to the set. `models` may be\n    // Models or raw JavaScript objects to be converted to Models, or any\n    // combination of the two.\n    add: function(models, options) {\n        return this.set(models, assign({ merge: false }, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n        options = assign({}, options);\n        var singular = !Array.isArray(models);\n        models = singular ? [models] : models.slice();\n        var removed = this._removeModels(models, options);\n        if (!options.silent && removed.length) {\n            options.changes = { added: [], merged: [], removed: removed };\n            this.trigger('update', this, options);\n        }\n        return singular ? removed[0] : removed;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n        if (models == null) return;\n\n        options = assign({}, setOptions, options);\n\n        var singular = !Array.isArray(models);\n        models = singular ? [models] : models.slice();\n\n        var at = options.at;\n        if (at != null) at = +at;\n        if (at > this.length) at = this.length;\n        if (at < 0) at += this.length + 1;\n\n        var set = [];\n        var toAdd = [];\n        var toMerge = [];\n        var toRemove = [];\n        var modelMap = {};\n\n        var add = options.add;\n        var merge = options.merge;\n        var remove = options.remove;\n\n        var sort = false;\n        var sortable = this.comparator && at == null && options.sort !== false;\n        var sortAttr = isString(this.comparator) ? this.comparator : null;\n\n        // Turn bare objects into model references, and prevent invalid models\n        // from being added.\n        var model, i;\n        for (i = 0; i < models.length; i++) {\n            model = models[i];\n\n            // If a duplicate is found, prevent it from being added and\n            // optionally merge it into the existing model.\n            var existing = this.get(model);\n            if (existing) {\n                if (merge && model !== existing) {\n                    var attrs = this._isModel(model) ? model.attributes : model;\n                    existing.set(attrs, options);\n                    toMerge.push(existing);\n                    if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n                }\n                if (!modelMap[existing.cid]) {\n                    modelMap[existing.cid] = true;\n                    set.push(existing);\n                }\n                models[i] = existing;\n\n                // If this is a new, valid model, push it to the `toAdd` list.\n            } else if (add) {\n                model = models[i] = this._prepareModel(model, options);\n                if (model) {\n                    toAdd.push(model);\n                    this._addReference(model, options);\n                    modelMap[model.cid] = true;\n                    set.push(model);\n                }\n            }\n        }\n\n        // Remove stale models.\n        if (remove) {\n            for (i = 0; i < this.length; i++) {\n                model = this.models[i];\n                if (!modelMap[model.cid]) toRemove.push(model);\n            }\n            if (toRemove.length) this._removeModels(toRemove, options);\n        }\n\n        // See if sorting is needed, update `length` and splice in new models.\n        var orderChanged = false;\n        var replace = !sortable && add && remove;\n        if (set.length && replace) {\n            orderChanged = this.length !== set.length || this.models.some(function(m, index) {\n                return m !== set[index];\n            });\n            this.models.length = 0;\n            splice(this.models, set, 0);\n            this.length = this.models.length;\n        } else if (toAdd.length) {\n            if (sortable) sort = true;\n            splice(this.models, toAdd, at == null ? this.length : at);\n            this.length = this.models.length;\n        }\n\n        // Silently sort the collection if appropriate.\n        if (sort) this.sort({ silent: true });\n\n        // Unless silenced, it's time to fire all appropriate add/sort/update events.\n        if (!options.silent) {\n            for (i = 0; i < toAdd.length; i++) {\n                if (at != null) options.index = at + i;\n                model = toAdd[i];\n                model.trigger('add', model, this, options);\n            }\n            if (sort || orderChanged) this.trigger('sort', this, options);\n            if (toAdd.length || toRemove.length || toMerge.length) {\n                options.changes = {\n                    added: toAdd,\n                    removed: toRemove,\n                    merged: toMerge\n                };\n                this.trigger('update', this, options);\n            }\n        }\n\n        // Return the added (or merged) model (or models).\n        return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n        options = options ? clone(options) : {};\n        for (var i = 0; i < this.models.length; i++) {\n            this._removeReference(this.models[i], options);\n        }\n        options.previousModels = this.models;\n        this._reset();\n        models = this.add(models, assign({ silent: true }, options));\n        if (!options.silent) this.trigger('reset', this, options);\n        return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n        return this.add(model, assign({ at: this.length }, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n        var model = this.at(this.length - 1);\n        return this.remove(model, options);\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n        return this.add(model, assign({ at: 0 }, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n        var model = this.at(0);\n        return this.remove(model, options);\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n        return Array.prototype.slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id, cid, model object with id or cid\n    // properties, or an attributes object that is transformed through modelId.\n    get: function(obj) {\n        if (obj == null) return void 0;\n        return this._byId[obj] ||\n        this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] ||\n        obj.cid && this._byId[obj.cid];\n    },\n\n    // Returns `true` if the model is in the collection.\n    has: function(obj) {\n        return this.get(obj) != null;\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n        if (index < 0) index += this.length;\n        return this.models[index];\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n        var comparator = this.comparator;\n        if (!comparator) throw new Error('Cannot sort a set without a comparator');\n        options || (options = {});\n\n        var length = comparator.length;\n        if (isFunction(comparator)) comparator = comparator.bind(this);\n\n        // Run sort based on type of `comparator`.\n        if (length === 1 || isString(comparator)) {\n            this.models = this.sortBy(comparator);\n        } else {\n            this.models.sort(comparator);\n        }\n        if (!options.silent) this.trigger('sort', this, options);\n        return this;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n        return new this.constructor(this.models, {\n            model: this.model,\n            comparator: this.comparator\n        });\n    },\n\n    // Define how to uniquely identify models in the collection.\n    modelId: function(attrs, idAttribute) {\n        return attrs[idAttribute || this.model.prototype.idAttribute || 'id'];\n    },\n\n    // Get an iterator of all models in this collection.\n    values: function() {\n        return new CollectionIterator(this, ITERATOR_VALUES);\n    },\n\n    // Get an iterator of all model IDs in this collection.\n    keys: function() {\n        return new CollectionIterator(this, ITERATOR_KEYS);\n    },\n\n    // Get an iterator of all [ID, model] tuples in this collection.\n    entries: function() {\n        return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n    },\n\n    // Iterate over elements of the collection, and invoke fn for each element\n    each: function(fn, context) {\n        this.models.forEach(fn, context);\n    },\n\n    // Iterate over elements of collection, and return an array of all elements fn returns truthy for\n    filter: function(fn, context) {\n        return this.models.filter(fn, context);\n    },\n\n    find: function(fn, context) {\n        return this.models.find(fn, context);\n    },\n\n    findIndex: function(fn, context) {\n        return this.models.findIndex(fn, context);\n    },\n\n    // Return the first model of the collection\n    first: function() {\n        return this.models[0];\n    },\n\n    // Return true if value is in the collection\n    includes: function(value) {\n        return this.models.includes(value);\n    },\n\n    // Return the last model of the collection\n    last: function() {\n        return this.models[this.models.length - 1];\n    },\n\n    // Return true if collection has no elements\n    isEmpty: function() {\n        return !this.models.length;\n    },\n\n    // Create an array of values by running each element in the collection through fn\n    map: function(fn, context) {\n        return this.models.map(fn, context);\n    },\n\n    // Runs \"reducer\" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value\n    reduce: function(fn, initAcc = this.first()) {\n        return this.models.reduce(fn, initAcc);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n        this.length = 0;\n        this.models = [];\n        this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n        if (this._isModel(attrs)) {\n            if (!attrs.collection) attrs.collection = this;\n            return attrs;\n        }\n        options = options ? clone(options) : {};\n        options.collection = this;\n\n        var model;\n        if (this.model.prototype) {\n            model = new this.model(attrs, options);\n        } else {\n        // ES class methods didn't have prototype\n            model = this.model(attrs, options);\n        }\n\n        if (!model.validationError) return model;\n        this.trigger('invalid', this, model.validationError, options);\n        return false;\n    },\n\n    // Internal method called by both remove and set.\n    _removeModels: function(models, options) {\n        var removed = [];\n        for (var i = 0; i < models.length; i++) {\n            var model = this.get(models[i]);\n            if (!model) continue;\n\n            var index = this.models.indexOf(model);\n            this.models.splice(index, 1);\n            this.length--;\n\n            // Remove references before triggering 'remove' event to prevent an\n            // infinite loop. #3693\n            delete this._byId[model.cid];\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) delete this._byId[id];\n\n            if (!options.silent) {\n                options.index = index;\n                model.trigger('remove', model, this, options);\n            }\n\n            removed.push(model);\n            this._removeReference(model, options);\n        }\n        if (models.length > 0 && !options.silent) delete options.index;\n        return removed;\n    },\n\n    // Method for checking whether an object should be considered a model for\n    // the purposes of adding to the collection.\n    _isModel: function(model) {\n        return model instanceof Model;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n        this._byId[model.cid] = model;\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) this._byId[id] = model;\n        model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n        delete this._byId[model.cid];\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) delete this._byId[id];\n        if (this === model.collection) delete model.collection;\n        model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n        if (model) {\n            if ((event === 'add' || event === 'remove') && collection !== this) return;\n            if (event === 'changeId') {\n                var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n                var id = this.modelId(model.attributes, model.idAttribute);\n                if (prevId != null) delete this._byId[prevId];\n                if (id != null) this._byId[id] = model;\n            }\n        }\n        this.trigger.apply(this, arguments);\n    }\n\n});\n\n// Defining an @@iterator method implements JavaScript's Iterable protocol.\n// In modern ES2015 browsers, this value is found at Symbol.iterator.\nvar $$iterator = typeof Symbol === 'function' && Symbol.iterator;\nif ($$iterator) {\n    Collection.prototype[$$iterator] = Collection.prototype.values;\n}\n\n// CollectionIterator\n// ------------------\n\n// A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n// use of `for of` loops in modern browsers and interoperation between\n// Collection and other JavaScript functions and third-party libraries\n// which can operate on Iterables.\nvar CollectionIterator = function(collection, kind) {\n    this._collection = collection;\n    this._kind = kind;\n    this._index = 0;\n};\n\n// This \"enum\" defines the three possible kinds of values which can be emitted\n// by a CollectionIterator that correspond to the values(), keys() and entries()\n// methods on Collection, respectively.\nvar ITERATOR_VALUES = 1;\nvar ITERATOR_KEYS = 2;\nvar ITERATOR_KEYSVALUES = 3;\n\n// All Iterators should themselves be Iterable.\nif ($$iterator) {\n    CollectionIterator.prototype[$$iterator] = function() {\n        return this;\n    };\n}\n\nCollectionIterator.prototype.next = function() {\n    if (this._collection) {\n\n        // Only continue iterating if the iterated collection is long enough.\n        if (this._index < this._collection.length) {\n            var model = this._collection.at(this._index);\n            this._index++;\n\n            // Construct a value depending on what kind of values should be iterated.\n            var value;\n            if (this._kind === ITERATOR_VALUES) {\n                value = model;\n            } else {\n                var id = this._collection.modelId(model.attributes, model.idAttribute);\n                if (this._kind === ITERATOR_KEYS) {\n                    value = id;\n                } else { // ITERATOR_KEYSVALUES\n                    value = [id, model];\n                }\n            }\n            return { value: value, done: false };\n        }\n\n        // Once exhausted, remove the reference to the collection so future\n        // calls to the next method always return done.\n        this._collection = void 0;\n    }\n\n    return { value: void 0, done: true };\n};\n\n//  Methods that we want to implement on the Collection.\nvar collectionMethods = { toArray: 1, sortBy: 3 };\n\n\n// Mix in each method as a proxy to `Collection#models`.\n\nvar config = [ Collection, collectionMethods, 'models' ];\n\nfunction addMethods(config) {\n    var Base = config[0],\n        methods = config[1],\n        attribute = config[2];\n\n    const methodsToAdd = {\n        sortBy,\n        toArray\n    };\n\n    addMethodsUtil(Base, methodsToAdd, methods, attribute);\n}\n\naddMethods(config);\n\n// Set up inheritance for the collection.\nCollection.extend = extend;\n", "import * as mvc from '../mvc/index.mjs';\nimport V from '../V/index.mjs';\nimport { isPlainObject, result } from '../util/util.mjs';\n\nfunction toArray(obj) {\n    if (!obj) return [];\n    if (Array.isArray(obj)) return obj;\n    return [obj];\n}\n\nexport const HighlighterView = mvc.View.extend({\n\n    tagName: 'g',\n    svgElement: true,\n    className: 'highlight',\n\n    HIGHLIGHT_FLAG: 1,\n    UPDATE_PRIORITY: 3,\n    DETACHABLE: false,\n    UPDATABLE: true,\n    MOUNTABLE: true,\n\n    cellView: null,\n    nodeSelector: null,\n    node: null,\n    updateRequested: false,\n    postponedUpdate: false,\n    transformGroup: null,\n    detachedTransformGroup: null,\n\n    requestUpdate(cellView, nodeSelector) {\n        const { paper } = cellView;\n        this.cellView = cellView;\n        this.nodeSelector = nodeSelector;\n        if (paper) {\n            this.updateRequested = true;\n            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n        }\n    },\n\n    confirmUpdate() {\n        // The cellView is now rendered/updated since it has a higher update priority.\n        this.updateRequested = false;\n        const { cellView, nodeSelector } = this;\n        if (cellView.isMounted()) {\n            this.update(cellView, nodeSelector);\n            this.mount();\n            this.transform();\n        } else {\n            this.postponedUpdate = true;\n        }\n        return 0;\n    },\n\n    findNode(cellView, nodeSelector = null) {\n        let el;\n        if (typeof nodeSelector === 'string') {\n            el = cellView.findNode(nodeSelector);\n        } else if (isPlainObject(nodeSelector)) {\n            const isLink = cellView.model.isLink();\n            const { label = null, port, selector } = nodeSelector;\n            if (isLink && label !== null) {\n                // Link Label Selector\n                el = cellView.findLabelNode(label, selector);\n            } else if (!isLink && port) {\n                // Element Port Selector\n                el = cellView.findPortNode(port, selector);\n            } else {\n                // Cell Selector\n                el = cellView.findNode(selector);\n            }\n        } else if (nodeSelector) {\n            el = V.toNode(nodeSelector);\n            if (!(el instanceof SVGElement)) el = null;\n        }\n        return el ? el : null;\n    },\n\n    getNodeMatrix(cellView, node) {\n        const { options } = this;\n        const { layer } = options;\n        const { rotatableNode } = cellView;\n        const nodeMatrix = cellView.getNodeMatrix(node);\n        if (rotatableNode) {\n            if (layer) {\n                if (rotatableNode.contains(node)) {\n                    return nodeMatrix;\n                }\n                // The node is outside of the rotatable group.\n                // Compensate the rotation set by transformGroup.\n                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n            } else {\n                return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n            }\n        }\n        return nodeMatrix;\n    },\n\n    mount() {\n        const { MOUNTABLE, cellView, el, options, transformGroup, detachedTransformGroup, postponedUpdate, nodeSelector } = this;\n        if (!MOUNTABLE || transformGroup) return;\n        if (postponedUpdate) {\n            // The cellView was not mounted when the update was requested.\n            // The update was postponed until the cellView is mounted.\n            this.update(cellView, nodeSelector);\n            this.transform();\n            return;\n        }\n        const { vel: cellViewRoot, paper } = cellView;\n        const { layer: layerName } = options;\n        if (layerName) {\n            let vGroup;\n            if (detachedTransformGroup) {\n                vGroup = detachedTransformGroup;\n                this.detachedTransformGroup = null;\n            } else {\n                vGroup = V('g').addClass('highlight-transform').append(el);\n            }\n            this.transformGroup = vGroup;\n            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);\n        } else {\n            // TODO: prepend vs append\n            if (!el.parentNode || el.nextSibling) {\n                // Not appended yet or not the last child\n                cellViewRoot.append(el);\n            }\n        }\n    },\n\n    unmount() {\n        const { MOUNTABLE, transformGroup, vel } = this;\n        if (!MOUNTABLE) return;\n        if (transformGroup) {\n            this.transformGroup = null;\n            this.detachedTransformGroup = transformGroup;\n            transformGroup.remove();\n        } else {\n            vel.remove();\n        }\n    },\n\n    transform() {\n        const { transformGroup, cellView, updateRequested } = this;\n        if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n        const translateMatrix = cellView.getRootTranslateMatrix();\n        const rotateMatrix = cellView.getRootRotateMatrix();\n        const transformMatrix = translateMatrix.multiply(rotateMatrix);\n        transformGroup.attr('transform', V.matrixToTransformString(transformMatrix));\n    },\n\n    update() {\n        const { node: prevNode, cellView, nodeSelector, updateRequested, id } = this;\n        if (updateRequested) return;\n        this.postponedUpdate = false;\n        const node = this.node = this.findNode(cellView, nodeSelector);\n        if (prevNode) {\n            this.unhighlight(cellView, prevNode);\n        }\n        if (node) {\n            this.highlight(cellView, node);\n            this.mount();\n        } else {\n            this.unmount();\n            cellView.notify('cell:highlight:invalid', id, this);\n        }\n    },\n\n    onRemove() {\n        const { node, cellView, id, constructor } = this;\n        if (node) {\n            this.unhighlight(cellView, node);\n        }\n        this.unmount();\n        constructor._removeRef(cellView, id);\n    },\n\n    highlight(_cellView, _node) {\n        // to be overridden\n    },\n\n    unhighlight(_cellView, _node) {\n        // to be overridden\n    },\n\n    // Update Attributes\n\n    listenToUpdateAttributes(cellView) {\n        const attributes = result(this, 'UPDATE_ATTRIBUTES');\n        if (!Array.isArray(attributes) || attributes.length === 0) return;\n        this.listenTo(cellView.model, 'change', this.onCellAttributeChange);\n    },\n\n    onCellAttributeChange() {\n        const { cellView } = this;\n        if (!cellView) return;\n        const { model, paper } = cellView;\n        const attributes = result(this, 'UPDATE_ATTRIBUTES');\n        if (!attributes.some(attribute => model.hasChanged(attribute))) return;\n        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n    }\n\n}, {\n\n    _views: {},\n\n    // Used internally by CellView highlight()\n    highlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.add(cellView, node, id, opt);\n    },\n\n    // Used internally by CellView unhighlight()\n    unhighlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.remove(cellView, id);\n    },\n\n    get(cellView, id = null) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (id === null) {\n            // all highlighters\n            const views = [];\n            if (!refs) return views;\n            for (let hid in refs) {\n                const ref = refs[hid];\n                if (ref instanceof this) {\n                    views.push(ref);\n                }\n            }\n            return views;\n        } else {\n            // single highlighter\n            if (!refs) return null;\n            if (id in refs) {\n                const ref = refs[id];\n                if (ref instanceof this) return ref;\n            }\n            return null;\n        }\n    },\n\n    add(cellView, nodeSelector, id, opt = {}) {\n        if (!id) throw new Error('dia.HighlighterView: An ID required.');\n        // Search the existing view amongst all the highlighters\n        const previousView = HighlighterView.get(cellView, id);\n        if (previousView) previousView.remove();\n        const view = new this(opt);\n        view.id = id;\n        this._addRef(cellView, id, view);\n        view.requestUpdate(cellView, nodeSelector);\n        view.listenToUpdateAttributes(cellView);\n        return view;\n    },\n\n    _addRef(cellView, id, view) {\n        const { cid } = cellView;\n        const { _views } = this;\n        let refs = _views[cid];\n        if (!refs) refs = _views[cid] = {};\n        refs[id] = view;\n    },\n\n    _removeRef(cellView, id) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (!refs) return;\n        if (id) delete refs[id];\n        for (let _ in refs) return;\n        delete _views[cid];\n    },\n\n    remove(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            view.remove();\n        });\n    },\n\n    getAll(paper, id = null) {\n        const views = [];\n        const { _views } = this;\n        for (let cid in _views) {\n            for (let hid in _views[cid]) {\n                const view = _views[cid][hid];\n                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n                    views.push(view);\n                }\n            }\n        }\n        return views;\n    },\n\n    removeAll(paper, id = null) {\n        this.getAll(paper, id).forEach(view => view.remove());\n    },\n\n    update(cellView, id = null, dirty = false) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            if (dirty || view.UPDATABLE) view.update();\n        });\n    },\n\n    transform(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            if (view.UPDATABLE) view.transform();\n        });\n    },\n\n    unmount(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => view.unmount());\n    },\n\n    mount(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => view.mount());\n    },\n\n    uniqueId(node, opt = '') {\n        return V.ensureId(node) + JSON.stringify(opt);\n    }\n\n});\n", "import { assign } from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nexport const stroke = HighlighterView.extend({\n\n    tagName: 'path',\n    className: 'highlight-stroke',\n    attributes: {\n        'pointer-events': 'none',\n        'fill': 'none'\n    },\n\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            'stroke-width': 3,\n            'stroke': '#FEB663'\n        }\n    },\n\n    getPathData(cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = V(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n\n    highlightConnection(cellView) {\n        this.vel.attr('d', cellView.getSerializedConnection());\n    },\n\n    highlightNode(cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = this.getNodeMatrix(cellView, node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + (nodeBBox.width / 2);\n            const cy = nodeBBox.y + (nodeBBox.height / 2);\n            nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = V.createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            'd': this.getPathData(cellView, node),\n            'transform': V.matrixToTransformString(highlightMatrix)\n        });\n    },\n\n    highlight(cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (options.nonScalingStroke) {\n            vel.attr('vector-effect', 'non-scaling-stroke');\n        }\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n\n});\n", "import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nexport const mask = HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray',\n        'class',\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'class',\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = V('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n        // support both `strokeWidth` and `stroke-width` attribute names\n        const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  V('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return V('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const highlightMatrix = this.getNodeMatrix(cellView, node);\n        const maskEl = this.getMask(cellView, V(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': V.matrixToTransformString(highlightMatrix),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n", "import { HighlighterView } from '../dia/HighlighterView.mjs';\n\nexport const opacity = HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    highlight: function(_cellView, node) {\n        const { alphaValue = 0.3 } = this.options;\n        node.style.opacity = alphaValue;\n    },\n\n    unhighlight: function(_cellView, node) {\n        node.style.opacity = '';\n    }\n\n});\n", "import * as util from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst className = util.addClassNamePrefix('highlighted');\n\nexport const addClass = HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    options: {\n        className\n    },\n\n    highlight: function(_cellView, node) {\n        V(node).addClass(this.options.className);\n    },\n\n    unhighlight: function(_cellView, node) {\n        V(node).removeClass(this.options.className);\n    }\n\n}, {\n    // Backwards Compatibility\n    className\n});\n", "import { Rect } from '../g/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nimport {\n    normalizeSides,\n    isEqual,\n} from '../util/index.mjs';\nimport {\n    Positions,\n    getRectPoint,\n} from '../util/getRectPoint.mjs';\n\nconst Directions = {\n    ROW: 'row',\n    COLUMN: 'column'\n};\n\nexport const list = HighlighterView.extend({\n\n    tagName: 'g',\n    MOUNTABLE: true,\n    UPDATE_ATTRIBUTES: function() {\n        return [this.options.attribute];\n    },\n\n    _prevItems: null,\n\n    highlight(elementView, node) {\n        const element = elementView.model;\n        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;\n        if (!attribute) throw new Error('List: attribute is required');\n        const normalizedSize = (typeof size === 'number') ? { width: size, height: size } : size;\n        const isRowDirection = (direction === Directions.ROW);\n        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n        let items = element.get(attribute);\n        if (!Array.isArray(items)) items = [];\n        const prevItems = this._prevItems || [];\n        const comparison = items.map((item, index) => isEqual(prevItems[index], items[index]));\n        if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {\n            const prevEls = this.vel.children();\n            const itemsEls = items.map((item, index) => {\n                const prevEl = (index in prevEls) ? prevEls[index].node : null;\n                if (comparison[index]) return prevEl;\n                const itemEl = this.createListItem(item, normalizedSize, prevEl);\n                if (!itemEl) return null;\n                if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');\n                itemEl.dataset.index = index;\n                itemEl.dataset.attribute = attribute;\n                const offset = index * (itemWidth + gap);\n                itemEl.setAttribute('transform', (isRowDirection)\n                    ? `translate(${offset}, 0)`\n                    : `translate(0, ${offset})`\n                );\n                return itemEl;\n            });\n            this.vel.empty().append(itemsEls);\n            this._prevItems = items;\n        }\n        const itemsCount = items.length;\n        const length = (itemsCount === 0)\n            ? 0\n            : (itemsCount * itemWidth + (itemsCount - 1) * gap);\n        const listSize = (isRowDirection)\n            ? { width: length, height: normalizedSize.height }\n            : { width: normalizedSize.width, height: length };\n\n        this.position(element, listSize);\n    },\n\n    position(element, listSize) {\n        const { vel, options } = this;\n        const { margin = 5, position = 'top-left' } = options;\n        const { width, height } = element.size();\n        const { left, right, top, bottom } = normalizeSides(margin);\n        const bbox = new Rect(left, top, width - (left + right), height - (top + bottom));\n        let { x, y } = getRectPoint(bbox, position);\n        // x\n        switch (position) {\n            case Positions.CENTER:\n            case Positions.TOP:\n            case Positions.BOTTOM: {\n                x -= listSize.width / 2;\n                break;\n            }\n            case Positions.RIGHT:\n            case Positions.BOTTOM_RIGHT:\n            case Positions.TOP_RIGHT: {\n                x -= listSize.width;\n                break;\n            }\n        }\n        // y\n        switch (position) {\n            case Positions.CENTER:\n            case Positions.RIGHT:\n            case Positions.LEFT: {\n                y -= listSize.height / 2;\n                break;\n            }\n            case Positions.BOTTOM:\n            case Positions.BOTTOM_RIGHT:\n            case Positions.BOTTOM_LEFT: {\n                y -= listSize.height;\n                break;\n            }\n        }\n        vel.attr('transform', `translate(${x}, ${y})`);\n    }\n}, {\n    Directions,\n    Positions\n});\n", "import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n    if (util.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new g.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findNode(selector);\n    } else if (selector === false) {\n        node = magnet;\n    } else if (Array.isArray(selector)) {\n        node = util.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!V.isSVGGraphicsElement(node)) {\n        if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = V.transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof g.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof g.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof g.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;\n", "import * as util from '../util/index.mjs';\n\nfunction abs2rel(absolute, max) {\n\n    if (max === 0) return '0%';\n    // round to 3 decimal places\n    const dp = 1000;\n    const relative = Math.round(absolute / max * 100 * dp) / dp;\n    return `${relative}%`;\n}\n\nfunction pin(relative) {\n\n    return function(end, view, magnet, coords) {\n        var fn = (view.isNodeConnection(magnet)) ? pinnedLinkEnd : pinnedElementEnd;\n        return fn(relative, end, view, magnet, coords);\n    };\n}\n\nfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeUnrotatedBBox(magnet);\n    var origin = view.model.getBBox().center();\n    coords.rotate(origin, angle);\n    var dx = coords.x - bbox.x;\n    var dy = coords.y - bbox.y;\n\n    if (relative) {\n        dx = abs2rel(dx, bbox.width);\n        dy = abs2rel(dy, bbox.height);\n    }\n\n    end.anchor = {\n        name: 'topLeft',\n        args: {\n            dx: dx,\n            dy: dy,\n            rotate: true\n        }\n    };\n\n    return end;\n}\n\nfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\n    var connection = view.getConnection();\n    if (!connection) return end;\n    var length = connection.closestPointLength(coords);\n    if (relative) {\n        var totalLength = connection.length();\n        end.anchor = {\n            name: 'connectionRatio',\n            args: {\n                ratio: length / totalLength\n            }\n        };\n    } else {\n        end.anchor = {\n            name: 'connectionLength',\n            args: {\n                length: length\n            }\n        };\n    }\n    return end;\n}\n\nexport const useDefaults = util.noop;\nexport const pinAbsolute = pin(false);\nexport const pinRelative = pin(true);\n\n", "export * from './normal.mjs';\nexport * from './oneSide.mjs';\nexport * from './orthogonal.mjs';\nexport * from './manhattan.mjs';\nexport * from './metro.mjs';\nexport * from './rightAngle.mjs';\n", "// Does not make any changes to vertices.\n// Returns the arguments that are passed to it, unchanged.\nexport const normal = function(vertices, opt, linkView) {\n\n    return vertices;\n};\n", "import * as util from '../util/index.mjs';\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nexport const oneSide = function(vertices, opt, linkView) {\n\n    var side = opt.side || 'bottom';\n    var padding = util.normalizeSides(opt.padding || 40);\n\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n\n    var coordinate, dimension, direction;\n\n    switch (side) {\n        case 'bottom':\n            direction = 1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'top':\n            direction = -1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'left':\n            direction = -1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        case 'right':\n            direction = 1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        default:\n            throw new Error('Router: invalid side');\n    }\n\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n    // make link orthogonal (at least the first and last vertex).\n    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n\n    return [sourcePoint].concat(vertices, targetPoint);\n};\n", "import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n\n    var p = new g.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new g.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n\n    return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n\n    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n\n    if (from.x === to.x) return (from.y > to.y) ? 'N' : 'S';\n    if (from.y === to.y) return (from.x > to.x) ? 'W' : 'E';\n    return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n\n    return new g.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = util.normalizeSides(opt.padding || opt.elementPadding || 20);\n\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n\n    var p1 = new g.Point(from.x, to.y);\n    var p2 = new g.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n\n    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n\n    var p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n\n    var route = {};\n\n    var points = [new g.Point(from.x, to.y), new g.Point(to.x, from.y)];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n\n        route.points = [p];\n        route.direction = getBearing(p, to);\n\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n\n        p = util.difference(points, freePoints)[0];\n\n        var p2 = (new g.Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n\n        route.points = [p1, p2];\n        route.direction = getBearing(p2, to);\n    }\n\n    return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n\n        if (toBBox.containsPoint(p2)) {\n\n            var fromBorder = (new g.Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = (new g.Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = (new g.Line(fromBorder, toBorder)).midpoint();\n\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n            route.points = [startRoute.points[0], endRoute.points[0]];\n            route.direction = endRoute.direction;\n        }\n    }\n\n    return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n\n    var p1, p2, p3;\n\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = g.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n\n    if (p1.round().equals(p2.round())) {\n        p2 = g.Point.fromPolar(boundary.width + boundary.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n    } else {\n        route.points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n    return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nexport function orthogonal(vertices, opt, linkView) {\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n    vertices = util.toArray(vertices).map(g.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n\n    var bearing; // bearing of previous route segment\n\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n        var route = null;\n\n        var from = vertices[i];\n        var to = vertices[i + 1];\n\n        var isOrthogonal = !!getBearing(from, to);\n\n        if (i === 0) { // source\n\n            if (i + 1 === max) { // route source -> target\n\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n\n            } else { // route source -> vertex\n\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n\n        } else if (i + 1 === max) { // route vertex -> target\n\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n\n        } else if (!isOrthogonal) { // route vertex -> vertex\n            route = vertexVertex(from, to, bearing);\n        }\n\n        // applicable to all routes:\n\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n\n    return orthogonalVertices;\n}\n", "import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: [],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!util.isFunction(orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return orthogonal(vertices, util.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = util.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return util.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = util.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new g.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new g.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new g.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = util.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new g.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new g.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(p => !isPointObstacle(p));\n    endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = util.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for (var j = 0; j < startPoints.length; j++) {\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = util.result(opt, 'directions');\n    opt.penalties = util.result(opt, 'penalties');\n    opt.paddingBox = util.result(opt, 'paddingBox');\n    opt.padding = util.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = util.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new g.Point(0, 0);\n        var point2 = new g.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = g.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === 'function') {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point) => !map.isPointAccessible(point);\n    }\n\n    var oldVertices = util.toArray(vertices).map(g.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nexport const manhattan = function(vertices, opt, linkView) {\n    return router(vertices, util.assign({}, config, opt), linkView);\n};\n", "import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new g.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n        var l2 = new g.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nexport const metro = function(vertices, opt, linkView) {\n\n    if (!util.isFunction(manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return manhattan(vertices, util.assign({}, config, opt), linkView);\n};\n\n", "import * as g from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    ANCHOR_SIDE: 'anchor-side',\n    MAGNET_SIDE: 'magnet-side'\n};\n\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\n\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\n\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\n\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new g.Polyline(points).simplify({ threshold: 1 }).points;\n}\n\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n\n    let sourceSide;\n\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new g.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n\n    let targetSide;\n\n    if (!targetView) {\n        const targetLinkAnchorBBox = new g.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n\n    return [sourceSide, targetSide];\n}\n\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty > smy0) return Directions.TOP;\n    if (tx > smx1 && ty > smy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.BOTTOM;\n}\n\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty < smy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty < smy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.TOP;\n}\n\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= smx0 && ty < smy0) return Directions.LEFT;\n    if (tx >= smx0 && ty > smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.RIGHT;\n}\n\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= smx1 && ty < smy0) return Directions.RIGHT;\n    if (tx <= smx1 && ty > smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.LEFT;\n}\n\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n\n    switch (sourceSide) {\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\n\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n\n    switch (roundedAngle) {\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\n\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n\n    const isElement = view && view.model.isElement();\n\n    const {\n        x: x0,\n        y: y0,\n        width = 0,\n        height = 0\n    } = isElement ? g.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\n\nfunction pointDataFromVertex({ x, y }) {\n    const point = new g.Point(x, y);\n\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new g.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\n\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n\n    const { x0, y0, width, height } = pointData;\n\n    switch (side) {\n        case 'left':\n            outsidePoint.x = x0 - margin;\n            break;\n        case 'right':\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case 'top':\n            outsidePoint.y = y0 - margin;\n            break;\n        case 'bottom':\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n\n    return outsidePoint;\n}\n\nfunction createLoop(from, to, { dx = 0, dy = 0 }) {\n    const p1 = { x: from.point.x + dx, y: from.point.y + dy };\n    const p2 = { x: to.point.x + dx, y: to.point.y + dy };\n\n    return [from.point, p1, p2, to.point];\n}\n\nfunction loopSegment(from, to, connectionSegmentAngle, margin) {\n    // Find out the loop coordinates.\n    const angle = g.normalizeAngle(connectionSegmentAngle - 90);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (angle === 90) {\n        dy = -margin;\n    } else if (angle === 180) {\n        dx = -margin;\n    } else if (angle === 270) {\n        dy = margin;\n    } else if (angle === 0) {\n        dx = margin;\n    }\n\n    const loopRoute = createLoop(from, to, { dx, dy });\n\n    const secondCreatedPoint = loopRoute[2];\n    const loopEndSegment = new g.Line(to.point, secondCreatedPoint);\n    // The direction in which the loop should continue.\n    const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\n    return {\n        loopRoute,\n        continueDirection\n    };\n}\n\n// Calculates the distances along the horizontal axis for the left and right route.\nfunction getHorizontalDistance(source, target) {\n\n    const { x0: sx0, x1: sx1, outsidePoint: sourcePoint } = source;\n    const { x0: tx0, x1: tx1, outsidePoint: targetPoint } = target;\n\n    // Furthest left boundary\n    let leftBoundary = Math.min(sx0, tx0);\n    // Furthest right boundary\n    let rightBoundary = Math.max(sx1, tx1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const aboveShape = source.y0 < target.y0 ? source : target;\n        const belowShape = aboveShape === source ? target : source;\n\n        // The source and target anchors are on the top => then the `aboveShape` defines the boundary.\n        // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;\n\n        leftBoundary = boundaryDefiningShape.x0;\n        rightBoundary = boundaryDefiningShape.x1;\n    }\n\n    const { x: sox } = sourcePoint;\n    const { x: tox } = targetPoint;\n\n    // Calculate the distances for the left route\n    const leftDistance1 = Math.abs(sox - leftBoundary);\n    const leftDistance2 = Math.abs(tox - leftBoundary);\n    const leftD = leftDistance1 + leftDistance2;\n\n    // Calculate the distances for the right route\n    const rightDistance1 = Math.abs(sox - rightBoundary);\n    const rightDistance2 = Math.abs(tox - rightBoundary);\n    const rightD = rightDistance1 + rightDistance2;\n\n    return [leftD, rightD];\n}\n\n// Calculates the distances along the vertical axis for the top and bottom route.\nfunction getVerticalDistance(source, target) {\n\n    const { y0: sy0, y1: sy1, outsidePoint: sourcePoint } = source;\n    const { y0: ty0, y1: ty1, outsidePoint: targetPoint } = target;\n\n    // Furthest top boundary\n    let topBoundary = Math.min(sy0, ty0);\n    // Furthest bottom boundary\n    let bottomBoundary = Math.max(sy1, ty1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const leftShape = source.x0 < target.x0 ? source : target;\n        const rightShape = leftShape === source ? target : source;\n\n        // The source and target anchors are on the left => then the `leftShape` defines the boundary.\n        // The source and target anchors are on the right => then the `rightShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;\n\n        topBoundary = boundaryDefiningShape.y0;\n        bottomBoundary = boundaryDefiningShape.y1;  \n    }\n\n    const { y: soy } = sourcePoint;\n    const { y: toy } = targetPoint;\n\n    // Calculate the distances for the top route\n    const topDistance1 = Math.abs(soy - topBoundary);\n    const topDistance2 = Math.abs(toy - topBoundary);\n    const topD = topDistance1 + topDistance2;\n\n    // Calculate the distances for the bottom route\n    const bottomDistance1 = Math.abs(soy - bottomBoundary);\n    const bottomDistance2 = Math.abs(toy - bottomBoundary);\n    const bottomD = bottomDistance1 + bottomDistance2;\n\n    return [topD, bottomD];\n}\n\n// Inflate bbox in 3 directions depending on the direction of the anchor\n// don't inflate in the opposite direction of the anchor\nfunction moveAndExpandBBox(bbox, direction, margin) {\n    switch (direction) {\n        case Directions.LEFT:\n            bbox.inflate(0, margin).moveAndExpand({ x: -margin, width: margin });\n            break;\n        case Directions.RIGHT:\n            bbox.inflate(0, margin).moveAndExpand({ width: margin });\n            break;\n        case Directions.TOP:\n            bbox.inflate(margin, 0).moveAndExpand({ y: -margin, height: margin });\n            break;\n        case Directions.BOTTOM:\n            bbox.inflate(margin, 0).moveAndExpand({ height: margin });\n            break;\n    }\n\n    return bbox;\n}\n\nfunction routeBetweenPoints(source, target, opt = {}) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n    const { targetInSourceBBox = false } = opt;\n\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n\n    const [sourceSide, targetSide] = resolveSides(source, target);\n\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight }, targetMargin);\n\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n    const sourceBBox = new g.Rect(sx0, sy0, sourceWidth, sourceHeight);\n    const targetBBox = new g.Rect(tx0, ty0, targetWidth, targetHeight);\n    const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n    const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\n    const sourceForDistance = Object.assign({}, source, { x1: sx1, y1: sy1, outsidePoint: sourceOutsidePoint, direction: sourceSide });\n    const targetForDistance = Object.assign({}, target, { x1: tx1, y1: ty1, outsidePoint: targetOutsidePoint, direction: targetSide });\n\n    // Distances used to determine the shortest route along the connections on horizontal sides for\n    // bottom => bottom\n    // top => bottom\n    // bottom => top\n    // top => top\n    const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);\n\n    // Distances used to determine the shortest route along the connection on vertical sides for\n    // left => left\n    // left => right\n    // right => right\n    // right => left\n    const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);\n\n    // All possible combinations of source and target sides\n    if (sourceSide === 'left' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx0 < tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.min(sox, tmx0);\n                x2 = Math.max(tox, smx1);\n            \n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on minimal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on maximal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy },\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx1 > tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.max(sox, tmx1);\n                x2 = Math.min(tox, smx0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on maximal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on minimal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy0 < toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n\n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.min(soy, tmy0);\n                y2 = Math.max(toy, smy1);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on minimal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on maximal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy1 > toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n            \n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.max(soy, tmy1);\n                y2 = Math.min(toy, smy0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on maximal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on minimal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'top') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox)) ||\n            (soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.min(soy, toy) },\n                { x: tox, y: Math.min(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n\n        if (toy < soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox)) ||\n            (soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.max(soy, toy) },\n                { x: tox, y: Math.max(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n\n        if (toy > soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'left') {\n        const useUShapeConnection = \n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy)) ||\n            (sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.min(sox, tox), y: soy },\n                { x: Math.min(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n\n        if (tox > sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'right') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy)) ||\n            (sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.max(sox, tox), y: soy },\n                { x: Math.max(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n\n        if (tox <= sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox < tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox > tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }];\n        }\n\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox < tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox > tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x < smx1 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.min(smx0, tmx0);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy < toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const y = Math.min(soy - sourceMargin, toy);\n                const x = Math.min(smx0, tmx0);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Add the `sourceMargin` since the source anchor is above the target anchor\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy > toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.min(smy0, tmy0);\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.min(soy - sourceMargin, toy);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y }, // Path adjustment for right side start\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Adjust sourceMargin calculation since the source anchor is now on the right\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy > toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.min(smy0, tmy0);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy < toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    }\n}\n\nfunction getLoopCoordinates(direction, angle, margin) {\n    const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;\n\n    let dx = 0;\n    let dy = 0;\n\n    switch (g.normalizeAngle(Math.round(angle))) {\n        case 0:\n        case 90:\n            dx = isHorizontal ? 0 : margin;\n            dy = isHorizontal ? margin : 0;\n            break;\n        case 180:\n        case 270:\n            dx = isHorizontal ? 0 : -margin;\n            dy = isHorizontal ? -margin : 0;\n            break;\n    }\n\n    return { dx, dy };\n}\n\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\n    let resultVertices = [];\n\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n\n    const verticesData = vertices.map((v) => pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n\n    const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);\n    const isElement = sourcePoint.view && sourcePoint.view.model.isElement();\n    const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;\n    const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;\n\n    if (isVertexInside) {\n        const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);\n        const firstPointOverlap = outsidePoint.equals(firstVertex.point);\n\n        const alignsVertically = sourcePoint.point.x === firstVertex.point.x;\n        const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;\n\n        const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);\n        const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);\n\n        const firstSegment = new g.Line(sourcePoint.point, outsidePoint);\n        const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);\n\n        const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);\n\n        \n\n        if (firstPointOverlap) {\n            resultVertices.push(sourcePoint.point, firstVertex.point);\n            // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex\n            firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];\n        } else if (isVertexOnSegment || isVertexAlignedAndInside) {\n            // Case where there is a need to create a loop\n            const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new g.Line(sourcePoint.point, firstVertex.point));\n            const { dx, dy } = getLoopCoordinates(resolvedSourceDirection, angle, margin);\n\n            const loop = createLoop({ point: outsidePoint }, firstVertex, { dx, dy });\n            const secondCreatedPoint = loop[2];\n            const loopEndSegment = new g.Line(firstVertex.point, secondCreatedPoint);\n\n            const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n            firstVertex.direction = accessDirection;\n            resultVertices.push(...loop);\n        } else {\n            // No need to create a route, use the `routeBetweenPoints` to construct a route\n            firstVertex.direction = resolvedSourceDirection;\n            firstVertex.margin = margin;\n            resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, { targetInSourceBBox: true }), firstVertex.point);\n        }\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n\n    for (let i = 0; i < verticesData.length - 1; i++) {\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n\n        const connectionSegment = new g.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);\n            // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new g.Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);\n            // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n            // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];\n            // console.log(accessDirection);\n            // console.log(accessDirection2);\n            // if (accessDirection !== accessDirection2) {\n            //     console.log('error');\n            // }\n            // console.log('------------------');\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly\n                resultVertices.push(from.point, to.point);\n                const [, toDirection] = resolveSides(from, to);\n                to.direction = toDirection;\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute, continueDirection } = loopSegment(from, to, connectionSegmentAngle, margin);\n                to.direction = continueDirection;\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n\n            continue;\n        }\n\n        // Vertices are not aligned vertically nor horizontally\n        // so we need to route between them\n\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n\n        from.direction = fromDirection;\n        to.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n\n    const lastVertex = verticesData[verticesData.length - 1];\n\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);\n        const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);\n\n        // the last point of `simplified` array is the last defined vertex\n        // this will ensure that the last segment continues in a straight line\n        const simplified = simplifyPoints([...resultVertices, lastVertex.point]);\n        const simplifiedSegment = new g.Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);\n        const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));\n        const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];\n\n        const lastPointOverlap = outsidePoint.equals(lastVertex.point);\n\n        if (!lastPointOverlap || (lastPointOverlap && definedDirection === resolvedTargetDirection)) {\n\n            lastVertex.direction = definedDirection;\n\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\n            const lastSegment = new g.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\n            const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);\n\n            const alignsVertically = lastVertex.point.x === targetPoint.point.x;\n            const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;\n            const isVertexInside = targetBBox.containsPoint(lastVertex.point);\n\n            const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);\n            const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);\n\n            \n            if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {\n                // Handle special cases when the last vertex is inside the target element\n                // and in is aligned with the connection point => construct a loop\n                const { dx, dy } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);\n                lastSegmentRoute = createLoop(lastVertex, { point: outsidePoint }, { dx, dy });\n            } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {\n                lastVertex.margin = margin;\n                lastVertex.direction = resolvedTargetDirection;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const from = lastVertex;\n        const to = targetPoint;\n\n        const connectionSegment = new g.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints(resultVertices);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new g.Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly by adding the first point\n                // the target point is handled separately\n                resultVertices.push(from.point);\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute } = loopSegment(from, to, connectionSegmentAngle, margin);\n                // Remove the last point since it is the target that is handled separately\n                loopRoute.pop();\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n        } else {\n            // The last vertex and the target are not aligned vertically nor horizontally\n            // so we need to route between them\n            const [fromDirection, toDirection] = resolveDirection(from, to);\n\n            from.direction = fromDirection;\n            to.direction = toDirection;\n\n            resultVertices.push(...routeBetweenPoints(from, to));\n        }\n    }\n\n    return simplifyPoints(resultVertices);\n}\n\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n\n    return [sourceDirection, targetDirection];\n}\n\nrightAngleRouter.Directions = Directions;\n\nexport const rightAngle = rightAngleRouter;\n", "import * as util from '../util/index.mjs';\nimport { toRad } from '../g/index.mjs';\nimport { resolveRef } from '../linkAnchors/index.mjs';\n\nfunction bboxWrapper(method) {\n\n    return function(view, magnet, ref, opt) {\n\n        var rotate = !!opt.rotate;\n        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = util.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = util.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n\n        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n\n    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n        var dy = (refPoint.y - anchor.y);\n        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan(toRad(angle));\n        anchor.y += dy;\n    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n        var dx = (refPoint.x - anchor.x);\n        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan(toRad(angle));\n        anchor.x += dx;\n    }\n\n    return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n\n    if (rotate) refPoint.rotate(center, angle);\n\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch (side) {\n        case 'left':\n            anchor = bbox.leftMiddle();\n            break;\n        case 'right':\n            anchor = bbox.rightMiddle();\n            break;\n        case 'top':\n            anchor = bbox.topMiddle();\n            break;\n        case 'bottom':\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n\n    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nexport const center = bboxWrapper('center');\nexport const top = bboxWrapper('topMiddle');\nexport const bottom = bboxWrapper('bottomMiddle');\nexport const left = bboxWrapper('leftMiddle');\nexport const right = bboxWrapper('rightMiddle');\nexport const topLeft = bboxWrapper('origin');\nexport const topRight = bboxWrapper('topRight');\nexport const bottomLeft = bboxWrapper('bottomLeft');\nexport const bottomRight = bboxWrapper('corner');\nexport const perpendicular = resolveRef(_perpendicular);\nexport const midSide = resolveRef(_midSide);\nexport const modelCenter = _modelCenter;\n\n", "import { Line, Point } from '../g/index.mjs';\nimport { isPercentage } from '../util/index.mjs';\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n    var length = ('length' in opt) ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if ('fallbackAt' in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new Point();\n    return closestPoint;\n}\n\nexport function resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\n\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if (isPercentage(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n\n// joint.linkAnchors\nexport { connectionRatio, connectionLength };\nexport const connectionPerpendicular = resolveRef(_connectionPerpendicular);\nexport const connectionClosest = resolveRef(_connectionClosest);\n", "export * from './Graph.mjs';\nexport * from './attributes/index.mjs';\nexport * from './PaperLayer.mjs';\nexport * from './Cell.mjs';\nexport * from './CellView.mjs';\nexport * from './Element.mjs';\nexport * from './ElementView.mjs';\nexport * from './Link.mjs';\nexport * from './LinkView.mjs';\nexport * from './Paper.mjs';\nexport * from './ToolView.mjs';\nexport * from './ToolsView.mjs';\nexport * from './HighlighterView.mjs';\n", "import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nimport { Model } from '../mvc/Model.mjs';\nimport { Collection } from '../mvc/Collection.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\n\nconst GraphCells = Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */\n            this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        const collection = opt.collection;\n        const namespace = collection.cellNamespace;\n        const { type } = attrs;\n\n        // Find the model class based on the `type` attribute in the cell namespace\n        const ModelClass = util.getByPath(namespace, type, '.');\n        if (!ModelClass) {\n            throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n        }\n\n        return new ModelClass(attrs, opt);\n    },\n\n    _addReference: function(model, options) {\n        Collection.prototype._addReference.apply(this, arguments);\n        // If not in `dry` mode and the model does not have a graph reference yet,\n        // set the reference.\n        if (!options.dry && !model.graph) {\n            model.graph = this.graph;\n        }\n    },\n\n    _removeReference: function(model, options) {\n        Collection.prototype._removeReference.apply(this, arguments);\n        // If not in `dry` mode and the model has a reference to this exact graph,\n        // remove the reference.\n        if (!options.dry && model.graph === this.graph) {\n            model.graph = null;\n        }\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nexport const Graph = Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // JointJS automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells mvc collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function(opt = {}) {\n\n        // JointJS does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON(opt.cellAttributes);\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = util.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = util.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell) {\n\n        let attrs;\n        if (cell instanceof Model) {\n            attrs = cell.attributes;\n        } else {\n            attrs = cell;\n        }\n\n        if (!util.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = util.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = util.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            util.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n    },\n\n    transferCellEmbeds: function(sourceCell, targetCell, opt = {}) {\n\n        const batchName = 'transfer-embeds';\n        this.startBatch(batchName);\n\n        // Embed children of the source cell in the target cell.\n        const children = sourceCell.getEmbeddedCells();\n        targetCell.embed(children, { ...opt, reparent: true });\n\n        this.stopBatch(batchName);\n    },\n\n    transferCellConnectedLinks: function(sourceCell, targetCell, opt = {}) {\n\n        const batchName = 'transfer-connected-links';\n        this.startBatch(batchName);\n\n        // Reconnect all the links connected to the old cell to the new cell.\n        const connectedLinks = this.getConnectedLinks(sourceCell, opt);\n        connectedLinks.forEach((link) => {\n\n            if (link.getSourceCell() === sourceCell) {\n                link.prop(['source', 'id'], targetCell.id, opt);\n            }\n\n            if (link.getTargetCell() === sourceCell) {\n                link.prop(['target', 'id'], targetCell.id, opt);\n            }\n        });\n\n        this.stopBatch(batchName);\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isElement());\n    },\n\n    getLinks: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isLink());\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            util.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            util.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    util.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    util.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && util.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return util.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = util.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        util.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || util.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || util.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && util.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        util.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all cells at given point\n\n    findElementsAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getElements(), point, opt);\n    },\n\n    findLinksAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getLinks(), point, opt);\n    },\n\n    findCellsAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getCells(), point, opt);\n    },\n\n    _filterAtPoint: function(cells, point, opt = {}) {\n        return cells.filter(el => el.getBBox({ rotate: true }).containsPoint(point, opt));\n    },\n\n    // Find all cells in given area\n\n    findElementsInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getElements(), area, opt);\n    },\n\n    findLinksInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getLinks(), area, opt);\n    },\n\n    findCellsInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getCells(), area, opt);\n    },\n\n    _filterInArea: function(cells, area, opt = {}) {\n        const r = new g.Rect(area);\n        const { strict = false } = opt;\n        const method = strict ? 'containsRect' : 'intersect';\n        return cells.filter(el => r[method](el.getBBox({ rotate: true })));\n    },\n\n    // Find all cells under the given element.\n\n    findElementsUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getElements(), element, opt);\n    },\n\n    findLinksUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getLinks(), element, opt);\n    },\n\n    findCellsUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getCells(), element, opt);\n    },\n\n    _isValidElementUnderElement: function(el1, el2) {\n        return el1.id !== el2.id && !el1.isEmbeddedIn(el2);\n    },\n\n    _isValidLinkUnderElement: function(link, el) {\n        return (\n            link.source().id !== el.id &&\n            link.target().id !== el.id &&\n            !link.isEmbeddedIn(el)\n        );\n    },\n\n    _validateCellsUnderElement: function(cells, element) {\n        return cells.filter(cell => {\n            return cell.isLink()\n                ? this._isValidLinkUnderElement(cell, element)\n                : this._isValidElementUnderElement(cell, element);\n        });\n    },\n\n    _getFindUnderElementGeometry: function(element, searchBy = 'bbox') {\n        const bbox = element.getBBox({ rotate: true });\n        return (searchBy !== 'bbox') ? util.getRectPoint(bbox, searchBy) : bbox;\n    },\n\n    _filterCellsUnderElement: function(cells, element, opt = {}) {\n        const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);\n        const filteredCells = (geometry.type === g.types.Point)\n            ? this._filterAtPoint(cells, geometry)\n            : this._filterInArea(cells, geometry, opt);\n        return this._validateCellsUnderElement(filteredCells, element);\n    },\n\n    // @deprecated use `findElementsInArea` instead\n    findModelsInArea: function(area, opt) {\n        return this.findElementsInArea(area, opt);\n    },\n\n    // @deprecated use `findElementsAtPoint` instead\n    findModelsFromPoint: function(point) {\n        return this.findElementsAtPoint(point);\n    },\n\n    // @deprecated use `findModelsUnderElement` instead\n    findModelsUnderElement: function(element, opt) {\n        return this.findElementsUnderElement(element, opt);\n    },\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return util.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({ rotate });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        util.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', util.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', util.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n", "import { View } from '../mvc/index.mjs';\nimport { addClassNamePrefix } from '../util/util.mjs';\n\nexport const LayersNames = {\n    GRID: 'grid',\n    CELLS: 'cells',\n    BACK: 'back',\n    FRONT: 'front',\n    TOOLS: 'tools',\n    LABELS: 'labels'\n};\n\nexport const PaperLayer = View.extend({\n\n    tagName: 'g',\n    svgElement: true,\n    pivotNodes: null,\n    defaultTheme: null,\n\n    options: {\n        name: ''\n    },\n\n    className: function() {\n        return addClassNamePrefix(`${this.options.name}-layer`);\n    },\n\n    init: function() {\n        this.pivotNodes = {};\n    },\n\n    insertSortedNode: function(node, z) {\n        this.el.insertBefore(node, this.insertPivot(z));\n    },\n\n    insertNode: function(node) {\n        const { el } = this;\n        if (node.parentNode !== el) {\n            el.appendChild(node);\n        }\n    },\n\n    insertPivot: function(z) {\n        const { el, pivotNodes } = this;\n        z = +z;\n        z || (z = 0);\n        let pivotNode = pivotNodes[z];\n        if (pivotNode) return pivotNode;\n        pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));\n        let neighborZ = -Infinity;\n        for (let currentZ in pivotNodes) {\n            currentZ = +currentZ;\n            if (currentZ < z && currentZ > neighborZ) {\n                neighborZ = currentZ;\n                if (neighborZ === z - 1) continue;\n            }\n        }\n        if (neighborZ !== -Infinity) {\n            const neighborPivot = pivotNodes[neighborZ];\n            // Insert After\n            el.insertBefore(pivotNode, neighborPivot.nextSibling);\n        } else {\n            // First Child\n            el.insertBefore(pivotNode, el.firstChild);\n        }\n        return pivotNode;\n    },\n\n    removePivots: function() {\n        const { el, pivotNodes } = this;\n        for (let z in pivotNodes) el.removeChild(pivotNodes[z]);\n        this.pivotNodes = {};\n    }\n\n});\n", "import { isCalcExpression, evalCalcExpression } from '../../util/calc.mjs';\n\nconst calcAttributesList = [\n    'transform',\n    'x',\n    'y',\n    'cx',\n    'cy',\n    'dx',\n    'dy',\n    'x1',\n    'y1',\n    'x2',\n    'y2',\n    'points',\n    'd',\n    'r',\n    'rx',\n    'ry',\n    'width',\n    'height',\n    'stroke-width',\n    'font-size',\n];\n\nconst positiveValueList = [\n    'r',\n    'rx',\n    'ry',\n    'width',\n    'height',\n    'stroke-width',\n    'font-size',\n];\n\nconst calcAttributes = calcAttributesList.reduce((acc, attrName) => {\n    acc[attrName] = true;\n    return acc;\n}, {});\n\nconst positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {\n    acc[attrName] = true;\n    return acc;\n}, {});\n\nexport function evalAttributes(attrs, refBBox) {\n    const evalAttrs = {};\n    for (let attrName in attrs) {\n        if (!attrs.hasOwnProperty(attrName)) continue;\n        evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);\n    }\n    return evalAttrs;\n}\n\nexport function evalAttribute(attrName, attrValue, refBBox) {\n    if (attrName in calcAttributes && isCalcExpression(attrValue)) {\n        let evalAttrValue = evalCalcExpression(attrValue, refBBox);\n        if (attrName in positiveValueAttributes) {\n            evalAttrValue = Math.max(0, evalAttrValue);\n        }\n        return evalAttrValue;\n    }\n    return attrValue;\n}\n", "import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport {\n    assign,\n    guid,\n    omit,\n    parseDOMJSON,\n    isFunction,\n    isObject,\n    isPlainObject,\n    isBoolean,\n    isEmpty,\n    isString,\n    result,\n    sortedIndex,\n    merge,\n    uniq\n} from '../util/index.mjs';\nimport { Point, Rect, intersection } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from '../mvc/Dom/index.mjs';\nimport { HighlighterView } from './HighlighterView.mjs';\nimport { evalAttributes, evalAttribute } from './attributes/eval.mjs';\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\nconst Flags = {\n    TOOLS: 'TOOLS',\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = result(this, 'presentationAttributes');\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = result(this, 'initFlag');\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || guid(this);\n\n        View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        this.startListening();\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = parseDOMJSON(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = isFunction(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return (isObject(interactive) && interactive[feature] !== false) ||\n            (isBoolean(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (this.useCSSSelectors) return $(root).find(selector).toArray();\n\n        return [];\n    },\n\n    findNodes: function(selector) {\n        return this.findBySelector(selector, this.el, this.selectors);\n    },\n\n    findNode: function(selector) {\n        const [node = null] = this.findNodes(selector);\n        return node;\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        const rect = this.getNodeBoundingRect(magnet);\n        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n        const magnetMatrix = this.getNodeMatrix(magnet);\n        return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n    },\n\n    getNodeRotateMatrix(node) {\n        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n            // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n        }\n        // Nodes outside the rotatable group\n        return V.createSVGMatrix();\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = V.createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = V.createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            node = this.findNode(el) || rootNode;\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const proxyNode = this.findNode(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = V(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        const model = this.model;\n        const id = model.id;\n        // Find a node with the `port` attribute set on it.\n        const portNode = this.findAttributeNode('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        const selector = magnet.getAttribute('joint-selector');\n\n        const end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (portNode != null) {\n            let port = portNode.getAttribute('port');\n            if (portNode.getAttribute('port-id-type') === 'number') {\n                port = parseInt(port, 10);\n            }\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || this.el;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findNode(selector);\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch('add-link');\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView });\n    },\n\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!isEmpty(attrs)) {\n            if (node instanceof SVGElement) {\n                V(node).attr(attrs);\n            } else {\n                $(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        const rawAttrs = {};\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            rawAttrs[V.attributeNames[attrName]] = attrs[attrName];\n        }\n        // divide the attributes between normal and special\n        for (attrName in rawAttrs) {\n            if (!rawAttrs.hasOwnProperty(attrName)) continue;\n            attrVal = rawAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def) {\n                if (attrVal === null) {\n                    // Assign the unset attribute name.\n                    let unsetAttrName;\n                    if (isFunction(def.unset)) {\n                        unsetAttrName = def.unset.call(this, node, rawAttrs, this);\n                    } else {\n                        unsetAttrName = def.unset;\n                    }\n                    if (!unsetAttrName && isString(def.set)) {\n                        // We unset an alias attribute.\n                        unsetAttrName = def.set;\n                    }\n                    if (!unsetAttrName) {\n                        // There is no alias for the attribute. We unset the attribute itself.\n                        unsetAttrName = attrName;\n                    }\n                    // Unset the attribute.\n                    if (isString(unsetAttrName) && unsetAttrName) {\n                        // Unset a single attribute.\n                        normalAttrs || (normalAttrs = {});\n                        // values takes precedence over unset values\n                        if (unsetAttrName in normalAttrs) continue;\n                        normalAttrs[unsetAttrName] = attrVal;\n                    } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {\n                        // Unset multiple attributes.\n                        normalAttrs || (normalAttrs = {});\n                        for (i = 0, n = unsetAttrName.length; i < n; i++) {\n                            const attrName = unsetAttrName[i];\n                            // values takes precedence over unset values\n                            if (attrName in normalAttrs) continue;\n                            normalAttrs[attrName] = attrVal;\n                        }\n                    }\n                    // The unset value is neither a string nor an array.\n                    // The attribute is not unset.\n                } else {\n                    if (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {\n                        if (isString(def.set)) {\n                            // An alias e.g 'xlink:href' -> 'href'\n                            normalAttrs || (normalAttrs = {});\n                            normalAttrs[def.set] = attrVal;\n                        }\n                        relatives.push(attrName, def);\n                    } else {\n                        normalAttrs || (normalAttrs = {});\n                        normalAttrs[attrName] = attrVal;\n                    }\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[attrName] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if (isFunction(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: rawAttrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);\n        var nodeAttrs = attrs.normal || {};\n        for (const nodeAttrName in nodeAttrs) {\n            nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n        }\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if (isObject(setResult)) {\n                assign(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = omit(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if (translation) {\n                nodePosition.offset(Point(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = evalAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n                    if (translation) {\n                        nodePosition.offset(Point(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    cleanNodeCache: function(node) {\n        const id = node.id;\n        if (!id) return;\n        delete this.metrics[id];\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = V.ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n        return new Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        const metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            const { rotatableNode, el } = this;\n            let target;\n            if (rotatableNode && rotatableNode.contains(magnet)) {\n                target = rotatableNode;\n            } else {\n                target = el;\n            }\n            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n        }\n        return V.createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = V.ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = sortedIndex(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (\n            // Explicitly defined `fromPoint` option\n            opt.fromPoint ||\n            // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n            // It holds the element when a touchstart triggered.\n            type === 'touchmove' || type === 'touchend' ||\n            // Pointermove/Pointerup event with the pointer captured\n            ('pointerId' in evt && target.hasPointerCapture(evt.pointerId))\n        ) {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = Rect());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        for (let i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            const refNodeId = refNode ? V.ensureId(refNode) : '';\n            let refBBox = bboxCache[refNodeId];\n            if (!refBBox) {\n                // Get the bounding box of the reference element using to the common ancestor\n                // transformation space.\n                //\n                // @example 1\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                //     <rect @selector=\"a\"/>\n                // </g>\n                //\n                // In this case, the reference bounding box can not be affected\n                // by the `transform` attribute of the `<g>` element,\n                // because the exact transformation will be applied to the `a` element\n                // as well as to the `b` element.\n                //\n                // @example 2\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                // </g>\n                // <rect @selector=\"a\"/>\n                //\n                // In this case, the reference bounding box have to be affected by the\n                // `transform` attribute of the `<g>` element, because the `a` element\n                // is not descendant of the `<g>` element and will not be affected\n                // by the transformation.\n                refBBox = bboxCache[refNodeId] = (refNode)\n                    ? V(refNode).getBBox({ target: getCommonAncestorNode(node, refNode) })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        assign(processedAttrs.set, roProcessedAttrs.set);\n        assign(processedAttrs.position, roProcessedAttrs.position);\n        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    // Lifecycle methods\n\n    // Called when the view is attached to the DOM,\n    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n    onMount(isInitialMount) {\n        if (isInitialMount) return;\n        this.mountTools();\n        HighlighterView.mount(this);\n    },\n\n    // Called when the view is detached from the DOM,\n    // as result of `paper.options.viewport` returning `false`.\n    onDetach() {\n        this.unmountTools();\n        HighlighterView.unmount(this);\n    },\n\n    // Called when the view is removed from the DOM\n    // as result of `cell.remove()`.\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    unmountTools() {\n        const toolsView = this._toolsView;\n        if (toolsView) toolsView.unmount();\n        return this;\n    },\n\n    mountTools() {\n        const toolsView = this._toolsView;\n        // Prevent unnecessary re-appending of the tools.\n        if (toolsView && !toolsView.isMounted()) toolsView.mount();\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    preventDefaultInteraction(evt) {\n        this.eventData(evt, { defaultInteractionPrevented: true  });\n    },\n\n    isDefaultInteractionPrevented(evt) {\n        const { defaultInteractionPrevented = false } = this.eventData(evt);\n        return defaultInteractionPrevented;\n    },\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper, model } = this;\n        if (paper.isAsync()) {\n            // Make sure the source/target views are updated before this view.\n            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n            // The connected cells could be links as well. In that case, we would\n            // need to recursively go through all the connected links and update\n            // their source/target views as well.\n            if (model.isLink()) {\n                // The `this.sourceView` and `this.targetView` might not be updated yet.\n                // We need to find the view by the model.\n                const sourceElement = model.getSourceElement();\n                if (sourceElement) {\n                    const sourceView = paper.findViewByModel(sourceElement);\n                    if (sourceView) {\n                        paper.dumpView(sourceView);\n                        paper.checkViewVisibility(sourceView);\n                    }\n                }\n                const targetElement = model.getTargetElement();\n                if (targetElement) {\n                    const targetView = paper.findViewByModel(targetElement);\n                    if (targetView) {\n                        paper.dumpView(targetView);\n                        paper.checkViewVisibility(targetView);\n                    }\n                }\n            }\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n            paper.checkViewVisibility(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    },\n\n    isIntersecting: function(geometryShape, geometryData) {\n        return intersection.exists(geometryShape, this.getNodeBBox(this.el), geometryData);\n    },\n\n    isEnclosedIn: function(geometryRect) {\n        return geometryRect.containsRect(this.getNodeBBox(this.el));\n    },\n\n    isInArea: function(geometryRect, options = {}) {\n        if (options.strict) {\n            return this.isEnclosedIn(geometryRect);\n        }\n        return this.isIntersecting(geometryRect);\n    },\n\n    isAtPoint: function(point, options) {\n        return this.getNodeBBox(this.el).containsPoint(point, options);\n    }\n\n}, {\n\n    Flags,\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n        });\n    },\n\n    evalAttribute,\n\n});\n\n\nObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n    get() {\n        const localUse = this.model.useCSSSelectors;\n        if (localUse !== undefined) return localUse;\n        return config.useCSSSelectors;\n    }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n    let parent = node1;\n    do {\n        if (parent.contains(node2)) return parent;\n        parent = parent.parentNode;\n    } while (parent);\n    return null;\n}\n\n\n", "import { assign, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs';\n\nconst Flags = {\n    TOOLS: CellView.Flags.TOOLS,\n    UPDATE: 'UPDATE',\n    TRANSLATE: 'TRANSLATE',\n    RESIZE: 'RESIZE',\n    PORTS: 'PORTS',\n    ROTATE: 'ROTATE',\n    RENDER: 'RENDER'\n};\n\nconst DragActions = {\n    MOVE: 'move',\n    MAGNET: 'magnet',\n};\n// Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n\n    /**\n     * @abstract\n     */\n    _removePorts: function() {\n        // implemented in ports.js\n    },\n\n    /**\n     *\n     * @abstract\n     */\n    _renderPorts: function() {\n        // implemented in ports.js\n    },\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('element');\n\n        return classNames.join(' ');\n    },\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        this._initializePorts();\n    },\n\n    presentationAttributes: {\n        'attrs': [Flags.UPDATE],\n        'position': [Flags.TRANSLATE, Flags.TOOLS],\n        'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n        'angle': [Flags.ROTATE, Flags.TOOLS],\n        'markup': [Flags.RENDER],\n        'ports': [Flags.PORTS],\n    },\n\n    initFlag: [Flags.RENDER],\n\n    UPDATE_PRIORITY: 0,\n\n    confirmUpdate: function(flag, opt) {\n\n        const { useCSSSelectors } = this;\n        if (this.hasFlag(flag, Flags.PORTS)) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, Flags.RENDER)) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n        } else {\n            let updateHighlighters = false;\n\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, Flags.RESIZE)) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n                if (useCSSSelectors) {\n                    // `resize()` rendered the ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.UPDATE)) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, Flags.UPDATE);\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.TRANSLATE)) {\n                this.translate();\n                flag = this.removeFlag(flag, Flags.TRANSLATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.ROTATE)) {\n                this.rotate();\n                flag = this.removeFlag(flag, Flags.ROTATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.PORTS)) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, Flags.PORTS);\n            }\n\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n\n        if (this.hasFlag(flag, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, Flags.TOOLS);\n        }\n\n        return flag;\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    update: function(_, renderingOnlyAttrs) {\n\n        this.cleanNodesCache();\n\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = this;\n        if (useCSSSelectors) this._removePorts();\n\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n        });\n\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n\n    rotatableSelector: 'rotatable',\n    scalableSelector: 'scalable',\n    scalableNode: null,\n    rotatableNode: null,\n\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n\n        var element = this.model;\n        var markup = element.get('markup') || element.markup;\n        if (!markup) throw new Error('dia.ElementView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.ElementView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = V(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        var vel = this.vel;\n        vel.append(V(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne('.rotatable');\n        this.scalableNode = vel.findOne('.scalable');\n\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n\n    render: function() {\n\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!this.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n\n    resize: function(opt) {\n\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n\n    translate: function() {\n\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n\n    rotate: function() {\n\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n\n    updateTransformation: function() {\n\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += ' ' + rotateString;\n        this.vel.attr('transform', transformation);\n    },\n\n    getTranslateString: function() {\n\n        const { x, y } = this.model.position();\n        return `translate(${x},${y})`;\n    },\n\n    getRotateString: function() {\n\n        const angle = this.model.angle();\n        if (!angle) return null;\n        const { width, height } = this.model.size();\n        return `rotate(${angle},${width / 2},${height / 2})`;\n    },\n\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n\n    rgRotate: function() {\n\n        this.rotatableNode.attr('transform', this.getRotateString());\n    },\n\n    rgTranslate: function() {\n\n        this.vel.attr('transform', this.getTranslateString());\n    },\n\n    sgResize: function(opt) {\n\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = (size.width / (scalableBBox.width || 1));\n        var sy = (size.height / (scalableBBox.height || 1));\n        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr('transform');\n        if (rotation) {\n\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, assign({ updateHandled: true }, opt));\n            this.translate();\n            this.rotate();\n        }\n\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n\n    // Embedding mode methods.\n    // -----------------------\n\n    prepareEmbedding: function(data = {}) {\n\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n\n        const initialZIndices = data.initialZIndices = {};\n        const embeddedCells = element.getEmbeddedCells({ deep: true });\n        const connectedLinks = graph.getConnectedLinks(element, { deep: true, includeEnclosed: true });\n\n        // Note: an embedded cell can be a connect link, but it's fine\n        // to iterate over the cell twice.\n        [\n            element,\n            ...embeddedCells,\n            ...connectedLinks\n        ].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\n        element.startBatch('to-front');\n\n        // Bring the model to the front with all his embeds.\n        element.toFront({ deep: true, ui: true });\n\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        connectedLinks.forEach((link) => {\n            if (link.attributes.z <= maxZ) {\n                link.set('z', maxZ + 1, { ui: true });\n            }\n        });\n\n        element.stopBatch('to-front');\n\n        // Before we start looking for suitable parent we remove the current one.\n        const parentId = element.parent();\n        if (parentId) {\n            const parent = graph.getCell(parentId);\n            parent.unembed(element, { ui: true });\n            data.initialParentId = parentId;\n        } else {\n            data.initialParentId = null;\n        }\n    },\n\n    processEmbedding: function(data = {}, evt, x, y) {\n\n        const model = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;\n\n        let candidates;\n        if (isFunction(findParentBy)) {\n            candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n        } else if (findParentBy === 'pointer') {\n            candidates = graph.findElementsAtPoint({ x, y });\n        } else {\n            candidates = graph.findElementsUnderElement(model, { searchBy: findParentBy });\n        }\n\n        candidates = candidates.filter((el) => {\n            return (el instanceof Cell) && (model.id !== el.id) && !el.isEmbeddedIn(model);\n        });\n\n        if (frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for (let i = candidates.length - 1; i >= 0; i--) {\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            } else {\n                const view = candidate.findView(paper);\n                if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(\n                newCandidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n        }\n\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n\n    clearEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n            data.candidateEmbedView = null;\n        }\n    },\n\n    finalizeEmbedding: function(data = {}) {\n\n        const candidateView = data.candidateEmbedView;\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n\n        if (candidateView) {\n\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(element, { ui: true });\n            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), { embedding: true });\n\n            data.candidateEmbedView = null;\n\n        } else {\n\n            const { validateUnembedding } = paper.options;\n            const { initialParentId } = data;\n            // The element was originally embedded into another element.\n            // The interaction would unembed the element. Let's validate\n            // if the element can be unembedded.\n            if (\n                initialParentId &&\n                typeof validateUnembedding === 'function' &&\n                !validateUnembedding.call(paper, this)\n            ) {\n                this._disallowUnembed(data);\n                return;\n            }\n        }\n\n        paper.model.getConnectedLinks(element, { deep: true }).forEach(link => {\n            link.reparent({ ui: true });\n        });\n    },\n\n    _disallowUnembed: function(data) {\n        const { model, whenNotAllowed = 'revert' } = data;\n        const element = model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        switch (whenNotAllowed) {\n            case 'remove': {\n                element.remove({ ui: true });\n                break;\n            }\n            case 'revert': {\n                const { initialParentId, initialPosition, initialZIndices } = data;\n                // Revert the element's position (and the position of its embedded cells if any)\n                if (initialPosition) {\n                    const { x, y } = initialPosition;\n                    element.position(x, y, { deep: true, ui: true });\n                }\n                // Revert all the z-indices changed during the embedding\n                if (initialZIndices) {\n                    Object.keys(initialZIndices).forEach(id => {\n                        const cell = graph.getCell(id);\n                        if (cell) {\n                            cell.set('z', initialZIndices[id], { ui: true });\n                        }\n                    });\n                }\n                // Revert the original parent\n                const parent = graph.getCell(initialParentId);\n                if (parent) {\n                    parent.embed(element, { ui: true });\n                }\n                break;\n            }\n        }\n    },\n\n    getTargetParentView: function(evt) {\n        const { candidateEmbedView = null } = this.eventData(evt);\n        return candidateEmbedView;\n    },\n\n    getDelegatedView: function() {\n\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n\n        while (view) {\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n\n        return null;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute('port', el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const proxyNode = this.findNode(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('element:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('element:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('element:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('element:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('element:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('element:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointermove(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnet(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointerup(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointerup(evt, x, y);\n        }\n\n        if (targetMagnet) {\n            this.magnetpointerclick(evt, targetMagnet, x, y);\n        }\n\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('element:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('element:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('element:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('element:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('element:mousewheel', evt, x, y, delta);\n    },\n\n    onmagnet: function(evt, x, y) {\n\n        const { currentTarget: targetMagnet } = evt;\n        this.magnetpointerdown(evt, targetMagnet, x, y);\n        this.eventData(evt, { targetMagnet });\n        this.dragMagnetStart(evt, x, y);\n    },\n\n    magnetpointerdown: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n    },\n\n    magnetpointermove: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointermove', evt, magnet, x, y);\n    },\n\n    magnetpointerup: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerup', evt, magnet, x, y);\n    },\n\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n    },\n\n    magnetcontextmenu: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n    },\n\n    // Drag Start Handlers\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        var view = this.getDelegatedView();\n        if (!view || !view.can('elementMove')) return;\n\n        this.eventData(evt, {\n            action: DragActions.MOVE,\n            delegatedView: view\n        });\n\n        const position = view.model.position();\n        view.eventData(evt, {\n            initialPosition: position,\n            pointerOffset: position.difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n\n    dragMagnetStart: function(evt, x, y) {\n\n        const { paper } = this;\n        const isPropagationAlreadyStopped = evt.isPropagationStopped();\n        if (isPropagationAlreadyStopped) {\n            // Special case when the propagation was already stopped\n            // on the `element:magnet:pointerdown` event.\n            // Do not trigger any `element:pointer*` events\n            // but still start the magnet dragging.\n            this.eventData(evt, { preventPointerEvents: true });\n        }\n\n        if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n            // Stop the default action, which is to start dragging a link.\n            return;\n        }\n\n        const { targetMagnet = evt.currentTarget } = this.eventData(evt);\n        evt.stopPropagation();\n\n        // Invalid (Passive) magnet. Start dragging the element.\n        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n            if (isPropagationAlreadyStopped) {\n                // Do not trigger `element:pointerdown` and start element dragging\n                // if the propagation was stopped.\n                this.dragStart(evt, x, y);\n                // The `element:pointerdown` event is not triggered because\n                // of `preventPointerEvents` flag.\n            } else {\n                // We need to reset the action\n                // to `MOVE` so that the element is dragged.\n                this.pointerdown(evt, x, y);\n            }\n            return;\n        }\n\n        // Valid magnet. Start dragging a link.\n        if (paper.options.magnetThreshold <= 0) {\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n        this.eventData(evt, { action: DragActions.MAGNET });\n    },\n\n    // Drag Handlers\n\n    snapToGrid: function(evt, x, y) {\n        const grid = this.paper.options.gridSize;\n        return {\n            x: snapToGrid(x, grid),\n            y: snapToGrid(y, grid)\n        };\n    },\n\n    drag: function(evt, x, y) {\n\n        var paper = this.paper;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n\n        // Make sure the new element's position always snaps to the current grid\n        const { x: elX, y: elY } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);\n\n        element.position(elX, elY, { restrictedArea, deep: true, ui: true });\n\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data, evt, x, y);\n        }\n\n        this.eventData(evt, {\n            embedding\n        });\n    },\n\n    dragMagnet: function(evt, x, y) {\n        this.dragLink(evt, x, y);\n    },\n\n    // Drag End Handlers\n\n    dragEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n\n    dragMagnetEnd: function(evt, x, y) {\n        this.dragLinkEnd(evt, x, y);\n    },\n\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nassign(ElementView.prototype, elementViewPortPrototype);\n", "import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, merge, assign, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline, intersection } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport { env } from '../env/index.mjs';\n\nconst Flags = {\n    TOOLS: CellView.Flags.TOOLS,\n    RENDER: 'RENDER',\n    UPDATE: 'UPDATE',\n    LABELS: 'LABELS',\n    SOURCE: 'SOURCE',\n    TARGET: 'TARGET',\n    CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n\n    presentationAttributes: {\n        markup: [Flags.RENDER],\n        attrs: [Flags.UPDATE],\n        router: [Flags.UPDATE],\n        connector: [Flags.CONNECTOR],\n        labels: [Flags.LABELS, Flags.TOOLS],\n        labelMarkup: [Flags.LABELS],\n        vertices: [Flags.UPDATE],\n        source: [Flags.SOURCE, Flags.UPDATE],\n        target: [Flags.TARGET, Flags.UPDATE]\n    },\n\n    initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\n    UPDATE_PRIORITY: 1,\n    EPSILON: 1e-6,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n\n            if (env.test('isSafari')) {\n                this.__fixSafariBug268376();\n            }\n\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n            updateLabels = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n\n        return flags;\n    },\n\n    __fixSafariBug268376: function() {\n        // Safari has a bug where any change after the first render is not reflected in the DOM.\n        // https://bugs.webkit.org/show_bug.cgi?id=268376\n        const { el } = this;\n        const childNodes = Array.from(el.childNodes);\n        const fragment = document.createDocumentFragment();\n        for (let i = 0, n = childNodes.length; i < n; i++) {\n            el.removeChild(childNodes[i]);\n            fragment.appendChild(childNodes[i]);\n        }\n        el.appendChild(fragment);\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = V(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = V(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = V('g').append(fragment);\n        } else {\n            vNode = V(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = V('g').addClass('labels');\n            if (this.options.labelsLayer) {\n                vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n                vLabels.attr('model-id', model.id);\n            }\n        }\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n\n    findLabelNodes: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return [];\n        const labelSelectors = this._labelSelectors[labelIndex];\n        return this.findBySelector(selector, labelRoot, labelSelectors);\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const [node = null] = this.findLabelNodes(labelIndex, selector);\n        return node;\n    },\n\n    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    // merge default label size into label size (no built-in default)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n\n        if (labelSize === null) return null;\n        if (labelSize === undefined) {\n\n            if (defaultLabelSize === null) return null;\n            if (defaultLabelSize === undefined) return undefined;\n\n            return defaultLabelSize;\n        }\n\n        return merge({}, defaultLabelSize, labelSize);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        if (!this.paper.options.labelLayer) {\n            // If there is no label layer, the cache needs to be cleared\n            // of the root node because the labels are attached\n            // to it and could affect the bounding box.\n            this.cleanNodeCache(this.el);\n        }\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n        var defaultLabelSize = defaultLabel.size;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n            var labelSize = label.size;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            var size = this._mergeLabelSize(\n                labelSize,\n                defaultLabelSize\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new Rect(size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourceAnchor);\n            case 'target':\n                return new Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourcePoint);\n            case 'target':\n                return new Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n\n    // Updating.\n    // ---------\n\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and anchor points.\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n\n    updateDOM() {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors });\n        // update the label position etc.\n        this.updateLabelPositions();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 4. Find Connection\n        const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n        this.path = path;\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (this.options.perpendicular) {\n                    // Backwards compatibility\n                    // See `manhattan` router for more details\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    isIntersecting: function(geometryShape, geometryData) {\n        const connection = this.getConnection();\n        if (!connection) return false;\n        return intersection.exists(\n            geometryShape,\n            connection,\n            geometryData,\n            { segmentSubdivisions: this.getConnectionSubdivisions() },\n        );\n    },\n\n    isEnclosedIn: function(geometryRect) {\n        const connection = this.getConnection();\n        if (!connection) return false;\n        const bbox = connection.bbox();\n        if (!bbox) return false;\n        return geometryRect.containsRect(bbox);\n    },\n\n    isAtPoint: function(point /*, options */) {\n        // Note: `strict` option is not applicable for links.\n        // There is currently no method to determine if a path contains a point.\n        const area = new Rect(point);\n        // Intersection with a zero-size area is not possible.\n        area.inflate(this.EPSILON);\n        return this.isIntersecting(area);\n    },\n\n    // combine default label position with built-in default label position\n    _getDefaultLabelPositionProperty: function() {\n\n        var model = this.model;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    // expects normalized position properties\n    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\n        if (normalizedLabelPosition === null) return null;\n        if (normalizedLabelPosition === undefined) {\n\n            if (normalizedDefaultLabelPosition === null) return null;\n            return normalizedDefaultLabelPosition;\n        }\n\n        return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _getLabelPositionProperty: function(idx) {\n\n        return (this.model.label(idx).position || {});\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if (isObject(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = V(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findNode(selector);\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = this.paper.options.routerNamespace || routers;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(Point); // no router specified\n        }\n\n        var routerFn = isFunction(router) ? router : namespace[router.name];\n        if (!isFunction(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = this.paper.options.connectorNamespace || connectors;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n        if (!isFunction(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = clone(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new Path(V.normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start.clone();\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n                }\n            }\n\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start.clone();\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return V.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) assign(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragLabelStart: function(evt, x, y) {\n\n        if (this.can('labelMove')) {\n\n            if (this.isDefaultInteractionPrevented(evt)) return;\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\n            var coords = this.getLabelCoordinates(position);\n            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                dx: dx,\n                dy: dy,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition((x + data.dx), (y + data.dy), data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        // The `touchmove' events are not fired\n        // when the original event target is removed from the DOM.\n        // The labels are currently re-rendered completely when only\n        // the position changes. This is why we need to make sure that\n        // the label is updated synchronously.\n        // TODO: replace `touchmove` with `pointermove` (breaking change).\n        const setOptions = { ui: true };\n        if (this.paper.isAsync() && evt.type === 'touchmove') {\n            setOptions.async = false;\n        }\n        this.model.label(data.labelIdx, label, setOptions);\n    },\n\n    dragArrowhead: function(evt, x, y) {\n        if (this.paper.options.snapLinks) {\n            const isSnapped = this._snapArrowhead(evt, x, y);\n            if (!isSnapped && this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            }\n        } else {\n            if (this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            } else {\n                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n            }\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapToPoints: function(snapPoint, points, radius) {\n        let closestPointX = null;\n        let closestDistanceX = Infinity;\n\n        let closestPointY = null;\n        let closestDistanceY = Infinity;\n\n        let x = snapPoint.x;\n        let y = snapPoint.y;\n\n        for (let i = 0; i < points.length; i++) {\n            const distX = Math.abs(points[i].x - snapPoint.x);\n            if (distX < closestDistanceX) {\n                closestDistanceX = distX;\n                closestPointX = points[i];\n            }\n\n            const distY = Math.abs(points[i].y - snapPoint.y);\n            if (distY < closestDistanceY) {\n                closestDistanceY = distY;\n                closestPointY = points[i];\n            }\n        }\n\n        if (closestDistanceX < radius) {\n            x = closestPointX.x;\n        }\n        if (closestDistanceY < radius) {\n            y = closestPointY.y;\n        }\n\n        return { x, y };\n    },\n\n    _snapArrowheadSelf: function(evt, x, y) {\n\n        const { paper, model } = this;\n        const { snapLinksSelf } = paper.options;\n        const data = this.eventData(evt);\n        const radius = snapLinksSelf.radius || 20;\n\n        const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n        const vertices = model.vertices();\n        const points = [anchor, ...vertices];\n\n        const snapPoint = this._snapToPoints({ x: x, y: y }, points, radius);\n\n        const point = paper.localToClientPoint(snapPoint);\n        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        let isSnapped = false;\n        // checking view in close area of the pointer\n\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findElementViewsInArea(\n            { x: x - r, y: y - r, width: 2 * r, height: 2 * r },\n            snapLinks.findInAreaOptions\n        );\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new Point(x, y);\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n            isSnapped = true;\n\n            if (!newClosestMagnet)  {\n                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n            }\n\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && isEqual(prevEnd, end)) {\n                // the source/target json has not changed\n                return isSnapped;\n            }\n\n            data.prevEnd = end;\n\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n\n        return isSnapped;\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: clone(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    },\n\n    // Lifecycle methods\n\n    onMount: function() {\n        CellView.prototype.onMount.apply(this, arguments);\n        this.mountLabels();\n    },\n\n    onDetach: function() {\n        CellView.prototype.onDetach.apply(this, arguments);\n        this.unmountLabels();\n    },\n\n    onRemove: function() {\n        CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n", "import { PaperLayer } from '../PaperLayer.mjs';\nimport {\n    isFunction,\n    isString,\n    defaults,\n    omit,\n    assign,\n    merge,\n} from '../../util/index.mjs';\nimport V from '../../V/index.mjs';\n\nexport const GridLayer = PaperLayer.extend({\n\n    style: {\n        'pointer-events': 'none'\n    },\n\n    _gridCache: null,\n    _gridSettings: null,\n\n    init() {\n        PaperLayer.prototype.init.apply(this, arguments);\n        const { options: { paper }} = this;\n        this._gridCache = null;\n        this._gridSettings = [];\n        this.listenTo(paper, 'transform resize', this.updateGrid);\n    },\n\n    setGrid(drawGrid) {\n        this._gridSettings = this.getGridSettings(drawGrid);\n        this.renderGrid();\n    },\n\n    getGridSettings(drawGrid) {\n        const gridSettings = [];\n        if (drawGrid) {\n            const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n            optionsList.forEach((item) => {\n                gridSettings.push(...this._resolveDrawGridOption(item));\n            });\n        }\n        return gridSettings;\n    },\n\n    removeGrid() {\n        const { _gridCache: grid } = this;\n        if (!grid) return;\n        grid.root.remove();\n        this._gridCache = null;\n    },\n\n    renderGrid() {\n\n        const { options: { paper }} = this;\n        const { _gridSettings: gridSettings } = this;\n\n        this.removeGrid();\n\n        if (gridSettings.length === 0) return;\n\n        const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n        if (gridSize <= 1) {\n            return;\n        }\n\n        const refs = this._getGridRefs();\n\n        gridSettings.forEach((gridLayerSetting, index) => {\n\n            const id = this._getPatternId(index);\n            const options = merge({}, gridLayerSetting);\n            const { scaleFactor = 1 } = options;\n            options.width = gridSize * scaleFactor || 1;\n            options.height = gridSize * scaleFactor || 1;\n\n            let vPattern;\n            if (!refs.exist(id)) {\n                vPattern = V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup));\n                refs.add(id, vPattern);\n            } else {\n                vPattern = refs.get(id);\n            }\n\n            if (isFunction(options.render)) {\n                options.render(vPattern.node.firstChild, options, paper);\n            }\n            vPattern.attr({\n                width: options.width,\n                height: options.height\n            });\n        });\n\n        refs.root.appendTo(this.el);\n        this.updateGrid();\n    },\n\n    updateGrid() {\n\n        const { _gridCache: grid, _gridSettings: gridSettings, options: { paper }} = this;\n        if (!grid) return;\n        const { root: vSvg, patterns } = grid;\n        const { x, y, width, height } = paper.getArea();\n        vSvg.attr({ x, y, width, height });\n        for (const patternId in patterns) {\n            const vPattern = patterns[patternId];\n            vPattern.attr({ x: -x, y: -y });\n        }\n        gridSettings.forEach((options, index) => {\n            if (isFunction(options.update)) {\n                const vPattern = patterns[this._getPatternId(index)];\n                options.update(vPattern.node.firstChild, options, paper);\n            }\n        });\n    },\n\n    _getPatternId(index) {\n        return `pattern_${this.options.paper.cid}_${index}`;\n    },\n\n    _getGridRefs() {\n        let { _gridCache: grid } = this;\n        if (grid) return grid;\n        const defsVEl = V('defs');\n        const svgVEl = V('svg', { width: '100%', height: '100%' }, [defsVEl]);\n        grid = this._gridCache = {\n            root: svgVEl,\n            patterns: {},\n            add: function(id, patternVEl) {\n                const rectVEl = V('rect', { width: '100%', height: '100%', fill: `url(#${id})` });\n                defsVEl.append(patternVEl);\n                svgVEl.append(rectVEl);\n                this.patterns[id] = patternVEl;\n            },\n            get: function(id) {\n                return this.patterns[id];\n            },\n            exist: function(id) {\n                return this.patterns[id] !== undefined;\n            }\n        };\n        return grid;\n    },\n\n    _resolveDrawGridOption(opt) {\n\n        var namespace = this.options.patterns;\n        if (isString(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return assign({}, item);\n            });\n        }\n\n        var options = opt || { args: [{}] };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n\n        if (!isArray && !name && !options.markup) {\n            name = 'dot';\n        }\n\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return assign({}, item);\n            });\n\n            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n            defaults(args[0], omit(opt, 'args'));\n            for (var i = 0; i < args.length; i++) {\n                if (pattern[i]) {\n                    assign(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n\n        return isArray ? options : [options];\n    },\n\n});\n", "import V from '../V/index.mjs';\nimport {\n    isNumber,\n    assign,\n    nextFrame,\n    isObject,\n    cancelFrame,\n    defaults,\n    defaultsDeep,\n    addClassNamePrefix,\n    normalizeSides,\n    isFunction,\n    isPlainObject,\n    getByPath,\n    sortElements,\n    isString,\n    guid,\n    normalizeEvent,\n    normalizeWheel,\n    cap,\n    debounce,\n    omit,\n    result,\n    camelCase,\n    cloneDeep,\n    invoke,\n    hashCode,\n    filter as _filter,\n    parseDOMJSON,\n    toArray,\n    has\n} from '../util/index.mjs';\nimport { ViewBase } from '../mvc/ViewBase.mjs';\nimport { Rect, Point, toRad } from '../g/index.mjs';\nimport { View, views } from '../mvc/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { ElementView } from './ElementView.mjs';\nimport { LinkView } from './LinkView.mjs';\nimport { Cell } from './Cell.mjs';\nimport { Graph } from './Graph.mjs';\nimport { LayersNames, PaperLayer } from './PaperLayer.mjs';\nimport * as highlighters from '../highlighters/index.mjs';\nimport * as linkAnchors from '../linkAnchors/index.mjs';\nimport * as connectionPoints from '../connectionPoints/index.mjs';\nimport * as anchors from '../anchors/index.mjs';\n\nimport $ from '../mvc/Dom/index.mjs';\nimport { GridLayer } from './layers/GridLayer.mjs';\n\nconst sortingTypes = {\n    NONE: 'sorting-none',\n    APPROX: 'sorting-approximate',\n    EXACT: 'sorting-exact'\n};\n\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = CellView.Highlighting;\n\nconst defaultHighlighting = {\n    [HighlightingTypes.DEFAULT]: {\n        name: 'stroke',\n        options: {\n            padding: 3\n        }\n    },\n    [HighlightingTypes.MAGNET_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-magnet'\n        }\n    },\n    [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-cell'\n        }\n    }\n};\n\nconst defaultLayers = [{\n    name: LayersNames.GRID,\n}, {\n    name: LayersNames.BACK,\n}, {\n    name: LayersNames.CELLS,\n}, {\n    name: LayersNames.LABELS,\n}, {\n    name: LayersNames.FRONT\n}, {\n    name: LayersNames.TOOLS\n}];\n\nexport const Paper = View.extend({\n\n    className: 'paper',\n\n    options: {\n\n        width: 800,\n        height: 600,\n        gridSize: 1,\n        // Whether or not to draw the grid lines on the paper's DOM element.\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n        drawGrid: false,\n        // If not set, the size of the visual grid is the same as the `gridSize`.\n        drawGridSize: null,\n\n        // Whether or not to draw the background on the paper's DOM element.\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n        background: false,\n\n        elementView: ElementView,\n        linkView: LinkView,\n        snapLabels: false, // false, true\n        snapLinks: false, // false, true, { radius: value }\n        snapLinksSelf: false, // false, true, { radius: value }\n\n        // Should the link labels be rendered into its own layer?\n        // `false` - the labels are part of the links\n        // `true` - the labels are appended to LayersName.LABELS\n        // [LayersName] - the labels are appended to the layer specified\n        labelsLayer: false,\n\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n        multiLinks: true,\n\n        // For adding custom guard logic.\n        guard: function(evt, view) {\n\n            // FALSE means the event isn't guarded.\n            return false;\n        },\n\n        highlighting: defaultHighlighting,\n\n        // Prevent the default context menu from being displayed.\n        preventContextMenu: true,\n\n        // Prevent the default action for blank:pointer<action>.\n        preventDefaultBlankAction: true,\n\n        // Prevent the default action for cell:pointer<action>.\n        preventDefaultViewAction: true,\n\n        // Restrict the translation of elements by given bounding box.\n        // Option accepts a boolean:\n        //  true - the translation is restricted to the paper area\n        //  false - no restrictions\n        // A method:\n        // restrictTranslate: function(elementView) {\n        //     var parentId = elementView.model.get('parent');\n        //     return parentId && this.model.getCell(parentId).getBBox();\n        // },\n        // Or a bounding box:\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n        restrictTranslate: false,\n\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n        // when the dragging is stopped.\n        markAvailable: false,\n\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\n        // Value could be the mvc.model or a function returning the mvc.model\n        // defaultLink: (elementView, magnet) => {\n        //   return condition ? new customLink1() : new customLink2()\n        // }\n        defaultLink: function() {\n            // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n            const { cellNamespace } = this.model.get('cells');\n            const ctor = getByPath(cellNamespace, ['standard', 'Link']);\n            if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n            return new ctor();\n        },\n\n        // A connector that is used by links with no connector defined on the model.\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n        defaultConnector: { name: 'normal' },\n\n        // A router that is used by links with no router defined on the model.\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n        defaultRouter: { name: 'normal' },\n\n        defaultAnchor: { name: 'center' },\n\n        defaultLinkAnchor: { name: 'connectionRatio' },\n\n        defaultConnectionPoint: { name: 'boundary' },\n\n        /* CONNECTING */\n\n        connectionStrategy: null,\n\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\n        validateMagnet: function(_cellView, magnet, _evt) {\n            return magnet.getAttribute('magnet') !== 'passive';\n        },\n\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n        // being changed.\n        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n            return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n        },\n\n        /* EMBEDDING */\n\n        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n        // all links and elements are visible taken the level of embedding into account.\n        embeddingMode: false,\n\n        // Check whether to allow or disallow the element embedding while an element being translated.\n        validateEmbedding: function(childView, parentView) {\n            // by default all elements can be in relation child-parent\n            return true;\n        },\n\n        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n        validateUnembedding: function(childView) {\n            // by default all elements can become roots\n            return true;\n        },\n\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n        // The cell with the highest z-index (visually on the top) will be chosen.\n        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n        // If enabled only the element on the very front is taken into account for the embedding.\n        // If disabled the elements under the dragged view are tested one by one\n        // (from front to back) until a valid parent found.\n        frontParentOnly: true,\n\n        // Interactive flags. See online docs for the complete list of interactive flags.\n        interactive: {\n            labelMove: false\n        },\n\n        // When set to true the links can be pinned to the paper.\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n        linkPinning: true,\n\n        // Custom validation after an interaction with a link ends.\n        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n        // (linkView, paper) => boolean\n        allowLink: null,\n\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n        clickThreshold: 0,\n\n        // Number of required mousemove events before the first pointermove event will be triggered.\n        moveThreshold: 0,\n\n        // Number of required mousemove events before a link is created out of the magnet.\n        // Or string `onleave` so the link is created when the pointer leaves the magnet\n        magnetThreshold: 0,\n\n        // Rendering Options\n\n        sorting: sortingTypes.APPROX,\n\n        frozen: false,\n\n        autoFreeze: false,\n\n        // no docs yet\n        onViewUpdate: function(view, flag, priority, opt, paper) {\n            // Do not update connected links when:\n            // 1. the view was just inserted (added to the graph and rendered)\n            // 2. the view was just mounted (added back to the paper by viewport function)\n            // 3. the change was marked as `isolate`.\n            // 4. the view model was just removed from the graph\n            if ((flag & (view.FLAG_INSERT | view.FLAG_REMOVE)) || opt.mounting || opt.isolate) return;\n            paper.requestConnectedLinksUpdate(view, priority, opt);\n        },\n\n        // no docs yet\n        onViewPostponed: function(view, flag, paper) {\n            return paper.forcePostponedViewUpdate(view, flag);\n        },\n\n        beforeRender: null, // function(opt, paper) { },\n\n        afterRender: null, // function(stats, opt, paper) {\n\n        viewport: null,\n\n        // Default namespaces\n\n        cellViewNamespace: null,\n\n        routerNamespace: null,\n\n        connectorNamespace: null,\n\n        highlighterNamespace: highlighters,\n\n        anchorNamespace: anchors,\n\n        linkAnchorNamespace: linkAnchors,\n\n        connectionPointNamespace: connectionPoints,\n\n        overflow: false\n    },\n\n    events: {\n        'dblclick': 'pointerdblclick',\n        'dbltap': 'pointerdblclick',\n        'contextmenu': 'contextmenu',\n        'mousedown': 'pointerdown',\n        'touchstart': 'pointerdown',\n        'mouseover': 'mouseover',\n        'mouseout': 'mouseout',\n        'mouseenter': 'mouseenter',\n        'mouseleave': 'mouseleave',\n        'wheel': 'mousewheel',\n        'mouseenter .joint-cell': 'mouseenter',\n        'mouseleave .joint-cell': 'mouseleave',\n        'mouseenter .joint-tools': 'mouseenter',\n        'mouseleave .joint-tools': 'mouseleave',\n        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n        'touchstart .joint-link .label': 'onlabel',\n        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n    },\n\n    documentEvents: {\n        'mousemove': 'pointermove',\n        'touchmove': 'pointermove',\n        'mouseup': 'pointerup',\n        'touchend': 'pointerup',\n        'touchcancel': 'pointerup'\n    },\n\n    /* CSS within the SVG document\n    * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n    *    elements that use the `scalable` group.\n    */\n    stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n\n    svg: null,\n    viewport: null,\n    defs: null,\n    tools: null,\n    layers: null,\n\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\n    _viewportMatrix: null,\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n    // could have been manipulated directly.\n    _viewportTransformString: null,\n    // Updates data (priorities, unmounted views etc.)\n    _updates: null,\n    // Paper Layers\n    _layers: null,\n\n    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n    UPDATE_DELAYING_BATCHES: ['translate'],\n    // If you interact with these elements,\n    // the default interaction such as `element move` is prevented.\n    FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'] ,\n    // If you interact with these elements, the events are not propagated to the paper\n    // i.e. paper events such as `element:pointerdown` are not triggered.\n    GUARDED_TAG_NAMES: [\n        // Guard <select> for consistency. When you click on it:\n        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n        //          on close. However, if you open and then close by clicking elsewhere on the page,\n        //           no other event is triggered.\n        // Safari: when you open it, it triggers `pointerdown`. That's it.\n        'SELECT',\n    ],\n    MIN_SCALE: 1e-6,\n\n    // Default find buffer for the findViewsInArea and findViewsAtPoint methods.\n    // The find buffer is used to extend the area of the search\n    // to mitigate the differences between the model and view geometry.\n    DEFAULT_FIND_BUFFER: 200,\n\n    init: function() {\n\n        const { options } = this;\n        if (!options.cellViewNamespace) {\n            /* eslint-disable no-undef */\n            options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n        const model = this.model = options.model || new Graph;\n\n        // Layers (SVGGroups)\n        this._layers = {};\n\n        this.cloneOptions();\n        this.render();\n        this._setDimensions();\n        this.startListening();\n\n        // Hash of all cell views.\n        this._views = {};\n\n        // Mouse wheel events buffer\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n\n        // Render existing cells in the graph\n        this.resetViews(model.attributes.cells.models);\n        // Start the Rendering Loop\n        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n    },\n\n    _resetUpdates: function() {\n        if (this._updates && this._updates.id) cancelFrame(this._updates.id);\n\n        return this._updates = {\n            id: null,\n            priorities: [{}, {}, {}],\n            unmountedCids: [],\n            mountedCids: [],\n            unmounted: {},\n            mounted: {},\n            count: 0,\n            keyFrozen: false,\n            freezeKey: null,\n            sort: false,\n            disabled: false,\n            idle: false\n        };\n    },\n\n    startListening: function() {\n        var model = this.model;\n        this.listenTo(model, 'add', this.onCellAdded)\n            .listenTo(model, 'remove', this.onCellRemoved)\n            .listenTo(model, 'change', this.onCellChange)\n            .listenTo(model, 'reset', this.onGraphReset)\n            .listenTo(model, 'sort', this.onGraphSort)\n            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n        this.on('cell:highlight', this.onCellHighlight)\n            .on('cell:unhighlight', this.onCellUnhighlight)\n            .on('transform', this.update);\n    },\n\n    onCellAdded: function(cell, _, opt) {\n        var position = opt.position;\n        if (this.isAsync() || !isNumber(position)) {\n            this.renderView(cell, opt);\n        } else {\n            if (opt.maxPosition === position) this.freeze({ key: 'addCells' });\n            this.renderView(cell, opt);\n            if (position === 0) this.unfreeze({ key: 'addCells' });\n        }\n    },\n\n    onCellRemoved: function(cell, _, opt) {\n        const view = this.findViewByModel(cell);\n        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n    },\n\n    onCellChange: function(cell, opt) {\n        if (cell === this.model.attributes.cells) return;\n        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n            const view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    onGraphReset: function(collection, opt) {\n        this.resetLayers();\n        this.resetViews(collection.models, opt);\n    },\n\n    onGraphSort: function() {\n        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n        this.sortViews();\n    },\n\n    onGraphBatchStop: function(data) {\n        if (this.isFrozen()) return;\n        var name = data && data.batchName;\n        var graph = this.model;\n        if (!this.isAsync()) {\n            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    },\n\n    cloneOptions: function() {\n\n        const { options } = this;\n        const {\n            defaultConnector,\n            defaultRouter,\n            defaultConnectionPoint,\n            defaultAnchor,\n            defaultLinkAnchor,\n            highlighting,\n            cellViewNamespace,\n            interactive\n        } = options;\n\n        // Default cellView namespace for ES5\n        /* eslint-disable no-undef */\n        if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            options.cellViewNamespace = joint.shapes;\n        }\n        /* eslint-enable no-undef */\n\n        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n        if (!isFunction(defaultConnector)) {\n            options.defaultConnector = cloneDeep(defaultConnector);\n        }\n        if (!isFunction(defaultRouter)) {\n            options.defaultRouter = cloneDeep(defaultRouter);\n        }\n        if (!isFunction(defaultConnectionPoint)) {\n            options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n        }\n        if (!isFunction(defaultAnchor)) {\n            options.defaultAnchor = cloneDeep(defaultAnchor);\n        }\n        if (!isFunction(defaultLinkAnchor)) {\n            options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n        }\n        if (isPlainObject(interactive)) {\n            options.interactive = assign({}, interactive);\n        }\n        if (isPlainObject(highlighting)) {\n            // Return the default highlighting options into the user specified options.\n            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n        }\n    },\n\n    children: function() {\n        var ns = V.namespace;\n        return [{\n            namespaceURI: ns.xhtml,\n            tagName: 'div',\n            className: addClassNamePrefix('paper-background'),\n            selector: 'background',\n            style: {\n                position: 'absolute',\n                inset: 0\n            }\n        }, {\n            namespaceURI: ns.svg,\n            tagName: 'svg',\n            attributes: {\n                'width': '100%',\n                'height': '100%',\n                'xmlns:xlink': ns.xlink\n            },\n            selector: 'svg',\n            style: {\n                position: 'absolute',\n                inset: 0\n            },\n            children: [{\n                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                tagName: 'defs',\n                selector: 'defs'\n            }, {\n                tagName: 'g',\n                className: addClassNamePrefix('layers'),\n                selector: 'layers'\n            }]\n        }];\n    },\n\n    hasLayerView(layerName) {\n        return  (layerName in this._layers);\n    },\n\n    getLayerView(layerName) {\n        const { _layers } = this;\n        if (layerName in _layers) return _layers[layerName];\n        throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n    },\n\n    getLayerNode(layerName) {\n        return this.getLayerView(layerName).el;\n    },\n\n    render: function() {\n\n        this.renderChildren();\n        const { el, childNodes, options, stylesheet } = this;\n        const { svg, defs, layers } = childNodes;\n\n        el.style.position = 'relative';\n        svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\n        this.svg = svg;\n        this.defs = defs;\n        this.layers = layers;\n\n        this.renderLayers();\n\n        V.ensureId(svg);\n\n        this.addStylesheet(stylesheet);\n\n        if (options.background) {\n            this.drawBackground(options.background);\n        }\n\n        if (options.drawGrid) {\n            this.setGrid(options.drawGrid);\n        }\n\n        return this;\n    },\n\n    addStylesheet: function(css) {\n        if (!css) return;\n        V(this.svg).prepend(V.createSVGStyle(css));\n    },\n\n    createLayer(name) {\n        switch (name) {\n            case LayersNames.GRID:\n                return new GridLayer({ name, paper: this, patterns: this.constructor.gridPatterns });\n            default:\n                return new PaperLayer({ name });\n        }\n    },\n\n    renderLayers: function(layers = defaultLayers) {\n        this.removeLayers();\n        // TODO: Layers to be read from the graph `layers` attribute\n        layers.forEach(({ name, sorted }) => {\n            const layerView = this.createLayer(name);\n            this.layers.appendChild(layerView.el);\n            this._layers[name] = layerView;\n        });\n        // Throws an exception if doesn't exist\n        const cellsLayerView = this.getLayerView(LayersNames.CELLS);\n        const toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n        const labelsLayerView = this.getLayerView(LayersNames.LABELS);\n        // backwards compatibility\n        this.tools = toolsLayerView.el;\n        this.cells = this.viewport = cellsLayerView.el;\n        // user-select: none;\n        cellsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n        labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n        cellsLayerView.el.style.webkitUserSelect = 'none';\n        cellsLayerView.el.style.userSelect = 'none';\n        labelsLayerView.el.style.webkitUserSelect = 'none';\n        labelsLayerView.el.style.userSelect = 'none';\n    },\n\n    removeLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].remove();\n            delete _layers[name];\n        });\n    },\n\n    resetLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].removePivots();\n        });\n    },\n\n    update: function() {\n\n        if (this._background) {\n            this.updateBackgroundImage(this._background);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, data) {\n        const ctm = this.matrix();\n        // getter\n        if (sx === undefined) {\n            return V.matrixToScale(ctm);\n        }\n        // setter\n        if (sy === undefined) {\n            sy = sx;\n        }\n        sx = Math.max(sx || 0, this.MIN_SCALE);\n        sy = Math.max(sy || 0, this.MIN_SCALE);\n        ctm.a = sx;\n        ctm.d = sy;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    scaleUniformAtPoint: function(scale, point, data) {\n        const { a: sx, d: sy, e: tx, f: ty } = this.matrix();\n        scale = Math.max(scale || 0, this.MIN_SCALE);\n        if (scale === sx && scale === sy) {\n            // The scale is the same as the current one.\n            return this;\n        }\n        const matrix = V.createSVGMatrix()\n            .translate(\n                tx - point.x * (scale - sx),\n                ty - point.y * (scale - sy)\n            )\n            .scale(scale, scale);\n        this.matrix(matrix, data);\n        return this;\n    },\n\n    translate: function(tx, ty, data) {\n        const ctm = this.matrix();\n        // getter\n        if (tx === undefined) {\n            return V.matrixToTranslate(ctm);\n        }\n        // setter\n        tx || (tx = 0);\n        ty || (ty = 0);\n        if (ctm.e === tx && ctm.f === ty) return this;\n        ctm.e = tx;\n        ctm.f = ty;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    matrix: function(ctm, data = {}) {\n\n        var viewport = this.layers;\n\n        // Getter:\n        if (ctm === undefined) {\n\n            var transformString = viewport.getAttribute('transform');\n\n            if ((this._viewportTransformString || null) === transformString) {\n                // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n            } else {\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\n                ctm = viewport.getCTM();\n                this._viewportMatrix = ctm;\n                this._viewportTransformString = transformString;\n            }\n\n            // Clone the cached current transformation matrix.\n            // If no matrix previously stored the identity matrix is returned.\n            return V.createSVGMatrix(ctm);\n        }\n\n        // Setter:\n        const prev = this.matrix();\n        const current = V.createSVGMatrix(ctm);\n        const currentTransformString = this._viewportTransformString;\n        const ctmString = V.matrixToTransformString(current);\n        if (ctmString === currentTransformString) {\n            // The new transform string is the same as the current one.\n            // No need to update the transform attribute.\n            return this;\n        }\n        if (!currentTransformString && V.matrixToTransformString() === ctmString) {\n            // The current transform string is empty and the new one is an identity matrix.\n            // No need to update the transform attribute.\n            return this;\n        }\n\n        const { a, d, e, f } = current;\n\n        viewport.setAttribute('transform', ctmString);\n        this._viewportMatrix = current;\n        this._viewportTransformString = viewport.getAttribute('transform');\n\n        // scale event\n        if (a !== prev.a || d !== prev.d) {\n            this.trigger('scale', a, d, data);\n        }\n\n        // translate event\n        if (e !== prev.e || f !== prev.f) {\n            this.trigger('translate', e, f, data);\n        }\n\n        this.trigger('transform', current, data);\n        return this;\n    },\n\n    clientMatrix: function() {\n\n        return V.createSVGMatrix(this.cells.getScreenCTM());\n    },\n\n    requestConnectedLinksUpdate: function(view, priority, opt) {\n        if (view instanceof CellView) {\n            var model = view.model;\n            var links = this.model.getConnectedLinks(model);\n            for (var j = 0, n = links.length; j < n; j++) {\n                var link = links[j];\n                var linkView = this.findViewByModel(link);\n                if (!linkView) continue;\n                var flagLabels = ['UPDATE'];\n                if (link.getTargetCell() === model) flagLabels.push('TARGET');\n                if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n            }\n        }\n    },\n\n    forcePostponedViewUpdate: function(view, flag) {\n        if (!view || !(view instanceof CellView)) return false;\n        var model = view.model;\n        if (model.isElement()) return false;\n        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n            var dumpOptions = { silent: true };\n            // LinkView is waiting for the target or the source cellView to be rendered\n            // This can happen when the cells are not in the viewport.\n            var sourceFlag = 0;\n            var sourceView = this.findViewByModel(model.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView, dumpOptions);\n                view.updateEndMagnet('source');\n            }\n            var targetFlag = 0;\n            var targetView = this.findViewByModel(model.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView, dumpOptions);\n                view.updateEndMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n        }\n        return false;\n    },\n\n    requestViewUpdate: function(view, flag, priority, opt) {\n        opt || (opt = {});\n        this.scheduleViewUpdate(view, flag, priority, opt);\n        var isAsync = this.isAsync();\n        if (this.isFrozen() || (isAsync && opt.async !== false)) return;\n        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n        var stats = this.updateViews(opt);\n        if (isAsync) this.notifyAfterRender(stats, opt);\n    },\n\n    scheduleViewUpdate: function(view, type, priority, opt) {\n        const { _updates: updates, options } = this;\n        if (updates.idle) {\n            if (options.autoFreeze) {\n                updates.idle = false;\n                this.unfreeze();\n            }\n        }\n        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;\n        let priorityUpdates = updates.priorities[priority];\n        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n        // Move higher priority updates to this priority\n        if (priority > UPDATE_PRIORITY) {\n            // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n                const prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n        }\n        let currentType = priorityUpdates[cid] || 0;\n        // Prevent cycling\n        if ((currentType & type) === type) return;\n        if (!currentType) updates.count++;\n        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n            // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n            // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n        }\n        priorityUpdates[cid] |= type;\n        const viewUpdateFn = options.onViewUpdate;\n        if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n    },\n\n    dumpViewUpdate: function(view) {\n        if (!view) return 0;\n        var updates = this._updates;\n        var cid = view.cid;\n        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n        delete priorityUpdates[cid];\n        return flag;\n    },\n\n    dumpView: function(view, opt = {}) {\n        const flag = this.dumpViewUpdate(view);\n        if (!flag) return 0;\n        const shouldNotify = !opt.silent;\n        if (shouldNotify) this.notifyBeforeRender(opt);\n        const leftover = this.updateView(view, flag, opt);\n        if (shouldNotify) {\n            const stats = { updated: 1, priority: view.UPDATE_PRIORITY };\n            this.notifyAfterRender(stats, opt);\n        }\n        return leftover;\n    },\n\n    updateView: function(view, flag, opt) {\n        if (!view) return 0;\n        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;\n        if (view instanceof CellView) {\n            if (flag & FLAG_REMOVE) {\n                this.removeView(model);\n                return 0;\n            }\n            if (flag & FLAG_INSERT) {\n                const isInitialInsert = !!(flag & FLAG_INIT);\n                if (isInitialInsert) {\n                    flag ^= FLAG_INIT;\n                }\n                this.insertView(view, isInitialInsert);\n                flag ^= FLAG_INSERT;\n            }\n        }\n        if (!flag) return 0;\n        return view.confirmUpdate(flag, opt || {});\n    },\n\n    requireView: function(model, opt) {\n        var view = this.findViewByModel(model);\n        if (!view) return null;\n        this.dumpView(view, opt);\n        return view;\n    },\n\n    registerUnmountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.unmounted) return 0;\n        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    },\n\n    registerMountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.mounted) return 0;\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        var flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    },\n\n    isViewMounted: function(view) {\n        if (!view) return false;\n        var cid = view.cid;\n        var updates = this._updates;\n        return (cid in updates.mounted);\n    },\n\n    dumpViews: function(opt) {\n        var passingOpt = defaults({}, opt, { viewport: null });\n        this.checkViewport(passingOpt);\n        this.updateViews(passingOpt);\n    },\n\n    // Synchronous views update\n    updateViews: function(opt) {\n        this.notifyBeforeRender(opt);\n        let batchStats;\n        let updateCount = 0;\n        let batchCount = 0;\n        let priority = MIN_PRIORITY;\n        do {\n            batchCount++;\n            batchStats = this.updateViewsBatch(opt);\n            updateCount += batchStats.updated;\n            priority = Math.min(batchStats.priority, priority);\n        } while (!batchStats.empty);\n        const stats = { updated: updateCount, batches: batchCount, priority };\n        this.notifyAfterRender(stats, opt);\n        return stats;\n    },\n\n    hasScheduledUpdates: function() {\n        const priorities = this._updates.priorities;\n        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        let i = priorityIndexes.length;\n        while (i > 0 && i--) {\n            // a faster way how to check if an object is empty\n            for (let _key in priorities[priorityIndexes[i]]) return true;\n        }\n        return false;\n    },\n\n    updateViewsAsync: function(opt, data) {\n        opt || (opt = {});\n        data || (data = { processed: 0, priority: MIN_PRIORITY });\n        const { _updates: updates, options } = this;\n        const id = updates.id;\n        if (id) {\n            cancelFrame(id);\n            if (data.processed === 0 && this.hasScheduledUpdates()) {\n                this.notifyBeforeRender(opt);\n            }\n            const stats = this.updateViewsBatch(opt);\n            const passingOpt = defaults({}, opt, {\n                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n            });\n            const checkStats = this.checkViewport(passingOpt);\n            const unmountCount = checkStats.unmounted;\n            const mountCount = checkStats.mounted;\n            let processed = data.processed;\n            const total = updates.count;\n            if (stats.updated > 0) {\n                // Some updates have been just processed\n                processed += stats.updated + stats.unmounted;\n                stats.processed = processed;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountCount === 0) {\n                    stats.unmounted += unmountCount;\n                    stats.mounted += mountCount;\n                    stats.priority = data.priority;\n                    this.notifyAfterRender(stats, opt);\n                    data.processed = 0;\n                    data.priority = MIN_PRIORITY;\n                    updates.count = 0;\n                } else {\n                    data.processed = processed;\n                }\n            } else {\n                if (!updates.idle) {\n                    if (options.autoFreeze) {\n                        this.freeze();\n                        updates.idle = true;\n                        this.trigger('render:idle', opt);\n                    }\n                }\n            }\n            // Progress callback\n            const progressFn = opt.progress;\n            if (total && typeof progressFn === 'function') {\n                progressFn.call(this, stats.empty, processed, total, stats, this);\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.id !== id) return;\n        }\n        if (updates.disabled) {\n            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n        }\n        updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n    },\n\n    notifyBeforeRender: function(opt = {}) {\n        let beforeFn = opt.beforeRender;\n        if (typeof beforeFn !== 'function') {\n            beforeFn = this.options.beforeRender;\n            if (typeof beforeFn !== 'function') return;\n        }\n        beforeFn.call(this, opt, this);\n    },\n\n    notifyAfterRender: function(stats, opt = {}) {\n        let afterFn = opt.afterRender;\n        if (typeof afterFn !== 'function') {\n            afterFn = this.options.afterRender;\n        }\n        if (typeof afterFn === 'function') {\n            afterFn.call(this, stats, opt, this);\n        }\n        this.trigger('render:done', stats, opt);\n    },\n\n    updateViewsBatch: function(opt) {\n        opt || (opt = {});\n        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n        var updates = this._updates;\n        var updateCount = 0;\n        var postponeCount = 0;\n        var unmountCount = 0;\n        var mountCount = 0;\n        var maxPriority = MIN_PRIORITY;\n        var empty = true;\n        var options = this.options;\n        var priorities = updates.priorities;\n        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var postponeViewFn = options.onViewPostponed;\n        if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n            var priority = +priorityIndexes[i];\n            var priorityUpdates = priorities[priority];\n            for (var cid in priorityUpdates) {\n                if (updateCount >= batchSize) {\n                    empty = false;\n                    break main;\n                }\n                var view = views[cid];\n                if (!view) {\n                    // This should not occur\n                    delete priorityUpdates[cid];\n                    continue;\n                }\n                var currentFlag = priorityUpdates[cid];\n                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                    // We should never check a view for viewport if we are about to remove the view\n                    var isDetached = cid in updates.unmounted;\n                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                        // Unmount View\n                        if (!isDetached) {\n                            this.registerUnmountedView(view);\n                            this.detachView(view);\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete priorityUpdates[cid];\n                        unmountCount++;\n                        continue;\n                    }\n                    // Mount View\n                    if (isDetached) {\n                        currentFlag |= view.FLAG_INSERT;\n                        mountCount++;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                var leftoverFlag = this.updateView(view, currentFlag, opt);\n                if (leftoverFlag > 0) {\n                    // View update has not finished completely\n                    priorityUpdates[cid] = leftoverFlag;\n                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                        postponeCount++;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (maxPriority > priority) maxPriority = priority;\n                updateCount++;\n                delete priorityUpdates[cid];\n            }\n        }\n        return {\n            priority: maxPriority,\n            updated: updateCount,\n            postponed: postponeCount,\n            unmounted: unmountCount,\n            mounted: mountCount,\n            empty: empty\n        };\n    },\n\n    getUnmountedViews: function() {\n        const updates = this._updates;\n        const unmountedCids = Object.keys(updates.unmounted);\n        const n = unmountedCids.length;\n        const unmountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            unmountedViews[i] = views[unmountedCids[i]];\n        }\n        return unmountedViews;\n    },\n\n    getMountedViews: function() {\n        const updates = this._updates;\n        const mountedCids = Object.keys(updates.mounted);\n        const n = mountedCids.length;\n        const mountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            mountedViews[i] = views[mountedCids[i]];\n        }\n        return mountedViews;\n    },\n\n    checkUnmountedViews: function(viewportFn, opt) {\n        opt || (opt  = {});\n        var mountCount = 0;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n        var updates = this._updates;\n        var unmountedCids = updates.unmountedCids;\n        var unmounted = updates.unmounted;\n        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n            var cid = unmountedCids[i];\n            if (!(cid in unmounted)) continue;\n            var view = views[cid];\n            if (!view) continue;\n            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                // Push at the end of all unmounted ids, so this can be check later again\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount++;\n            var flag = this.registerMountedView(view);\n            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true });\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, i);\n        return mountCount;\n    },\n\n    checkMountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var unmountCount = 0;\n        if (typeof viewportFn !== 'function') return unmountCount;\n        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n        var updates = this._updates;\n        var mountedCids = updates.mountedCids;\n        var mounted = updates.mounted;\n        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n            var cid = mountedCids[i];\n            if (!(cid in mounted)) continue;\n            var view = views[cid];\n            if (!view) continue;\n            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                // Push at the end of all mounted ids, so this can be check later again\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount++;\n            var flag = this.registerUnmountedView(view);\n            if (flag) this.detachView(view);\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, i);\n        return unmountCount;\n    },\n\n    checkViewVisibility: function(cellView, opt = {}) {\n        let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        const updates = this._updates;\n        const { mounted, unmounted } = updates;\n        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n\n        let isUnmounted = false;\n        let isMounted = false;\n\n        if (cellView.cid in mounted && !visible) {\n            const flag = this.registerUnmountedView(cellView);\n            if (flag) this.detachView(cellView);\n            const i = updates.mountedCids.indexOf(cellView.cid);\n            updates.mountedCids.splice(i, 1);\n            isUnmounted = true;\n        }\n\n        if (!isUnmounted && cellView.cid in unmounted && visible) {\n            const i = updates.unmountedCids.indexOf(cellView.cid);\n            updates.unmountedCids.splice(i, 1);\n            var flag = this.registerMountedView(cellView);\n            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, { mounting: true });\n            isMounted = true;\n        }\n\n        return {\n            mounted: isMounted ? 1 : 0,\n            unmounted: isUnmounted ? 1 : 0\n        };\n    },\n\n    checkViewport: function(opt) {\n        var passingOpt = defaults({}, opt, {\n            mountBatchSize: Infinity,\n            unmountBatchSize: Infinity\n        });\n        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n        if (unmountedCount > 0) {\n            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n            var unmountedCids = this._updates.unmountedCids;\n            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n        }\n        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n        return {\n            mounted: mountedCount,\n            unmounted: unmountedCount\n        };\n    },\n\n    freeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var isFrozen = this.options.frozen;\n        var freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey)  {\n            // key passed, but the paper is already freezed with another key\n            if (isFrozen && freezeKey) return;\n            updates.freezeKey = key;\n            updates.keyFrozen = isFrozen;\n        }\n        this.options.frozen = true;\n        var id = updates.id;\n        updates.id = null;\n        if (this.isAsync() && id) cancelFrame(id);\n    },\n\n    unfreeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var freezeKey = updates.freezeKey;\n        // key passed, but the paper is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) return;\n        updates.freezeKey = null;\n        // key passed, but the paper is already freezed\n        if (key && key === freezeKey && updates.keyFrozen) return;\n        if (this.isAsync()) {\n            this.freeze();\n            this.updateViewsAsync(opt);\n        } else {\n            this.updateViews(opt);\n        }\n        this.options.frozen = updates.keyFrozen = false;\n        if (updates.sort) {\n            this.sortViews();\n            updates.sort = false;\n        }\n    },\n\n    isAsync: function() {\n        return !!this.options.async;\n    },\n\n    isFrozen: function() {\n        return !!this.options.frozen;\n    },\n\n    isExactSorting: function() {\n        return this.options.sorting === sortingTypes.EXACT;\n    },\n\n    onRemove: function() {\n\n        this.freeze();\n        this._updates.disabled = true;\n        //clean up all DOM elements/views to prevent memory leaks\n        this.removeLayers();\n        this.removeViews();\n    },\n\n    getComputedSize: function() {\n\n        var options = this.options;\n        var w = options.width;\n        var h = options.height;\n        if (!isNumber(w)) w = this.el.clientWidth;\n        if (!isNumber(h)) h = this.el.clientHeight;\n        return { width: w, height: h };\n    },\n\n    setDimensions: function(width, height, data = {}) {\n        const { options } = this;\n        const { width: currentWidth, height: currentHeight } = options;\n        let w = (width === undefined) ? currentWidth : width;\n        let h = (height === undefined) ? currentHeight : height;\n        if (currentWidth === w && currentHeight === h) return;\n        options.width = w;\n        options.height = h;\n        this._setDimensions();\n        const computedSize = this.getComputedSize();\n        this.trigger('resize', computedSize.width, computedSize.height, data);\n    },\n\n    _setDimensions: function() {\n        const { options } = this;\n        let w = options.width;\n        let h = options.height;\n        if (isNumber(w)) w = `${Math.round(w)}px`;\n        if (isNumber(h)) h = `${Math.round(h)}px`;\n        this.$el.css({\n            width: (w === null) ? '' : w,\n            height: (h === null) ? '' : h\n        });\n    },\n\n    // Expand/shrink the paper to fit the content.\n    // Alternatively signature function(opt)\n    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n\n        if (isObject(gridWidth)) {\n            // first parameter is an option object\n            opt = gridWidth;\n        } else {\n            // Support for a deprecated signature\n            opt = assign({ gridWidth, gridHeight, padding }, opt);\n        }\n\n        const { x, y, width, height } = this.getFitToContentArea(opt);\n        const { sx, sy } = this.scale();\n\n        this.translate(-x * sx, -y * sy, opt);\n        this.setDimensions(width * sx, height * sy, opt);\n\n        return new Rect(x, y, width, height);\n    },\n\n    getFitToContentArea: function(opt = {}) {\n\n        // Calculate the paper size to accommodate all the graph's elements.\n\n        const gridWidth = opt.gridWidth || 1;\n        const gridHeight = opt.gridHeight || 1;\n        const padding = normalizeSides(opt.padding || 0);\n\n        const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n        const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n        const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n        const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n        const newOrigin = opt.allowNewOrigin;\n\n        const area = ('contentArea' in opt) ? new Rect(opt.contentArea) : this.getContentArea(opt);\n        const { sx, sy } = this.scale();\n        area.x *= sx;\n        area.y *= sy;\n        area.width *= sx;\n        area.height *= sy;\n\n        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n        if (!opt.allowNegativeBottomRight) {\n            calcWidth = Math.max(calcWidth, 1);\n            calcHeight = Math.max(calcHeight, 1);\n        }\n        calcWidth *= gridWidth;\n        calcHeight *= gridHeight;\n\n        let tx = 0;\n        if ((newOrigin === 'negative' && area.x < 0) || (newOrigin === 'positive' && area.x >= 0) || newOrigin === 'any') {\n            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n            tx += padding.left;\n            calcWidth += tx;\n        }\n\n        let ty = 0;\n        if ((newOrigin === 'negative' && area.y < 0) || (newOrigin === 'positive' && area.y >= 0) || newOrigin === 'any') {\n            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n            ty += padding.top;\n            calcHeight += ty;\n        }\n\n        calcWidth += padding.right;\n        calcHeight += padding.bottom;\n\n        // Make sure the resulting width and height are greater than minimum.\n        calcWidth = Math.max(calcWidth, minWidth);\n        calcHeight = Math.max(calcHeight, minHeight);\n\n        // Make sure the resulting width and height are lesser than maximum.\n        calcWidth = Math.min(calcWidth, maxWidth);\n        calcHeight = Math.min(calcHeight, maxHeight);\n\n        return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n    },\n\n    transformToFitContent: function(opt) {\n        opt || (opt = {});\n\n        let contentBBox, contentLocalOrigin;\n        if ('contentArea' in opt) {\n            const contentArea = opt.contentArea;\n            contentBBox = this.localToPaperRect(contentArea);\n            contentLocalOrigin = new Point(contentArea);\n        } else {\n            contentBBox = this.getContentBBox(opt);\n            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n        }\n\n        if (!contentBBox.width || !contentBBox.height) return;\n\n        defaults(opt, {\n            padding: 0,\n            preserveAspectRatio: true,\n            scaleGrid: null,\n            minScale: 0,\n            maxScale: Number.MAX_VALUE,\n            verticalAlign: 'top',\n            horizontalAlign: 'left',\n            //minScaleX\n            //minScaleY\n            //maxScaleX\n            //maxScaleY\n            //fittingBBox\n        });\n\n        const padding = normalizeSides(opt.padding);\n\n        const minScaleX = opt.minScaleX || opt.minScale;\n        const maxScaleX = opt.maxScaleX || opt.maxScale;\n        const minScaleY = opt.minScaleY || opt.minScale;\n        const maxScaleY = opt.maxScaleY || opt.maxScale;\n\n        let fittingBBox;\n        if (opt.fittingBBox) {\n            fittingBBox = opt.fittingBBox;\n        } else {\n            const currentTranslate = this.translate();\n            const computedSize = this.getComputedSize();\n            fittingBBox = {\n                x: currentTranslate.tx,\n                y: currentTranslate.ty,\n                width: computedSize.width,\n                height: computedSize.height\n            };\n        }\n\n        fittingBBox = new Rect(fittingBBox).moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.left - padding.right,\n            height: -padding.top - padding.bottom\n        });\n\n        const ctm = this.matrix();\n        const { a: sx, d: sy, e: tx, f: ty } = ctm;\n\n        let newSx = fittingBBox.width / contentBBox.width * sx;\n        let newSy = fittingBBox.height / contentBBox.height * sy;\n\n        if (opt.preserveAspectRatio) {\n            newSx = newSy = Math.min(newSx, newSy);\n        }\n\n        // snap scale to a grid\n        if (opt.scaleGrid) {\n\n            const gridSize = opt.scaleGrid;\n\n            newSx = gridSize * Math.floor(newSx / gridSize);\n            newSy = gridSize * Math.floor(newSy / gridSize);\n        }\n\n        // scale min/max boundaries\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n        const scaleDiff = {\n            x: newSx / sx,\n            y: newSy / sy\n        };\n\n        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n\n        switch (opt.verticalAlign) {\n            case 'middle':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                break;\n            case 'bottom':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                break;\n            case 'top':\n            default:\n                break;\n        }\n\n        switch (opt.horizontalAlign) {\n            case 'middle':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                break;\n            case 'right':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                break;\n            case 'left':\n            default:\n                break;\n        }\n\n        ctm.a = newSx;\n        ctm.d = newSy;\n        ctm.e = newOx;\n        ctm.f = newOy;\n        this.matrix(ctm, opt);\n    },\n\n    scaleContentToFit: function(opt) {\n        this.transformToFitContent(opt);\n    },\n\n    // Return the dimensions of the content area in local units (without transformations).\n    getContentArea: function(opt) {\n\n        if (opt && opt.useModelGeometry) {\n            return this.model.getBBox() || new Rect();\n        }\n\n        return V(this.cells).getBBox();\n    },\n\n    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n    getContentBBox: function(opt) {\n\n        return this.localToPaperRect(this.getContentArea(opt));\n    },\n\n    // Returns a geometry rectangle representing the entire\n    // paper area (coordinates from the left paper border to the right one\n    // and the top border to the bottom one).\n    getArea: function() {\n\n        return this.paperToLocalRect(this.getComputedSize());\n    },\n\n    getRestrictedArea: function(...args) {\n\n        const { restrictTranslate } = this.options;\n\n        let restrictedArea;\n        if (isFunction(restrictTranslate)) {\n            // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n        } else if (restrictTranslate === true) {\n            // The paper area\n            restrictedArea = this.getArea();\n        } else if (!restrictTranslate) {\n            // falsy value\n            restrictedArea = null;\n        } else {\n            // any other value\n            restrictedArea = new Rect(restrictTranslate);\n        }\n\n        return restrictedArea;\n    },\n\n    createViewForModel: function(cell) {\n\n        const { options } = this;\n        // A class taken from the paper options.\n        var optionalViewClass;\n\n        // A default basic class (either dia.ElementView or dia.LinkView)\n        var defaultViewClass;\n\n        // A special class defined for this model in the corresponding namespace.\n        // e.g. joint.shapes.standard.Rectangle searches for joint.shapes.standard.RectangleView\n        var namespace = options.cellViewNamespace;\n        var type = cell.get('type') + 'View';\n        var namespaceViewClass = getByPath(namespace, type, '.');\n\n        if (cell.isLink()) {\n            optionalViewClass = options.linkView;\n            defaultViewClass = LinkView;\n        } else {\n            optionalViewClass = options.elementView;\n            defaultViewClass = ElementView;\n        }\n\n        // a) the paper options view is a class (deprecated)\n        //  1. search the namespace for a view\n        //  2. if no view was found, use view from the paper options\n        // b) the paper options view is a function\n        //  1. call the function from the paper options\n        //  2. if no view was return, search the namespace for a view\n        //  3. if no view was found, use the default\n        var ViewClass = (optionalViewClass.prototype instanceof ViewBase)\n            ? namespaceViewClass || optionalViewClass\n            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n        return new ViewClass({\n            model: cell,\n            interactive: options.interactive,\n            labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n        });\n    },\n\n    removeView: function(cell) {\n\n        const { id } = cell;\n        const { _views, _updates } = this;\n        const view = _views[id];\n        if (view) {\n            var { cid } = view;\n            const { mounted, unmounted } = _updates;\n            view.remove();\n            delete _views[id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    },\n\n    renderView: function(cell, opt) {\n\n        const { id } = cell;\n        const views = this._views;\n        let view, flag;\n        let create = true;\n        if (id in views) {\n            view = views[id];\n            if (view.model === cell) {\n                flag = view.FLAG_INSERT;\n                create = false;\n            } else {\n                // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n        }\n        if (create) {\n            view = views[id] = this.createViewForModel(cell);\n            view.paper = this;\n            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, 'initFlag'));\n        }\n        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n        return view;\n    },\n\n    onImageDragStart: function() {\n        // This is the only way to prevent image dragging in Firefox that works.\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n        return false;\n    },\n\n    resetViews: function(cells, opt) {\n        opt || (opt = {});\n        cells || (cells = []);\n        this._resetUpdates();\n        // clearing views removes any event listeners\n        this.removeViews();\n        // Allows to unfreeze normally while in the idle state using autoFreeze option\n        const key = this.options.autoFreeze ? null : 'reset';\n        this.freeze({ key });\n        for (var i = 0, n = cells.length; i < n; i++) {\n            this.renderView(cells[i], opt);\n        }\n        this.unfreeze({ key });\n        this.sortViews();\n    },\n\n    removeViews: function() {\n\n        invoke(this._views, 'remove');\n\n        this._views = {};\n    },\n\n    sortViews: function() {\n\n        if (!this.isExactSorting()) {\n            // noop\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this._updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    },\n\n    sortViewsExact: function() {\n\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n        // associated model `z` attribute.\n\n        var cellNodes = Array.from(this.cells.childNodes).filter(node => node.getAttribute('model-id'));\n        var cells = this.model.get('cells');\n\n        sortElements(cellNodes, function(a, b) {\n            var cellA = cells.get(a.getAttribute('model-id'));\n            var cellB = cells.get(b.getAttribute('model-id'));\n            var zA = cellA.attributes.z || 0;\n            var zB = cellB.attributes.z || 0;\n            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n        });\n    },\n\n    insertView: function(view, isInitialInsert) {\n        const layerView = this.getLayerView(LayersNames.CELLS);\n        const { el, model } = view;\n        switch (this.options.sorting) {\n            case sortingTypes.APPROX:\n                layerView.insertSortedNode(el, model.get('z'));\n                break;\n            case sortingTypes.EXACT:\n            default:\n                layerView.insertNode(el);\n                break;\n        }\n        view.onMount(isInitialInsert);\n    },\n\n    detachView(view) {\n        view.unmount();\n        view.onDetach();\n    },\n\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n    // be a selector or a jQuery object.\n    findView: function($el) {\n\n        var el = isString($el)\n            ? this.cells.querySelector($el)\n            : $el instanceof $ ? $el[0] : $el;\n\n        var id = this.findAttribute('model-id', el);\n        if (id) return this._views[id];\n\n        return undefined;\n    },\n\n    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n    findViewByModel: function(cell) {\n\n        var id = (isString(cell) || isNumber(cell)) ? cell : (cell && cell.id);\n\n        return this._views[id];\n    },\n\n    // Find all views at given point\n    findViewsFromPoint: function(p) {\n\n        p = new Point(p);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n\n        return views.filter(function(view) {\n            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n        }, this);\n    },\n\n    // Find all views in given area\n    findViewsInArea: function(rect, opt) {\n\n        opt = defaults(opt || {}, { strict: false });\n        rect = new Rect(rect);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        var method = opt.strict ? 'containsRect' : 'intersect';\n\n        return views.filter(function(view) {\n            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n        }, this);\n    },\n\n    findElementViewsInArea(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findLinkViewsInArea: function(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findCellViewsInArea: function(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findElementViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            (extArea) => this.model.findElementsInArea(extArea),\n            opt\n        );\n    },\n\n    findLinkViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            (extArea) => this.model.findLinksInArea(extArea),\n            opt,\n        );\n    },\n\n    findCellViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            // Note: we do not want to pass `opt` to `findCellsInArea`\n            // because the `strict` option works differently for querying at a point\n            (extArea) => this.model.findCellsInArea(extArea),\n            opt\n        );\n    },\n\n    _findInExtendedArea: function(area, findCellsFn, opt = {}) {\n        const {\n            buffer = this.DEFAULT_FIND_BUFFER,\n        } = opt;\n        const extendedArea = (new Rect(area)).inflate(buffer);\n        const cellsInExtendedArea = findCellsFn(extendedArea, opt);\n        return cellsInExtendedArea.map(element => this.findViewByModel(element));\n    },\n\n    _filterViewsInArea: function(plainArea, findCells, opt = {}) {\n        const area = new Rect(plainArea);\n        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n        const viewsInArea = viewsInExtendedArea.filter(view => {\n            if (!view) return false;\n            return view.isInArea(area, opt);\n        });\n        return viewsInArea;\n    },\n\n    _filterViewsAtPoint: function(plainPoint, findCells, opt = {}) {\n        const area = new Rect(plainPoint); // zero-size area\n        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n        const viewsAtPoint = viewsInExtendedArea.filter(view => {\n            if (!view) return false;\n            return view.isAtPoint(plainPoint, opt);\n        });\n        return viewsAtPoint;\n    },\n\n    removeTools: function() {\n        this.dispatchToolsEvent('remove');\n        return this;\n    },\n\n    hideTools: function() {\n        this.dispatchToolsEvent('hide');\n        return this;\n    },\n\n    showTools: function() {\n        this.dispatchToolsEvent('show');\n        return this;\n    },\n\n    dispatchToolsEvent: function(event, ...args) {\n        if (typeof event !== 'string') return;\n        this.trigger('tools:event', event, ...args);\n    },\n\n\n    getModelById: function(id) {\n\n        return this.model.getCell(id);\n    },\n\n    snapToGrid: function(x, y) {\n\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n    },\n\n    localToPaperPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new Point(x, y);\n        var paperPoint = V.transformPoint(localPoint, this.matrix());\n        return paperPoint;\n    },\n\n    localToPaperRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var localRect = new Rect(x, y, width, height);\n        var paperRect = V.transformRect(localRect, this.matrix());\n        return paperRect;\n    },\n\n    paperToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var paperPoint = new Point(x, y);\n        var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n        return localPoint;\n    },\n\n    paperToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var paperRect = new Rect(x, y, width, height);\n        var localRect = V.transformRect(paperRect, this.matrix().inverse());\n        return localRect;\n    },\n\n    localToClientPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new Point(x, y);\n        var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n        return clientPoint;\n    },\n\n    localToClientRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var localRect = new Rect(x, y, width, height);\n        var clientRect = V.transformRect(localRect, this.clientMatrix());\n        return clientRect;\n    },\n\n    // Transform client coordinates to the paper local coordinates.\n    // Useful when you have a mouse event object and you'd like to get coordinates\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n    clientToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var clientPoint = new Point(x, y);\n        var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n        return localPoint;\n    },\n\n    clientToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var clientRect = new Rect(x, y, width, height);\n        var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n        return localRect;\n    },\n\n    localToPagePoint: function(x, y) {\n\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n    },\n\n    localToPageRect: function(x, y, width, height) {\n\n        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n    },\n\n    pageToLocalPoint: function(x, y) {\n\n        var pagePoint = new Point(x, y);\n        var paperPoint = pagePoint.difference(this.pageOffset());\n        return this.paperToLocalPoint(paperPoint);\n    },\n\n    pageToLocalRect: function(x, y, width, height) {\n\n        var pageOffset = this.pageOffset();\n        var paperRect = new Rect(x, y, width, height);\n        paperRect.x -= pageOffset.x;\n        paperRect.y -= pageOffset.y;\n        return this.paperToLocalRect(paperRect);\n    },\n\n    clientOffset: function() {\n\n        var clientRect = this.svg.getBoundingClientRect();\n        return new Point(clientRect.left, clientRect.top);\n    },\n\n    pageOffset: function() {\n\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n\n    linkAllowed: function(linkView) {\n\n        if (!(linkView instanceof LinkView)) {\n            throw new Error('Must provide a linkView.');\n        }\n\n        var link = linkView.model;\n        var paperOptions = this.options;\n        var graph = this.model;\n        var ns = graph.constructor.validations;\n\n        if (!paperOptions.multiLinks) {\n            if (!ns.multiLinks.call(this, graph, link)) return false;\n        }\n\n        if (!paperOptions.linkPinning) {\n            // Link pinning is not allowed and the link is not connected to the target.\n            if (!ns.linkPinning.call(this, graph, link)) return false;\n        }\n\n        if (typeof paperOptions.allowLink === 'function') {\n            if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n        }\n\n        return true;\n    },\n\n    getDefaultLink: function(cellView, magnet) {\n\n        return isFunction(this.options.defaultLink)\n        // default link is a function producing link model\n            ? this.options.defaultLink.call(this, cellView, magnet)\n        // default link is the mvc model\n            : this.options.defaultLink.clone();\n    },\n\n    // Cell highlighting.\n    // ------------------\n\n    resolveHighlighter: function(opt = {}) {\n\n        let { highlighter: highlighterDef, type } = opt;\n        const { highlighting,highlighterNamespace  } = this.options;\n\n        /*\n            Expecting opt.highlighter to have the following structure:\n            {\n                name: 'highlighter-name',\n                options: {\n                    some: 'value'\n                }\n            }\n        */\n        if (highlighterDef === undefined) {\n\n            // Is highlighting disabled?\n            if (!highlighting) return false;\n            // check for built-in types\n            if (type) {\n                highlighterDef = highlighting[type];\n                // Is a specific type highlight disabled?\n                if (highlighterDef === false) return false;\n            }\n            if (!highlighterDef) {\n                // Type not defined use default highlight\n                highlighterDef = highlighting['default'];\n            }\n        }\n\n        // Do nothing if opt.highlighter is falsy.\n        // This allows the case to not highlight cell(s) in certain cases.\n        // For example, if you want to NOT highlight when embedding elements\n        // or use a custom highlighter.\n        if (!highlighterDef) return false;\n\n        // Allow specifying a highlighter by name.\n        if (isString(highlighterDef)) {\n            highlighterDef = {\n                name: highlighterDef\n            };\n        }\n\n        const name = highlighterDef.name;\n        const highlighter = highlighterNamespace[name];\n\n        // Highlighter validation\n        if (!highlighter) {\n            throw new Error('Unknown highlighter (\"' + name + '\")');\n        }\n        if (typeof highlighter.highlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n        }\n        if (typeof highlighter.unhighlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n        }\n\n        return {\n            highlighter,\n            options: highlighterDef.options || {},\n            name\n        };\n    },\n\n    onCellHighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.highlight(cellView, magnetEl, options);\n    },\n\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.unhighlight(cellView, magnetEl, options);\n    },\n\n    // Interaction.\n    // ------------\n\n    pointerdblclick: function(evt) {\n\n        evt.preventDefault();\n\n        // magnetpointerdblclick can stop propagation\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerclick: function(evt) {\n\n        // magnetpointerclick can stop propagation\n\n        var data = this.eventData(evt);\n        // Trigger event only if mouse has not moved.\n        if (data.mousemoved <= this.options.clickThreshold) {\n\n            evt = normalizeEvent(evt);\n\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n            if (view) {\n                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n            } else {\n                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    contextmenu: function(evt) {\n\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.contextMenuFired) {\n            this.contextMenuFired = false;\n            return;\n        }\n\n        evt = normalizeEvent(evt);\n\n        this.contextMenuTrigger(evt);\n    },\n\n    contextMenuTrigger: function(evt) {\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerdown: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const { target, button } = evt;\n        const view = this.findView(target);\n        const isContextMenu = (button === 2);\n\n        if (view) {\n\n            if (!isContextMenu && this.guard(evt, view)) return;\n\n            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\n            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n                // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n            }\n\n            if (isTargetFormNode) {\n                // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n            }\n\n            // Custom event\n            const eventEvt = this.customEventTrigger(evt, view);\n            if (eventEvt) {\n            // `onevent` could have stopped propagation\n                if (eventEvt.isPropagationStopped()) return;\n\n                evt.data = eventEvt.data;\n            }\n\n            // Element magnet\n            const magnetNode = target.closest('[magnet]');\n            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the magnet element.\n                    currentTarget: magnetNode\n                }));\n                this.onmagnet(magnetEvt);\n                if (magnetEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                if (magnetEvt.isPropagationStopped()) {\n                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                    if (isContextMenu) return;\n                    this.delegateDragEvents(view, magnetEvt.data);\n                    return;\n                }\n                evt.data = magnetEvt.data;\n            }\n        }\n\n        if (isContextMenu) {\n            this.contextMenuFired = true;\n            const contextmenuEvt = new $.Event(evt.originalEvent, { type: 'contextmenu', data: evt.data });\n            this.contextMenuTrigger(contextmenuEvt);\n        } else {\n            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerdown(evt, localPoint.x, localPoint.y);\n            } else {\n                if (this.options.preventDefaultBlankAction) {\n                    evt.preventDefault();\n                }\n                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n            }\n\n            this.delegateDragEvents(view, evt.data);\n        }\n\n    },\n\n    pointermove: function(evt) {\n\n        // mouse moved counter\n        var data = this.eventData(evt);\n        if (!data.mousemoved) {\n            data.mousemoved = 0;\n            // Make sure that events like `mouseenter` and `mouseleave` are\n            // not triggered while the user is dragging a cellView.\n            this.undelegateEvents();\n            // Note: the events are undelegated after the first `pointermove` event.\n            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n        }\n\n        var mousemoved = ++data.mousemoved;\n\n        if (mousemoved <= this.options.moveThreshold) return;\n\n        evt = normalizeEvent(evt);\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        var view = data.sourceView;\n        if (view) {\n            view.pointermove(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n        }\n\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt) {\n\n        this.undelegateDocumentEvents();\n\n        var normalizedEvt = normalizeEvent(evt);\n\n        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n        var view = this.eventData(evt).sourceView;\n        if (view) {\n            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n        }\n\n        if (!normalizedEvt.isPropagationStopped()) {\n            this.pointerclick(new $.Event(evt.originalEvent, { type: 'click', data: evt.data }));\n        }\n\n        this.delegateEvents();\n    },\n\n    mouseover: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseover(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseover', evt);\n        }\n    },\n\n    mouseout: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseout(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseout', evt);\n        }\n    },\n\n    mouseenter: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const {\n            target, // The EventTarget the pointing device entered to\n            relatedTarget, // The EventTarget the pointing device exited from\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse left a cell tool\n                return;\n            }\n            view.mouseenter(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer remains inside the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            return;\n        }\n        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n        // (mouseenter method would be fired twice)\n        if (currentTarget === this.el) {\n            // `paper` (more descriptive), not `blank`\n            this.trigger('paper:mouseenter', evt);\n        }\n    },\n\n    mouseleave: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const {\n            target, // The EventTarget the pointing device exited from\n            relatedTarget, // The EventTarget the pointing device entered to\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse entered a cell tool\n                return;\n            }\n            view.mouseleave(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            // The pointer has entered a new cellView\n            return;\n        }\n        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n        // (mouseleave method would be fired twice)\n        if (currentTarget === this.el) {\n            // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger('paper:mouseleave', evt);\n        }\n    },\n\n    _processMouseWheelEvtBuf: debounce(function() {\n        const { event, deltas } = this._mw_evt_buffer;\n        const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n\n        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);\n        this.trigger('paper:pinch', event, x, y, scale);\n\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n    }, WHEEL_WAIT_MS, { maxWait: WHEEL_WAIT_MS }),\n\n    mousewheel: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        const originalEvent = evt.originalEvent;\n        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n        const { deltaX, deltaY } = normalizeWheel(originalEvent);\n\n        const pinchHandlers = this._events['paper:pinch'];\n\n        // Touchpad devices will send a fake CTRL press when a pinch is performed\n        //\n        // We also check if there are any subscribers to paper:pinch event. If there are none,\n        // just skip the entire block of code (we don't want to blindly call\n        // .preventDefault() if we really don't have to).\n        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n            originalEvent.preventDefault();\n            this._mw_evt_buffer.event = evt;\n            this._mw_evt_buffer.deltas.push(deltaY);\n            this._processMouseWheelEvtBuf();\n        } else {\n            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n            if (view) {\n                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n            } else {\n                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n            }\n\n            this.trigger('paper:pan', evt, deltaX, deltaY);\n        }\n    },\n\n    onevent: function(evt) {\n\n        var eventNode = evt.currentTarget;\n        var eventName = eventNode.getAttribute('event');\n        if (eventName) {\n            var view = this.findView(eventNode);\n            if (view) {\n\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    magnetEvent: function(evt, handler) {\n\n        var magnetNode = evt.currentTarget;\n        var magnetValue = magnetNode.getAttribute('magnet');\n        if (magnetValue) {\n            var view = this.findView(magnetNode);\n            if (view) {\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    onmagnet: function(evt) {\n\n        if (evt.button === 2) {\n            this.contextMenuFired = true;\n            this.magnetContextMenuFired = true;\n            const contextmenuEvt = new $.Event(evt.originalEvent, {\n                type: 'contextmenu',\n                data: evt.data,\n                currentTarget: evt.currentTarget,\n            });\n            this.magnetContextMenuTrigger(contextmenuEvt);\n            if (contextmenuEvt.isPropagationStopped()) {\n                evt.stopPropagation();\n            }\n        } else {\n            this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        }\n    },\n\n    magnetpointerdblclick: function(evt) {\n\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetpointerdblclick(evt, magnet, x, y);\n        });\n    },\n\n    magnetcontextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.magnetContextMenuFired) {\n            this.magnetContextMenuFired = false;\n            return;\n        }\n\n        this.magnetContextMenuTrigger(evt);\n    },\n\n    magnetContextMenuTrigger: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetcontextmenu(evt, magnet, x, y);\n        });\n    },\n\n    onlabel: function(evt) {\n\n        var labelNode = evt.currentTarget;\n\n        var view = this.findView(labelNode);\n        if (!view) return;\n\n        evt = normalizeEvent(evt);\n        if (this.guard(evt, view)) return;\n\n        // Custom event\n        const eventEvt = this.customEventTrigger(evt, view, labelNode);\n        if (eventEvt) {\n            // `onevent` could have stopped propagation\n            if (eventEvt.isPropagationStopped()) return;\n\n            evt.data = eventEvt.data;\n        }\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onlabel(evt, localPoint.x, localPoint.y);\n    },\n\n    getPointerArgs(evt) {\n        const normalizedEvt = normalizeEvent(evt);\n        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        return [normalizedEvt, x, y];\n    },\n\n    delegateDragEvents: function(view, data) {\n\n        data || (data = {});\n        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n        this.delegateDocumentEvents(null, data);\n    },\n\n    // Guard the specified event. If the event should be ignored, guard returns `true`.\n    // Otherwise, it returns `false`.\n    guard: function(evt, view) {\n\n        if (evt.type === 'mousedown' && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n\n        const { target } = evt;\n\n        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n            return true;\n        }\n\n        if (view && view.model && (view.model instanceof Cell)) {\n            return false;\n        }\n\n        if (this.el === target || this.svg.contains(target)) {\n            return false;\n        }\n\n        return true;    // Event guarded. Paper should not react on it in any way.\n    },\n\n    setGridSize: function(gridSize) {\n        const { options } = this;\n        options.gridSize = gridSize;\n        if (options.drawGrid && !options.drawGridSize) {\n            // Do not redraw the grid if the `drawGridSize` is set.\n            this.getLayerView(LayersNames.GRID).renderGrid();\n        }\n        return this;\n    },\n\n    setGrid: function(drawGrid) {\n        this.getLayerView(LayersNames.GRID).setGrid(drawGrid);\n        return this;\n    },\n\n    updateBackgroundImage: function(opt) {\n\n        opt = opt || {};\n\n        var backgroundPosition = opt.position || 'center';\n        var backgroundSize = opt.size || 'auto auto';\n\n        var currentScale = this.scale();\n        var currentTranslate = this.translate();\n\n        // backgroundPosition\n        if (isObject(backgroundPosition)) {\n            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n            backgroundPosition = x + 'px ' + y + 'px';\n        }\n\n        // backgroundSize\n        if (isObject(backgroundSize)) {\n            backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n        }\n\n        const { background } = this.childNodes;\n        background.style.backgroundSize = backgroundSize;\n        background.style.backgroundPosition = backgroundPosition;\n    },\n\n    drawBackgroundImage: function(img, opt) {\n\n        // Clear the background image if no image provided\n        if (!(img instanceof HTMLImageElement)) {\n            this.childNodes.background.style.backgroundImage = '';\n            return;\n        }\n\n        if (!this._background || this._background.id !== opt.id) {\n            // Draw only the last image requested (see drawBackground())\n            return;\n        }\n\n        opt = opt || {};\n\n        var backgroundImage;\n        var backgroundSize = opt.size;\n        var backgroundRepeat = opt.repeat || 'no-repeat';\n        var backgroundOpacity = opt.opacity || 1;\n        var backgroundQuality = Math.abs(opt.quality) || 1;\n        var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\n        if (isFunction(backgroundPattern)) {\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n            img.width *= backgroundQuality;\n            img.height *= backgroundQuality;\n            var canvas = backgroundPattern(img, opt);\n            if (!(canvas instanceof HTMLCanvasElement)) {\n                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n            }\n\n            backgroundImage = canvas.toDataURL('image/png');\n            backgroundRepeat = 'repeat';\n            if (isObject(backgroundSize)) {\n                // recalculate the tile size if an object passed in\n                backgroundSize.width *= canvas.width / img.width;\n                backgroundSize.height *= canvas.height / img.height;\n            } else if (backgroundSize === undefined) {\n                // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            }\n        } else {\n            // backgroundRepeat:\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n            backgroundImage = img.src;\n            if (backgroundSize === undefined) {\n                // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n        }\n\n        this.childNodes.background.style.opacity = backgroundOpacity;\n        this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n        this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n\n        this.updateBackgroundImage(opt);\n    },\n\n    updateBackgroundColor: function(color) {\n\n        this.$el.css('backgroundColor', color || '');\n    },\n\n    drawBackground: function(opt) {\n\n        opt = opt || {};\n\n        this.updateBackgroundColor(opt.color);\n\n        if (opt.image) {\n            opt = this._background = cloneDeep(opt);\n            guid(opt);\n            var img = document.createElement('img');\n            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n            img.src = opt.image;\n        } else {\n            this.drawBackgroundImage(null);\n            this._background = null;\n        }\n\n        return this;\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n\n        invoke(this._views, 'setInteractivity', value);\n    },\n\n    // Paper definitions.\n    // ------------------\n\n    isDefined: function(defId) {\n\n        return !!this.svg.getElementById(defId);\n    },\n\n    defineFilter: function(filter) {\n\n        if (!isObject(filter)) {\n            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n        }\n\n        var filterId = filter.id;\n        var name = filter.name;\n        // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        if (!filterId) {\n            filterId = name + this.svg.id + hashCode(JSON.stringify(filter));\n        }\n        // If the filter already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        // If not, create one.\n        if (!this.isDefined(filterId)) {\n\n            var namespace = _filter;\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n            if (!filterSVGString) {\n                throw new Error('Non-existing filter ' + name);\n            }\n\n            // SVG <filter/> attributes\n            var filterAttrs = assign({\n                filterUnits: 'userSpaceOnUse',\n            }, filter.attrs, {\n                id: filterId\n            });\n\n            V(filterSVGString, filterAttrs).appendTo(this.defs);\n        }\n\n        return filterId;\n    },\n\n    defineGradient: function(gradient) {\n        if (!isObject(gradient)) {\n            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            type,\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = type + svg.id + hashCode(JSON.stringify(gradient)),\n            stops,\n            attrs = {}\n        } = gradient;\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const stopVEls = toArray(stops).map(({ offset, color, opacity }) => {\n            return V('stop').attr({\n                'offset': offset,\n                'stop-color': color,\n                'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n            });\n        });\n        const gradientVEl = V(type, attrs, stopVEls);\n        gradientVEl.id = id;\n        gradientVEl.appendTo(defs);\n        return id;\n    },\n\n    definePattern: function(pattern) {\n        if (!isObject(pattern)) {\n            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + hashCode(JSON.stringify(pattern)),\n            markup,\n            attrs = {}\n        } = pattern;\n        if (!markup) {\n            throw new TypeError('dia.Paper: definePattern() requires markup.');\n        }\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const patternVEl = V('pattern', {\n            patternUnits: 'userSpaceOnUse'\n        });\n        patternVEl.id = id;\n        patternVEl.attr(attrs);\n        if (typeof markup === 'string') {\n            patternVEl.append(V(markup));\n        } else {\n            const { fragment } = parseDOMJSON(markup);\n            patternVEl.append(fragment);\n        }\n        patternVEl.appendTo(defs);\n        return id;\n    },\n\n    defineMarker: function(marker) {\n        if (!isObject(marker)) {\n            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + hashCode(JSON.stringify(marker)),\n            // user-provided markup\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n            markup,\n            // user-provided attributes\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n            // note: `transform` attrs are ignored by browsers\n            attrs = {},\n            // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n            markerUnits = 'userSpaceOnUse'\n        } = marker;\n        // If the marker already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const markerVEl = V('marker', {\n            orient: 'auto',\n            overflow: 'visible',\n            markerUnits: markerUnits\n        });\n        markerVEl.id = id;\n        markerVEl.attr(attrs);\n        let markerContentVEl;\n        if (markup) {\n            let markupVEl;\n            if (typeof markup === 'string') {\n                // Marker object has a `markup` property of type string.\n                // - Construct V from the provided string.\n                markupVEl = V(markup);\n                // `markupVEl` is now either a single VEl, or an array of VEls.\n                // - Coerce it to an array.\n                markupVEl = (Array.isArray(markupVEl) ? markupVEl : [markupVEl]);\n            } else {\n                // Marker object has a `markup` property of type object.\n                // - Construct V from the object by parsing it as DOM JSON.\n                const { fragment } = parseDOMJSON(markup);\n                markupVEl = V(fragment).children();\n            }\n            // `markupVEl` is an array with one or more VEls inside.\n            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n            if (markupVEl.length > 1) {\n                markerContentVEl = V('g').append(markupVEl);\n            } else {\n                markerContentVEl = markupVEl[0];\n            }\n        } else {\n            // Marker object is a flat structure.\n            // - Construct a new V of type `marker.type`.\n            const { type = 'path' } = marker;\n            markerContentVEl = V(type);\n        }\n        // `markerContentVEl` is a single VEl.\n        // Assign additional attributes to it (= context attributes + marker attributes):\n        // - Attribute values are taken from non-special properties of `marker`.\n        const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n        const markerAttrsKeys = Object.keys(markerAttrs);\n        markerAttrsKeys.forEach((key) => {\n            const value = markerAttrs[key];\n            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n            if (markupValue == null) {\n                // Default logic:\n                markerContentVEl.attr(key, value);\n            } else {\n                // Properties with special logic should be added as cases to this switch block:\n                switch(key) {\n                    case 'transform':\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, (value + ' ' + markupValue));\n                        break;\n                }\n            }\n        });\n        markerContentVEl.appendTo(markerVEl);\n        markerVEl.appendTo(defs);\n        return id;\n    },\n\n    customEventTrigger: function(evt, view, rootNode = view.el) {\n\n        const eventNode = evt.target.closest('[event]');\n\n        if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n            const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n                data: evt.data,\n                // Originally the event listener was attached to the event element.\n                currentTarget: eventNode\n            }));\n\n            this.onevent(eventEvt);\n\n            if (eventEvt.isDefaultPrevented()) {\n                evt.preventDefault();\n            }\n\n            return eventEvt;\n        }\n\n        return null;\n    }\n\n}, {\n\n    sorting: sortingTypes,\n\n    Layers: LayersNames,\n\n    backgroundPatterns: {\n\n        flipXy: function(img) {\n            // d b\n            // q p\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = 2 * imgWidth;\n            canvas.height = 2 * imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // top-left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // xy-flipped bottom-right image\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // x-flipped top-right image\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // y-flipped bottom-left image\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipX: function(img) {\n            // d b\n            // d b\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth * 2;\n            canvas.height = imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped right image\n            ctx.translate(2 * imgWidth, 0);\n            ctx.scale(-1, 1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipY: function(img) {\n            // d d\n            // q q\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth;\n            canvas.height = imgHeight * 2;\n\n            var ctx = canvas.getContext('2d');\n            // top image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped bottom image\n            ctx.translate(0, 2 * imgHeight);\n            ctx.scale(1, -1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        watermark: function(img, opt) {\n            //   d\n            // d\n\n            opt = opt || {};\n\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            var canvas = document.createElement('canvas');\n            canvas.width = imgWidth * 3;\n            canvas.height = imgHeight * 3;\n\n            var ctx = canvas.getContext('2d');\n            var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n            var radians = toRad(angle);\n            var stepX = canvas.width / 4;\n            var stepY = canvas.height / 4;\n\n            for (var i = 0; i < 4; i++) {\n                for (var j = 0; j < 4; j++) {\n                    if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n            }\n\n            return canvas;\n        }\n    },\n\n    gridPatterns: {\n        dot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                V(el).attr({\n                    width: opt.thickness,\n                    height: opt.thickness,\n                    fill: opt.color\n                });\n            }\n        }],\n        fixedDot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                V(el).attr({ fill: opt.color });\n            },\n            update: function(el, opt, paper) {\n                const { sx, sy } = paper.scale();\n                const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n                const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n                V(el).attr({ width, height });\n            }\n        }],\n        mesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }],\n        doubleMesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }, {\n            color: '#000000',\n            thickness: 3,\n            scaleFactor: 4,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }]\n    }\n});\n\n", "import * as mvc from '../mvc/index.mjs';\n\nexport const ToolView = mvc.View.extend({\n    name: null,\n    tagName: 'g',\n    className: 'tool',\n    svgElement: true,\n    _visible: true,\n    _visibleExplicit: true,\n\n    init: function() {\n        var name = this.name;\n        if (name) this.vel.attr('data-tool-name', name);\n    },\n\n    configure: function(view, toolsView) {\n        this.relatedView = view;\n        this.paper = view.paper;\n        this.parentView = toolsView;\n        this.simulateRelatedView(this.el);\n        // Delegate events in case the ToolView was removed from the DOM and reused.\n        this.delegateEvents();\n        return this;\n    },\n\n    simulateRelatedView: function(el) {\n        if (el) el.setAttribute('model-id', this.relatedView.model.id);\n    },\n\n    getName: function() {\n        return this.name;\n    },\n\n    // Evaluate the visibility of the tool and update the `display` CSS property\n    updateVisibility: function() {\n        const isVisible = this.computeVisibility();\n        this.el.style.display = isVisible ? '' : 'none';\n        this._visible = isVisible;\n    },\n\n    // Evaluate the visibility of the tool. The method returns `true` if the tool\n    // should be visible in the DOM.\n    computeVisibility() {\n        if (!this.isExplicitlyVisible()) return false;\n        const { visibility } = this.options;\n        if (typeof visibility !== 'function') return true;\n        return !!visibility.call(this, this.relatedView, this);\n    },\n\n    show: function() {\n        this._visibleExplicit = true;\n        this.updateVisibility();\n    },\n\n    hide: function() {\n        this._visibleExplicit = false;\n        this.updateVisibility();\n    },\n\n    // The method returns `false` if the `hide()` method was called on the tool.\n    isExplicitlyVisible: function() {\n        return !!this._visibleExplicit;\n    },\n\n    // The method returns `false` if the tool is not visible (it has `display: none`).\n    // This can happen if the `hide()` method was called or the tool is not visible\n    // because of the `visibility` option was evaluated to `false`.\n    isVisible: function() {\n        return !!this._visible;\n    },\n\n    focus: function() {\n        var opacity = this.options.focusOpacity;\n        if (isFinite(opacity)) this.el.style.opacity = opacity;\n        this.parentView.focusTool(this);\n    },\n\n    blur: function() {\n        this.el.style.opacity = '';\n        this.parentView.blurTool(this);\n    },\n\n    update: function() {\n        // to be overridden\n    },\n\n    guard: function(evt) {\n        // Let the context-menu event bubble up to the relatedView\n        const { paper, relatedView } = this;\n        if (!paper || !relatedView) return true;\n        return paper.guard(evt, relatedView);\n    }\n});\n\n", "import * as mvc from '../mvc/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { LayersNames } from './PaperLayer.mjs';\nimport { ToolView } from './ToolView.mjs';\n\nexport const ToolsView = mvc.View.extend({\n    tagName: 'g',\n    className: 'tools',\n    svgElement: true,\n    tools: null,\n    isRendered: false,\n    options: {\n        tools: null,\n        relatedView: null,\n        name: null,\n        // layer?: LayersNames.TOOLS\n        // z?: number\n    },\n\n    configure: function(options) {\n        options = util.assign(this.options, options);\n        var tools = options.tools;\n        if (!Array.isArray(tools)) return this;\n        var relatedView = options.relatedView;\n        if (!(relatedView instanceof CellView)) return this;\n        var views = this.tools = [];\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (!(tool instanceof ToolView)) continue;\n            tool.configure(relatedView, this);\n            this.vel.append(tool.el);\n            views.push(tool);\n        }\n        this.isRendered = false;\n        relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n        return this;\n    },\n\n    getName: function() {\n        return this.options.name;\n    },\n\n    update: function(opt) {\n\n        opt || (opt = {});\n        const tools = this.tools;\n        if (!tools) return this;\n        const n = tools.length;\n        const wasRendered = this.isRendered;\n        for (let i = 0; i < n; i++) {\n            const tool = tools[i];\n            tool.updateVisibility();\n            if (!tool.isVisible()) continue;\n            if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {\n                tool.update();\n            }\n        }\n        if (!this.isRendered && n > 0) {\n            // None of the tools is visible\n            // Note: ToolsView with no tools are always mounted\n            return this;\n        }\n        if (!this.isMounted()) {\n            this.mount();\n        }\n        if (!wasRendered) {\n            // Make sure tools are visible (if they were hidden and the tool removed)\n            this.blurTool();\n        }\n        return this;\n    },\n\n    ensureToolRendered(tools, i) {\n        if (!this.isRendered) {\n            // There is at least one visible tool\n            this.isRendered = Array(tools.length).fill(false);\n        }\n        if (!this.isRendered[i]) {\n            // First update executes render()\n            tools[i].render();\n            this.isRendered[i] = true;\n            return false;\n        }\n        return true;\n    },\n\n    focusTool: function(focusedTool) {\n\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (focusedTool === tool) {\n                tool.show();\n            } else {\n                tool.hide();\n            }\n        }\n        return this;\n    },\n\n    blurTool: function(blurredTool) {\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (tool !== blurredTool && !tool.isExplicitlyVisible()) {\n                tool.show();\n                // Check if the tool is conditionally visible too\n                if (tool.isVisible()) {\n                    this.ensureToolRendered(tools, i) && tool.update();\n                }\n            }\n        }\n        return this;\n    },\n\n    hide: function() {\n        return this.focusTool(null);\n    },\n\n    show: function() {\n        this.blurTool(null);\n        // If this the first time the tools are shown, make sure they are mounted\n        if (!this.isMounted()) {\n            this.mount();\n        }\n        return this;\n    },\n\n    onRemove: function() {\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            tools[i].remove();\n        }\n        this.tools = null;\n    },\n\n    mount: function() {\n        const { options, el } = this;\n        const { relatedView, layer = LayersNames.TOOLS, z } = options;\n        if (relatedView) {\n            if (layer) {\n                relatedView.paper.getLayerView(layer).insertSortedNode(el, z);\n            } else {\n                relatedView.el.appendChild(el);\n            }\n        }\n        return this;\n    }\n\n});\n", "export * from './Vertices.mjs';\nexport * from './Segments.mjs';\nexport * from './Arrowhead.mjs';\nexport * from './Anchor.mjs';\nexport * from './RotateLabel.mjs';\n\nexport * from '../cellTools/Button.mjs';\nexport * from '../cellTools/Boundary.mjs';\nexport * from '../cellTools/Connect.mjs';\nexport * from '../cellTools/HoverConnect.mjs';\nexport * from '../cellTools/Control.mjs';\n", "import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport * as mvc from '../mvc/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\nimport V from '../V/index.mjs';\n\n\n// Vertex Handles\nvar VertexHandle = mvc.View.extend({\n    tagName: 'circle',\n    svgElement: true,\n    className: 'marker-vertex',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onDoubleClick',\n        dbltap: 'onDoubleClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    attributes: {\n        'r': 6,\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move'\n    },\n    position: function(x, y) {\n        const { vel, options } = this;\n        const { scale } = options;\n        let matrix = V.createSVGMatrix().translate(x, y);\n        if (scale) matrix = matrix.scale(scale);\n        vel.transform(matrix, { absolute: true });\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n        this.trigger('will-change', this, evt);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onDoubleClick: function(evt) {\n        this.trigger('remove', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.trigger('changed', this, evt);\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n    }\n});\n\nexport const Vertices = ToolView.extend({\n    name: 'vertices',\n    options: {\n        handleClass: VertexHandle,\n        snapRadius: 20,\n        redundancyRemoval: true,\n        vertexAdding: true,\n        // vertexRemoving: true,\n        // vertexMoving: true,\n        stopPropagation: true,\n        scale: null\n    },\n    children: [{\n        tagName: 'path',\n        selector: 'connection',\n        className: 'joint-vertices-path',\n        attributes: {\n            'fill': 'none',\n            'stroke': 'transparent',\n            'stroke-width': 10,\n            'cursor': 'cell'\n        }\n    }],\n    handles: null,\n    interactiveLinkNode: null,\n    events: {\n        'mousedown .joint-vertices-path': 'onPathPointerDown',\n        'touchstart .joint-vertices-path': 'onPathPointerDown'\n    },\n    linkEvents: {\n        mousedown: 'onLinkPointerDown',\n        touchstart: 'onLinkPointerDown'\n    },\n    onRender: function() {\n        const { vertexAdding } = this.options;\n        if (vertexAdding) {\n            const { interactiveLinkNode = null } = vertexAdding;\n            if (interactiveLinkNode) {\n                this.delegateLinkEvents(interactiveLinkNode);\n            } else {\n                this.renderChildren();\n                this.updatePath();\n            }\n        }\n        this.resetHandles();\n        this.renderHandles();\n        return this;\n    },\n    delegateLinkEvents: function(selector) {\n        this.undelegateLinkEvents();\n        const el = this.relatedView.findNode(selector);\n        if (!el) {\n            console.warn(`Interactive link node \"${selector}\" not found.`);\n            return;\n        }\n        el.classList.add('joint-vertices-path');\n        this.interactiveLinkNode = el;\n        this.delegateElementEvents(el, this.linkEvents);\n    },\n    undelegateLinkEvents: function() {\n        const el = this.interactiveLinkNode;\n        if (!el) return;\n        this.undelegateElementEvents(el);\n        el.classList.remove('joint-vertices-path');\n        this.interactiveLinkNode = null;\n    },\n    update: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        if (vertices.length === this.handles.length) {\n            this.updateHandles();\n        } else {\n            this.resetHandles();\n            this.renderHandles();\n        }\n        if (this.options.vertexAdding) {\n            this.updatePath();\n        }\n        return this;\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    renderHandles: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        for (var i = 0, n = vertices.length; i < n; i++) {\n            var vertex = vertices[i];\n            var handle = new (this.options.handleClass)({\n                index: i,\n                paper: this.paper,\n                scale: this.options.scale,\n                guard: evt => this.guard(evt)\n            });\n            handle.render();\n            handle.position(vertex.x, vertex.y);\n            this.simulateRelatedView(handle.el);\n            handle.vel.appendTo(this.el);\n            this.handles.push(handle);\n            this.startHandleListening(handle);\n        }\n    },\n    updateHandles: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        for (var i = 0, n = vertices.length; i < n; i++) {\n            var vertex = vertices[i];\n            var handle = this.handles[i];\n            if (!handle) return;\n            handle.position(vertex.x, vertex.y);\n        }\n    },\n    updatePath: function() {\n        if (this.interactiveLinkNode) return;\n        const connection = this.childNodes.connection;\n        if (connection) connection.setAttribute('d', this.relatedView.getSerializedConnection());\n    },\n    startHandleListening: function(handle) {\n        const { vertexRemoving = true, vertexMoving = true } = this.options;\n        if (vertexMoving) {\n            this.listenTo(handle, 'will-change', this.onHandleWillChange);\n            this.listenTo(handle, 'changing', this.onHandleChanging);\n            this.listenTo(handle, 'changed', this.onHandleChanged);\n        }\n        if (vertexRemoving) {\n            this.listenTo(handle, 'remove', this.onHandleRemove);\n        }\n    },\n    getNeighborPoints: function(index) {\n        var linkView = this.relatedView;\n        var vertices = linkView.model.vertices();\n        var prev = (index > 0) ? vertices[index - 1] : linkView.sourceAnchor;\n        var next = (index < vertices.length - 1) ? vertices[index + 1] : linkView.targetAnchor;\n        return {\n            prev: new g.Point(prev),\n            next: new g.Point(next)\n        };\n    },\n    onHandleWillChange: function(_handle, evt) {\n        this.focus();\n        const { relatedView, options } = this;\n        relatedView.model.startBatch('vertex-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));\n    },\n    onHandleChanging: function(handle, evt) {\n        const { options, relatedView: linkView } = this;\n        var index = handle.options.index;\n        var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);\n        var vertex = { x, y };\n        this.snapVertex(vertex, index);\n        linkView.model.vertex(index, vertex, { ui: true, tool: this.cid });\n        handle.position(vertex.x, vertex.y);\n        if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);\n    },\n    onHandleChanged: function(_handle, evt) {\n        const { options, relatedView: linkView } = this;\n        if (options.vertexAdding) this.updatePath();\n        if (!options.redundancyRemoval) {\n            linkView.checkMouseleave(util.normalizeEvent(evt));\n            return;\n        }\n        var verticesRemoved = linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        if (verticesRemoved) this.render();\n        this.blur();\n        linkView.model.stopBatch('vertex-move', { ui: true, tool: this.cid });\n        if (this.eventData(evt).vertexAdded) {\n            linkView.model.stopBatch('vertex-add', { ui: true, tool: this.cid });\n        }\n        var [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);\n        linkView.checkMouseleave(normalizedEvt);\n    },\n    snapVertex: function(vertex, index) {\n        var snapRadius = this.options.snapRadius;\n        if (snapRadius > 0) {\n            var neighbors = this.getNeighborPoints(index);\n            var prev = neighbors.prev;\n            var next = neighbors.next;\n            if (Math.abs(vertex.x - prev.x) < snapRadius) {\n                vertex.x = prev.x;\n            } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n                vertex.x = next.x;\n            }\n            if (Math.abs(vertex.y - prev.y) < snapRadius) {\n                vertex.y = neighbors.prev.y;\n            } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n                vertex.y = next.y;\n            }\n        }\n    },\n    onHandleRemove: function(handle, evt) {\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        linkView.model.removeVertex(index, { ui: true });\n        if (this.options.vertexAdding) this.updatePath();\n        linkView.checkMouseleave(util.normalizeEvent(evt));\n    },\n    onPathPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var normalizedEvent = util.normalizeEvent(evt);\n        var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n        var relatedView = this.relatedView;\n        relatedView.model.startBatch('vertex-add', { ui: true, tool: this.cid });\n        var index = relatedView.getVertexIndex(vertex.x, vertex.y);\n        this.snapVertex(vertex, index);\n        relatedView.model.insertVertex(index, vertex, { ui: true, tool: this.cid });\n        this.update();\n        var handle = this.handles[index];\n        this.eventData(normalizedEvent, { vertexAdded: true });\n        handle.onPointerDown(normalizedEvent);\n    },\n    onLinkPointerDown: function(evt) {\n        this.relatedView.preventDefaultInteraction(evt);\n        this.onPathPointerDown(evt);\n    },\n    onRemove: function() {\n        this.resetHandles();\n        this.undelegateLinkEvents();\n    }\n}, {\n    VertexHandle: VertexHandle // keep as class property\n});\n", "import * as connectionStrategies from '../connectionStrategies/index.mjs';\n\nexport function getViewBBox(view, useModelGeometry) {\n    const { model } = view;\n    if (useModelGeometry) return model.getBBox();\n    return (model.isLink()) ? view.getConnection().bbox() : view.getNodeUnrotatedBBox(view.el);\n}\n\nexport function getAnchor(coords, view, magnet) {\n    // take advantage of an existing logic inside of the\n    // pin relative connection strategy\n    var end = connectionStrategies.pinRelative.call(\n        this.paper,\n        {},\n        view,\n        magnet,\n        coords,\n        this.model\n    );\n    return end.anchor;\n}\n\nexport function snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n    var snapRadius = toolView.options.snapRadius;\n    var isSource = (type === 'source');\n    var refIndex = (isSource ? 0 : -1);\n    var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n    if (ref) {\n        if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;\n        if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;\n    }\n    return coords;\n}\n", "import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\nimport * as mvc from '../mvc/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\nimport { getAnchor } from '../cellTools/helpers.mjs';\n\nvar SegmentHandle = mvc.View.extend({\n    tagName: 'g',\n    svgElement: true,\n    className: 'marker-segment',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    children: [{\n        tagName: 'line',\n        selector: 'line',\n        attributes: {\n            'stroke': '#33334F',\n            'stroke-width': 2,\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'handle',\n        attributes: {\n            'width': 20,\n            'height': 8,\n            'x': -10,\n            'y': -4,\n            'rx': 4,\n            'ry': 4,\n            'fill': '#33334F',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2\n        }\n    }],\n    onRender: function() {\n        this.renderChildren();\n    },\n    position: function(x, y, angle, view) {\n        const { scale } = this.options;\n        let matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n        if (scale) matrix = matrix.scale(scale);\n\n        var handle = this.childNodes.handle;\n        handle.setAttribute('transform', V.matrixToTransformString(matrix));\n        handle.setAttribute('cursor', (angle % 180 === 0) ? 'row-resize' : 'col-resize');\n\n        var viewPoint = view.getClosestPoint(new g.Point(x, y));\n        var line = this.childNodes.line;\n        line.setAttribute('x1', x);\n        line.setAttribute('y1', y);\n        line.setAttribute('x2', viewPoint.x);\n        line.setAttribute('y2', viewPoint.y);\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        this.trigger('change:start', this, evt);\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n        this.trigger('change:end', this, evt);\n    },\n    show: function() {\n        this.el.style.display = '';\n    },\n    hide: function() {\n        this.el.style.display = 'none';\n    }\n});\n\nexport const Segments = ToolView.extend({\n    name: 'segments',\n    precision: .5,\n    options: {\n        handleClass: SegmentHandle,\n        segmentLengthThreshold: 40,\n        redundancyRemoval: true,\n        anchor: getAnchor,\n        snapRadius: 10,\n        snapHandle: true,\n        stopPropagation: true\n    },\n    handles: null,\n    onRender: function() {\n        this.resetHandles();\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        vertices.unshift(relatedView.sourcePoint);\n        vertices.push(relatedView.targetPoint);\n        for (var i = 0, n = vertices.length; i < n - 1; i++) {\n            var vertex = vertices[i];\n            var nextVertex = vertices[i + 1];\n            var handle = this.renderHandle(vertex, nextVertex);\n            this.simulateRelatedView(handle.el);\n            this.handles.push(handle);\n            handle.options.index = i;\n        }\n        return this;\n    },\n    renderHandle: function(vertex, nextVertex) {\n        var handle = new (this.options.handleClass)({\n            paper: this.paper,\n            scale: this.options.scale,\n            guard: evt => this.guard(evt)\n        });\n        handle.render();\n        this.updateHandle(handle, vertex, nextVertex);\n        handle.vel.appendTo(this.el);\n        this.startHandleListening(handle);\n        return handle;\n    },\n    update: function() {\n        this.render();\n        return this;\n    },\n    startHandleListening: function(handle) {\n        this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n        this.listenTo(handle, 'changing', this.onHandleChanging);\n        this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    shiftHandleIndexes: function(value) {\n        var handles = this.handles;\n        for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n    },\n    resetAnchor: function(type, anchor) {\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    snapHandle: function(handle, position, data) {\n\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        var link = linkView.model;\n        var vertices = link.vertices();\n        var axis = handle.options.axis;\n        var prev = vertices[index - 2] || data.sourceAnchor;\n        var next = vertices[index + 1] || data.targetAnchor;\n        var snapRadius = this.options.snapRadius;\n        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n            position[axis] = prev[axis];\n        } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n            position[axis] = next[axis];\n        }\n        return position;\n    },\n\n    onHandleChanging: function(handle, evt) {\n\n        const { options } = this;\n        var data = this.eventData(evt);\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var index = handle.options.index - 1;\n        var normalizedEvent = util.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        var position = this.snapHandle(handle, coords.clone(), data);\n        var axis = handle.options.axis;\n        var offset = (this.options.snapHandle) ? 0 : (coords[axis] - position[axis]);\n        var link = relatedView.model;\n        var vertices = util.cloneDeep(link.vertices());\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn !== 'function') anchorFn = null;\n\n        const handleIndex = handle.options.index;\n\n        const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n        let indexOffset = 0;\n\n        // check if vertex before handle vertex exists\n        if (handleIndex - 1 >= 0) {\n            const v1 = vertexPoints[handleIndex - 1];\n            const v2 = vertexPoints[handleIndex];\n\n            const theta = new g.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n                indexOffset++;\n                this.shiftHandleIndexes(1);\n            }\n        }\n\n        var vertex = vertices[index + indexOffset];\n        var nextVertex = vertices[index + 1 + indexOffset];\n\n        // check if vertex after handle vertex exists\n        if (handleIndex + 2 < vertexPoints.length) {\n            const v1 = vertexPoints[handleIndex + 1];\n            const v2 = vertexPoints[handleIndex + 2];\n\n            const theta = new g.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                const isSingleVertex = data.originalVertices.length === 1;\n                const origVIndex = isSingleVertex ? 0 : handleIndex;\n                const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n                let nextVIndex = 1 + indexOffset;\n                vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n            }\n        }\n\n        // First Segment\n        var sourceView = relatedView.sourceView;\n        var sourceBBox = relatedView.sourceBBox;\n        var changeSourceAnchor = false;\n        var deleteSourceAnchor = false;\n        if (!vertex) {\n            vertex = relatedView.sourceAnchor.toJSON();\n            vertex[axis] = position[axis];\n            if (sourceBBox.containsPoint(vertex)) {\n                vertex[axis] = position[axis];\n                changeSourceAnchor = true;\n            } else {\n                // we left the area of the source magnet for the first time\n                vertices.unshift(vertex);\n                this.shiftHandleIndexes(1);\n                data.firstHandleShifted = true;\n                deleteSourceAnchor = true;\n            }\n        } else if (index === 0) {\n            if (sourceBBox.containsPoint(vertex)) {\n                vertices.shift();\n                this.shiftHandleIndexes(-1);\n                changeSourceAnchor = true;\n            } else {\n                vertex[axis] = position[axis];\n                deleteSourceAnchor = true;\n            }\n        } else {\n            vertex[axis] = position[axis];\n        }\n\n        if (anchorFn && sourceView) {\n            if (changeSourceAnchor) {\n                var sourceAnchorPosition = data.sourceAnchor.clone();\n                sourceAnchorPosition[axis] = position[axis];\n                var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n                this.resetAnchor('source', sourceAnchor);\n            }\n            if (deleteSourceAnchor) {\n                this.resetAnchor('source', data.sourceAnchorDef);\n            }\n        }\n\n        // Last segment\n        var targetView = relatedView.targetView;\n        var targetBBox = relatedView.targetBBox;\n        var changeTargetAnchor = false;\n        var deleteTargetAnchor = false;\n        if (!nextVertex) {\n            nextVertex = relatedView.targetAnchor.toJSON();\n            nextVertex[axis] = position[axis];\n            if (targetBBox.containsPoint(nextVertex)) {\n                changeTargetAnchor = true;\n            } else {\n                // we left the area of the target magnet for the first time\n                vertices.push(nextVertex);\n                deleteTargetAnchor = true;\n            }\n        } else if (index === vertices.length - 2) {\n            if (targetBBox.containsPoint(nextVertex)) {\n                vertices.pop();\n                changeTargetAnchor = true;\n            } else {\n                nextVertex[axis] = position[axis];\n                deleteTargetAnchor = true;\n            }\n        } else {\n            nextVertex[axis] = position[axis];\n        }\n\n        if (anchorFn && targetView) {\n            if (changeTargetAnchor) {\n                var targetAnchorPosition = data.targetAnchor.clone();\n                targetAnchorPosition[axis] = position[axis];\n                var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n                this.resetAnchor('target', targetAnchor);\n            }\n            if (deleteTargetAnchor) {\n                this.resetAnchor('target', data.targetAnchorDef);\n            }\n        }\n        if (vertices.some(v => !v)) {\n            // This can happen when the link is using a smart routing and the number of\n            // vertices is not the same as the number of route points.\n            throw new Error('Segments: incompatible router in use');\n        }\n        link.vertices(vertices, { ui: true, tool: this.cid });\n        this.updateHandle(handle, vertex, nextVertex, offset);\n        if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onHandleChangeStart: function(handle, evt) {\n        const { options, handles, relatedView: linkView } = this;\n        const { model, paper } = linkView;\n        var index = handle.options.index;\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            if (i !== index) handles[i].hide();\n        }\n        this.focus();\n        this.eventData(evt, {\n            sourceAnchor: linkView.sourceAnchor.clone(),\n            targetAnchor: linkView.targetAnchor.clone(),\n            sourceAnchorDef: util.clone(model.prop(['source', 'anchor'])),\n            targetAnchorDef: util.clone(model.prop(['target', 'anchor'])),\n            originalVertices: util.cloneDeep(model.vertices()),\n            firstHandleShifted: false\n        });\n        model.startBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onHandleChangeEnd: function(_handle, evt) {\n        const { options, relatedView: linkView }= this;\n        const { paper, model } = linkView;\n        if (options.redundancyRemoval) {\n            linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        }\n        const normalizedEvent = util.normalizeEvent(evt);\n        const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.render();\n        this.blur();\n        model.stopBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n        linkView.checkMouseleave(normalizedEvent);\n    },\n    updateHandle: function(handle, vertex, nextVertex, offset) {\n        var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n        var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n        if (vertical || horizontal) {\n            var segmentLine = new g.Line(vertex, nextVertex);\n            var length = segmentLine.length();\n            if (length < this.options.segmentLengthThreshold) {\n                handle.hide();\n            } else {\n                var position = segmentLine.midpoint();\n                var axis = (vertical) ? 'x' : 'y';\n                position[axis] += offset || 0;\n                var angle = segmentLine.vector().vectorAngle(new g.Point(1, 0));\n                handle.position(position.x, position.y, angle, this.relatedView);\n                handle.show();\n                handle.options.axis = axis;\n            }\n        } else {\n            handle.hide();\n        }\n    },\n    onRemove: function() {\n        this.resetHandles();\n    }\n}, {\n    SegmentHandle: SegmentHandle // keep as class property\n});\n", "import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\n\n// End Markers\nconst Arrowhead = ToolView.extend({\n    tagName: 'path',\n    xAxisVector: new g.Point(1, 0),\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        scale: null\n    },\n    onRender: function() {\n        this.update();\n    },\n    update: function() {\n        var ratio = this.ratio;\n        var view = this.relatedView;\n        var tangent = view.getTangentAtRatio(ratio);\n        var position, angle;\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n        } else {\n            position = view.getPointAtRatio(ratio);\n            angle = 0;\n        }\n        if (!position) return this;\n        var matrix = V.createSVGMatrix().translate(position.x, position.y).rotate(angle);\n        const { scale } = this.options;\n        if (scale) matrix = matrix.scale(scale);\n        this.vel.transform(matrix, { absolute: true });\n        return this;\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        relatedView.model.startBatch('arrowhead-move', { ui: true, tool: this.cid });\n        relatedView.startArrowheadMove(this.arrowheadType);\n        const data = evt.data || (evt.data = {});\n        this.delegateDocumentEvents(null, data);\n        paper.undelegateEvents();\n        this.focus();\n        this.el.style.pointerEvents = 'none';\n        relatedView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onPointerMove: function(evt) {\n        var normalizedEvent = util.normalizeEvent(evt);\n        var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var normalizedEvent = util.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n        paper.delegateEvents();\n        this.blur();\n        this.el.style.pointerEvents = '';\n        relatedView.model.stopBatch('arrowhead-move', { ui: true, tool: this.cid });\n    }\n});\n\nexport const TargetArrowhead = Arrowhead.extend({\n    name: 'target-arrowhead',\n    ratio: 1,\n    arrowheadType: 'target',\n    attributes: {\n        'd': 'M -10 -8 10 0 -10 8 Z',\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move',\n        'class': 'target-arrowhead'\n    }\n});\n\nexport const SourceArrowhead = Arrowhead.extend({\n    name: 'source-arrowhead',\n    ratio: 0,\n    arrowheadType: 'source',\n    attributes: {\n        'd': 'M 10 -8 -10 0 10 8 Z',\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move',\n        'class': 'source-arrowhead'\n    }\n});\n", "import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\nimport { getAnchor, snapAnchor } from '../cellTools/helpers.mjs';\n\nconst Anchor = ToolView.extend({\n    tagName: 'g',\n    type: null,\n    children: [{\n        tagName: 'circle',\n        selector: 'anchor',\n        attributes: {\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'area',\n        attributes: {\n            'pointer-events': 'none',\n            'fill': 'none',\n            'stroke': '#33334F',\n            'stroke-dasharray': '2,4',\n            'rx': 5,\n            'ry': 5\n        }\n    }],\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onPointerDblClick',\n        dbltap: 'onPointerDblClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        snap: snapAnchor,\n        anchor: getAnchor,\n        scale: null,\n        resetAnchor: true,\n        customAnchorAttributes: {\n            'stroke-width': 4,\n            'stroke': '#33334F',\n            'fill': '#FFFFFF',\n            'r': 5\n        },\n        defaultAnchorAttributes: {\n            'stroke-width': 2,\n            'stroke': '#FFFFFF',\n            'fill': '#33334F',\n            'r': 6\n        },\n        areaPadding: 6,\n        snapRadius: 10,\n        restrictArea: true,\n        redundancyRemoval: true\n    },\n    onRender: function() {\n        this.renderChildren();\n        this.toggleArea(false);\n        this.update();\n    },\n    update: function() {\n        var type = this.type;\n        var relatedView = this.relatedView;\n        var view = relatedView.getEndView(type);\n        if (view) {\n            this.updateAnchor();\n            this.updateArea();\n            this.el.style.display = '';\n        } else {\n            this.el.style.display = 'none';\n        }\n        return this;\n    },\n    updateAnchor: function() {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var anchorNode = childNodes.anchor;\n        if (!anchorNode) return;\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var position = relatedView.getEndAnchor(type);\n        var options = this.options;\n        var customAnchor = relatedView.model.prop([type, 'anchor']);\n        let transformString =  `translate(${position.x},${position.y})`;\n        if (options.scale) {\n            transformString += ` scale(${options.scale})`;\n        }\n        anchorNode.setAttribute('transform', transformString);\n        var anchorAttributes = (customAnchor) ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n        for (var attrName in anchorAttributes) {\n            anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n        }\n    },\n    updateArea: function() {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var areaNode = childNodes.area;\n        if (!areaNode) return;\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var view = relatedView.getEndView(type);\n        var model = view.model;\n        var magnet = relatedView.getEndMagnet(type);\n        var padding = this.options.areaPadding;\n        if (!isFinite(padding)) padding = 0;\n        var bbox, angle, center;\n        if (view.isNodeConnection(magnet)) {\n            bbox = view.getNodeBBox(magnet);\n            angle = 0;\n            center = bbox.center();\n        } else {\n            bbox = view.getNodeUnrotatedBBox(magnet);\n            angle = model.angle();\n            center = bbox.center();\n            if (angle) center.rotate(model.getBBox().center(), -angle);\n            // TODO: get the link's magnet rotation into account\n        }\n        bbox.inflate(padding);\n        areaNode.setAttribute('x', -bbox.width / 2);\n        areaNode.setAttribute('y', -bbox.height / 2);\n        areaNode.setAttribute('width', bbox.width);\n        areaNode.setAttribute('height', bbox.height);\n        areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n    },\n    toggleArea: function(visible) {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var areaNode = childNodes.area;\n        if (!areaNode) return;\n        areaNode.style.display = (visible) ? '' : 'none';\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.paper.undelegateEvents();\n        this.delegateDocumentEvents();\n        this.focus();\n        this.toggleArea(this.options.restrictArea);\n        this.relatedView.model.startBatch('anchor-move', { ui: true, tool: this.cid });\n    },\n    resetAnchor: function(anchor) {\n        var type = this.type;\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    onPointerMove: function(evt) {\n\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var view = relatedView.getEndView(type);\n        var model = view.model;\n        var magnet = relatedView.getEndMagnet(type);\n        var normalizedEvent = util.normalizeEvent(evt);\n        var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n        var snapFn = this.options.snap;\n        if (typeof snapFn === 'function') {\n            coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n            coords = new g.Point(coords);\n        }\n\n        if (this.options.restrictArea) {\n            if (view.isNodeConnection(magnet)) {\n                // snap coords to the link's connection\n                var pointAtConnection = view.getClosestPoint(coords);\n                if (pointAtConnection) coords = pointAtConnection;\n            } else {\n                // snap coords within node bbox\n                var bbox = view.getNodeUnrotatedBBox(magnet);\n                var angle = model.angle();\n                var origin = model.getBBox().center();\n                var rotatedCoords = coords.clone().rotate(origin, angle);\n                if (!bbox.containsPoint(rotatedCoords)) {\n                    coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n                }\n            }\n        }\n\n        var anchor;\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn === 'function') {\n            anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n        }\n\n        this.resetAnchor(anchor);\n        this.update();\n    },\n\n    onPointerUp: function(evt) {\n        const normalizedEvent = util.normalizeEvent(evt);\n        this.paper.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleArea(false);\n        var linkView = this.relatedView;\n        if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        linkView.checkMouseleave(normalizedEvent);\n        linkView.model.stopBatch('anchor-move', { ui: true, tool: this.cid });\n    },\n\n    onPointerDblClick: function() {\n        var anchor = this.options.resetAnchor;\n        if (anchor === false) return; // reset anchor disabled\n        if (anchor === true) anchor = null; // remove the current anchor\n        this.resetAnchor(util.cloneDeep(anchor));\n        this.update();\n    }\n});\n\nexport const SourceAnchor = Anchor.extend({\n    name: 'source-anchor',\n    type: 'source'\n});\n\nexport const TargetAnchor = Anchor.extend({\n    name: 'target-anchor',\n    type: 'target'\n});\n", "import { ToolView } from '../dia/ToolView.mjs';\nimport * as util from '../util/index.mjs';\n\nexport const Control = ToolView.extend({\n    tagName: 'g',\n    children: [{\n        tagName: 'circle',\n        selector: 'handle',\n        attributes: {\n            'cursor': 'pointer',\n            'stroke-width': 2,\n            'stroke': '#FFFFFF',\n            'fill': '#33334F',\n            'r': 6\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'extras',\n        attributes: {\n            'pointer-events': 'none',\n            'fill': 'none',\n            'stroke': '#33334F',\n            'stroke-dasharray': '2,4',\n            'rx': 5,\n            'ry': 5\n        }\n    }],\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onPointerDblClick',\n        dbltap: 'onPointerDblClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        handleAttributes: null,\n        selector: 'root',\n        padding: 6,\n        scale: null\n    },\n\n    getPosition: function() {\n        // To be overridden\n    },\n    setPosition: function() {\n        // To be overridden\n    },\n    resetPosition: function() {\n        // To be overridden\n    },\n    onRender: function() {\n        this.renderChildren();\n        this.toggleExtras(false);\n        this.update();\n    },\n    update: function() {\n        const { handle, extras } = this.childNodes;\n        if (handle) {\n            this.updateHandle(handle);\n        } else {\n            throw new Error('Control: markup selector `handle` is required');\n        }\n        if (extras) {\n            this.updateExtras(extras);\n        }\n        return this;\n    },\n    updateHandle: function(handleNode) {\n        const { relatedView, options } = this;\n        const { model } = relatedView;\n        const relativePos = this.getPosition(relatedView, this);\n        const absolutePos = model.getAbsolutePointFromRelative(relativePos);\n        const { handleAttributes, scale } = options;\n        let transformString =  `translate(${absolutePos.x},${absolutePos.y})`;\n        if (scale) {\n            transformString += ` scale(${scale})`;\n        }\n        handleNode.setAttribute('transform', transformString);\n        if (handleAttributes) {\n            for (let attrName in handleAttributes) {\n                handleNode.setAttribute(attrName, handleAttributes[attrName]);\n            }\n        }\n    },\n    updateExtras: function(extrasNode) {\n        const { relatedView, options } = this;\n        const { selector } = this.options;\n        if (!selector) {\n            this.toggleExtras(false);\n            return;\n        }\n        const magnet = relatedView.findNode(selector);\n        if (!magnet) throw new Error('Control: invalid selector.');\n        let padding = options.padding;\n        if (!isFinite(padding)) padding = 0;\n        const bbox = relatedView.getNodeUnrotatedBBox(magnet);\n        const model = relatedView.model;\n        const angle = model.angle();\n        const center = bbox.center();\n        if (angle) center.rotate(model.getBBox().center(), -angle);\n        bbox.inflate(padding);\n        extrasNode.setAttribute('x', -bbox.width / 2);\n        extrasNode.setAttribute('y', -bbox.height / 2);\n        extrasNode.setAttribute('width', bbox.width);\n        extrasNode.setAttribute('height', bbox.height);\n        extrasNode.setAttribute('transform', `translate(${center.x},${center.y}) rotate(${angle})`);\n    },\n    toggleExtras: function(visible) {\n        const { extras } = this.childNodes;\n        if (!extras) return;\n        extras.style.display = (visible) ? '' : 'none';\n    },\n    onPointerDown: function(evt) {\n        const { relatedView, paper } = this;\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        paper.undelegateEvents();\n        this.delegateDocumentEvents();\n        this.focus();\n        this.toggleExtras(true);\n        relatedView.model.startBatch('control-move', { ui: true, tool: this.cid });\n    },\n    onPointerMove: function(evt) {\n        const { relatedView, paper } = this;\n        const { model } = relatedView;\n        const { clientX, clientY } = util.normalizeEvent(evt);\n        const coords = paper.clientToLocalPoint(clientX, clientY);\n        const relativeCoords = model.getRelativePointFromAbsolute(coords);\n        this.setPosition(relatedView, relativeCoords, evt);\n        this.update();\n    },\n    onPointerUp: function(_evt) {\n        const { relatedView, paper } = this;\n        paper.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleExtras(false);\n        relatedView.model.stopBatch('control-move', { ui: true, tool: this.cid });\n    },\n    onPointerDblClick: function(evt) {\n        const { relatedView } = this;\n        this.resetPosition(relatedView, evt);\n        this.update();\n    }\n\n});\n", "import * as g from '../g/index.mjs';\nimport { Control } from '../cellTools/Control.mjs';\n\nexport const RotateLabel = Control.extend({\n\n    xAxisVector: new g.Point(1, 0),\n\n    children() {\n        const {\n            buttonColor = '#333',\n            iconColor = '#fff',\n            outlineColor = '#fff'\n        } = this.options;\n        return [{\n            selector: 'handle',\n            tagName: 'g',\n            attributes: {\n                cursor: 'grab',\n            },\n            children: [{\n                tagName: 'circle',\n                attributes: {\n                    r: 10,\n                    fill: buttonColor,\n                    stroke: outlineColor,\n                },\n            }, {\n                tagName: 'path',\n                attributes: {\n                    d: 'M -5 0 A 5 5 0 1 1 0 5',\n                    fill: 'transparent',\n                    stroke: iconColor,\n                    strokeWidth: 2,\n                    strokeLinecap: 'round',\n                },\n            }, {\n                tagName: 'path',\n                attributes: {\n                    d: 'M -3 5 L 0 2.5 0 7.5 Z',\n                    fill: iconColor,\n                    stroke: iconColor,\n                    strokeWidth: 1,\n                    transform: 'rotate(-5, -3, 5)',\n                }\n            }]\n        }];\n    },\n\n    getPosition(view) {\n        const { offset = 0 } = this.options;\n        const { x = 0, y = 0 } = typeof offset === 'number' ? { x: 0, y: offset } : offset;\n        const label = this.getLabel();\n        const labelPosition = this.getLabelPosition(label);\n        const coords = view.getLabelCoordinates(labelPosition);\n        let { angle = 0, args = {}} = labelPosition;\n        const keepGradient = args.keepGradient;\n        if (keepGradient) {\n            const tangent = view.getTangentAtRatio(\n                view.getClosestPointRatio(coords)\n            );\n            if (tangent) {\n                // link slope angle\n                angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;\n            }\n        }\n        const matrix = new DOMMatrix()\n            .translate(coords.x, coords.y)\n            .rotate(angle)\n            .translate(x, y);\n        return new g.Point(matrix.e, matrix.f);\n    },\n\n    // Override the default `computeVisibility` method to hide the tool if the label is not present.\n    computeVisibility() {\n        const visibility = Control.prototype.computeVisibility.apply(this, arguments);\n        return visibility && !!this.getLabel();\n    },\n\n    setPosition(view, coordinates) {\n        const model = view.model;\n        const label = this.getLabel();\n        if (!label) return;\n        const labelPosition = this.getLabelPosition(label);\n        const position = view.getLabelCoordinates(labelPosition);\n        const angle = 90 - position.theta(coordinates);\n        const index = this.getLabelIndex();\n        model.prop(['labels', index, 'position', 'angle'], angle);\n    },\n\n    resetPosition(view) {\n        const model = view.model;\n        const index = this.getLabelIndex();\n        model.prop(['labels', index, 'position', 'angle'], 0);\n    },\n\n    getLabelIndex() {\n        return this.options.labelIndex || 0;\n    },\n\n    getLabel() {\n        return this.relatedView.model.label(this.getLabelIndex()) || null;\n    },\n\n    getLabelPosition(label) {\n        const view = this.relatedView;\n        const labelPosition = view._normalizeLabelPosition(label.position);\n        return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());\n    },\n\n});\n", "import { ToolView } from '../dia/ToolView.mjs';\nimport { getViewBBox } from './helpers.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\n\nexport const Button = ToolView.extend({\n    name: 'button',\n    events: {\n        'mousedown': 'onPointerDown',\n        'touchstart': 'onPointerDown'\n    },\n    options: {\n        distance: 0,\n        offset: 0,\n        scale: null,\n        rotate: false\n    },\n    onRender: function() {\n        this.renderChildren(this.options.markup);\n        this.update();\n    },\n    update: function() {\n        this.position();\n        return this;\n    },\n    position: function() {\n        const { vel } = this;\n        vel.transform(this.getCellMatrix(), { absolute: true });\n    },\n    getCellMatrix() {\n        return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n    },\n    getElementMatrix() {\n        const { relatedView: view, options } = this;\n        let { x = 0, y = 0, offset = {}, useModelGeometry, rotate, scale } = options;\n        let bbox = getViewBBox(view, useModelGeometry);\n        const angle = view.model.angle();\n        if (!rotate) bbox = bbox.bbox(angle);\n        const { x: offsetX = 0, y: offsetY = 0 } = offset;\n        if (util.isPercentage(x)) {\n            x = parseFloat(x) / 100 * bbox.width;\n        } else if (util.isCalcExpression(x)) {\n            x = Number(util.evalCalcExpression(x, bbox));\n        }\n        if (util.isPercentage(y)) {\n            y = parseFloat(y) / 100 * bbox.height;\n        } else if (util.isCalcExpression(y)) {\n            y = Number(util.evalCalcExpression(y, bbox));\n        }\n        let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n        if (rotate) matrix = matrix.rotate(angle);\n        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n    getLinkMatrix() {\n        const { relatedView: view, options } = this;\n        const { offset = 0, distance: distanceOpt = 0, rotate, scale } = options;\n        const distance = (typeof distanceOpt === 'function')\n            ? distanceOpt.call(this, view, this)\n            : distanceOpt;\n        let tangent, position, angle;\n        if (util.isPercentage(distance)) {\n            tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n        } else {\n            tangent = view.getTangentAtLength(distance);\n        }\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(new g.Point(1, 0)) || 0;\n        } else {\n            position = view.getConnection().start;\n            angle = 0;\n        }\n        let matrix = V.createSVGMatrix()\n            .translate(position.x, position.y)\n            .rotate(angle)\n            .translate(0, offset);\n        if (!rotate) matrix = matrix.rotate(-angle);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var actionFn = this.options.action;\n        if (typeof actionFn === 'function') {\n            actionFn.call(this.relatedView, evt, this.relatedView, this);\n        }\n    }\n});\n\nexport const Remove = Button.extend({\n    name: 'remove',\n    children: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#FF1D00',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -3 -3 3 3 M -3 3 3 -3',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    options: {\n        distance: 60,\n        offset: 0,\n        action: function(evt, view, tool) {\n            view.model.remove({ ui: true, tool: tool.cid });\n        }\n    }\n});\n", "\nimport * as util from '../util/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\nimport { getViewBBox } from './helpers.mjs';\n\nexport const Boundary = ToolView.extend({\n    name: 'boundary',\n    tagName: 'rect',\n    options: {\n        padding: 10,\n        useModelGeometry: false,\n    },\n    attributes: {\n        'fill': 'none',\n        'stroke': '#33334F',\n        'stroke-width': .5,\n        'stroke-dasharray': '5, 5',\n        'pointer-events': 'none'\n    },\n    onRender: function() {\n        this.update();\n    },\n    update: function() {\n        const { relatedView: view, options, vel } = this;\n        const { useModelGeometry, rotate } = options;\n        const padding = util.normalizeSides(options.padding);\n        let bbox = getViewBBox(view, useModelGeometry).moveAndExpand({\n            x: -padding.left,\n            y: -padding.top,\n            width: padding.left + padding.right,\n            height: padding.top + padding.bottom\n        });\n        var model = view.model;\n        if (model.isElement()) {\n            var angle = model.angle();\n            if (angle) {\n                if (rotate) {\n                    var origin = model.getBBox().center();\n                    vel.rotate(angle, origin.x, origin.y, { absolute: true });\n                } else {\n                    bbox = bbox.bbox(angle);\n                }\n            }\n        }\n        vel.attr(bbox.toJSON());\n        return this;\n    }\n});\n", "import { Button } from './Button.mjs';\nimport * as util from '../util/index.mjs';\n\nexport const Connect = Button.extend({\n    name: 'connect',\n    documentEvents: {\n        mousemove: 'drag',\n        touchmove: 'drag',\n        mouseup: 'dragend',\n        touchend: 'dragend',\n        touchcancel: 'dragend'\n    },\n    children: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#333333',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n            'fill': '#FFFFFF',\n            'stroke': 'none',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    options: {\n        distance: 80,\n        offset: 0,\n        magnet: (view) => view.el,\n        action: (evt, _view, tool) => tool.dragstart(evt),\n    },\n    getMagnetNode: function() {\n        const { options, relatedView } = this;\n        const { magnet } = options;\n        let magnetNode;\n        switch (typeof magnet) {\n            case 'function': {\n                magnetNode = magnet.call(this, relatedView, this);\n                break;\n            }\n            case 'string': {\n                magnetNode = relatedView.findNode(magnet);\n                break;\n            }\n            default: {\n                magnetNode = magnet;\n                break;\n            }\n        }\n        if (!magnetNode) magnetNode = relatedView.el;\n        if (magnetNode instanceof SVGElement) return magnetNode;\n        throw new Error('Connect: magnet must be an SVGElement');\n    },\n    dragstart: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = util.normalizeEvent(evt);\n        const { x, y } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n        paper.undelegateEvents();\n        this.delegateDocumentEvents(null, normalizedEvent.data);\n        this.focus();\n    },\n    drag: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = util.normalizeEvent(evt);\n        const { x, y } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLink(normalizedEvent, x, y);\n    },\n    dragend: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = util.normalizeEvent(evt);\n        const { x, y } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLinkEnd(normalizedEvent, x, y);\n        this.undelegateDocumentEvents();\n        paper.delegateEvents();\n        this.blur();\n        relatedView.checkMouseleave(normalizedEvent);\n    }\n});\n", "import { Connect } from './Connect.mjs';\nimport V from '../V/index.mjs';\nimport $ from '../mvc/Dom/index.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nexport const HoverConnect = Connect.extend({\n\n    name: 'hover-connect',\n\n    defaultMarkup: [\n        {\n            tagName: 'circle',\n            attributes: {\n                'r': 7,\n                'fill': '#333333',\n                'cursor': 'pointer'\n            }\n        },\n        {\n            tagName: 'path',\n            attributes: {\n                'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n                'fill': '#FFFFFF',\n                'stroke': 'none',\n                'stroke-width': 2\n            }\n        }\n    ],\n\n    children() {\n        const { options, defaultMarkup } = this;\n        return [\n            {\n                tagName: 'path',\n                selector: 'track',\n                attributes: {\n                    'fill': 'none',\n                    'stroke': 'transparent',\n                    'stroke-width': options.trackWidth || 15,\n                    'cursor': 'pointer'\n                }\n            },\n            {\n                tagName: 'g',\n                selector: 'button',\n                attributes: {\n                    'pointer-events': 'none',\n                    'display': 'none'\n                },\n                children: options.markup || defaultMarkup\n            }\n        ];\n    },\n\n    events: Object.assign({\n        mousemove: 'onMousemove',\n        mouseenter: 'onMouseenter',\n        mouseleave: 'onMouseleave'\n    }, Connect.prototype.events),\n\n    onRender: function() {\n        this.renderChildren();\n        this.update();\n    },\n\n    trackPath: null,\n\n    update() {\n        const { childNodes } = this;\n        this.trackPath = this.getTrackPath();\n        Connect.prototype.update.apply(this, arguments);\n        childNodes.track.setAttribute(\n            'd',\n            this.trackPath.serialize()\n        );\n    },\n\n    position() {\n        const { el, childNodes } = this;\n        childNodes.button.setAttribute(\n            'transform',\n            V.matrixToTransformString(this.getButtonMatrix())\n        );\n        el.setAttribute(\n            'transform',\n            V.matrixToTransformString(this.getTrackMatrix())\n        );\n    },\n\n    getButtonMatrix() {\n        const { options, trackPath } = this;\n        const { offset = 0, distance = 0, rotate, scale } = options;\n        let tangent, position, angle;\n        if (util.isPercentage(distance)) {\n            tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n        } else {\n            tangent = trackPath.tangentAtLength(distance);\n        }\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(new g.Point(1, 0)) || 0;\n        } else {\n            position = trackPath.start;\n            angle = 0;\n        }\n        let matrix = V.createSVGMatrix()\n            .translate(position.x, position.y)\n            .rotate(angle)\n            .translate(0, offset);\n        if (!rotate) matrix = matrix.rotate(-angle);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n\n    getTrackPath() {\n        return this.relatedView.getConnection();\n    },\n\n    getTrackMatrix() {\n        return V.createSVGMatrix();\n    },\n\n    getTrackRatioFromEvent(evt) {\n        const { relatedView, trackPath } = this;\n        const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n        const trackPoint = V.transformPoint(localPoint, this.getTrackMatrix().inverse());\n        return trackPath.closestPointLength(trackPoint);\n    },\n\n    canShowButton() {\n        // Has been the paper events undelegated? If so, we can't show the button.\n        // TODO: add a method to the paper to check if the events are delegated.\n        return $.event.has(this.paper.el);\n    },\n\n    showButton() {\n        this.childNodes.button.style.display = 'block';\n    },\n\n    hideButton() {\n        this.childNodes.button.style.display = '';\n    },\n\n    onMousemove(evt) {\n        const { trackPath } = this;\n        if (!trackPath) return;\n        const { options } = this;\n        options.distance = this.getTrackRatioFromEvent(evt);\n        this.position();\n    },\n\n    onMouseenter() {\n        if (!this.canShowButton()) return;\n        this.showButton();\n    },\n\n    onMouseleave() {\n        this.hideButton();\n    }\n});\n", "export { HoverConnect } from './HoverConnect.mjs';\n\nexport { Button, Remove } from '../cellTools/Button.mjs';\nexport { Connect } from '../cellTools/Connect.mjs';\nexport { Boundary } from '../cellTools/Boundary.mjs';\nexport { Control } from '../cellTools/Control.mjs';\n", "import { HoverConnect as LinkHoverConnect } from '../cellTools/HoverConnect.mjs';\nimport V from '../V/index.mjs';\nimport * as g from '../g/index.mjs';\nimport { isCalcExpression, evalCalcExpression } from '../util/calc.mjs';\nimport { getViewBBox } from '../cellTools/helpers.mjs';\n\nexport const HoverConnect = LinkHoverConnect.extend({\n\n    getTrackPath() {\n        const { relatedView: view, options } = this;\n        let {\n            useModelGeometry,\n            trackPath =  'M 0 0 H calc(w) V calc(h) H 0 Z'\n        } = options;\n        if (typeof trackPath === 'function') {\n            trackPath = trackPath.call(this, view);\n        }\n        if (isCalcExpression(trackPath)) {\n            const bbox = getViewBBox(view, useModelGeometry);\n            trackPath = evalCalcExpression(trackPath, bbox);\n        }\n        return new g.Path(V.normalizePathData(trackPath));\n    },\n\n    getTrackMatrix() {\n        const { relatedView: view, options } = this;\n        let { useModelGeometry, rotate } = options;\n        let bbox = getViewBBox(view, useModelGeometry);\n        const angle = view.model.angle();\n        if (!rotate) bbox = bbox.bbox(angle);\n        let matrix = V.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n        if (rotate) matrix = matrix.rotate(angle);\n        matrix = matrix.translate(- bbox.width / 2, - bbox.height / 2);\n        return matrix;\n    }\n\n});\n", "var version = \"4.1.3\";\n\nexport { version };\n", "import * as connectors from './connectors/index.mjs';\nimport * as highlighters from './highlighters/index.mjs';\nimport * as connectionPoints from './connectionPoints/index.mjs';\nimport * as connectionStrategies from './connectionStrategies/index.mjs';\nimport * as routers from './routers/index.mjs';\nimport * as anchors from './anchors/index.mjs';\nimport * as linkAnchors from './linkAnchors/index.mjs';\nimport * as dia from './dia/index.mjs';\nimport * as linkTools from './linkTools/index.mjs';\nimport * as elementTools from './elementTools/index.mjs';\nimport * as util from './util/index.mjs';\nimport * as mvc from './mvc/index.mjs';\nimport * as g from './g/index.mjs';\nimport { config } from './config/index.mjs';\nimport V from './V/index.mjs';\nimport * as Port from './layout/ports/port.mjs';\nimport * as PortLabel from './layout/ports/portLabel.mjs';\n\nexport * from '../dist/version.mjs';\nexport const Vectorizer = V;\nexport const layout = { PortLabel, Port };\nexport { env } from './env/index.mjs';\nexport {\n    config,\n    anchors,\n    linkAnchors,\n    connectionPoints,\n    connectionStrategies,\n    connectors,\n    dia,\n    highlighters,\n    mvc,\n    routers,\n    util,\n    linkTools,\n    elementTools,\n    V,\n    g\n};\nexport const setTheme = function(theme, opt) {\n\n    opt = opt || {};\n\n    util.invoke(mvc.views, 'setTheme', theme, opt);\n\n    // Update the default theme on the view prototype.\n    mvc.View.prototype.defaultTheme = theme;\n};\n"],
  "mappings": "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",
  "names": ["Ellipse", "Link", "Path", "Polygon", "Polyline", "min", "max", "cos", "sin", "atan2", "round", "PI", "closest", "point", "offset", "length", "scale", "max", "min", "left", "top", "right", "bottom", "length", "intersection", "line", "determinant", "sqrt", "round", "pow", "rect", "ellipse", "line", "diff", "result", "point", "center", "abs", "cos", "sin", "min", "max", "round", "pow", "width", "height", "line", "center", "result", "intersection", "rect", "scale", "point", "closest", "point", "abs", "rect", "point", "length", "line", "abs", "sqrt", "min", "max", "pow", "left", "top", "right", "bottom", "length", "point", "bbox", "length", "line", "intersection", "curve", "data", "curve", "rect", "line2", "ellipse", "line", "sqrt", "ellipse2", "rect", "width", "height", "length", "cos", "sin", "PI", "atan2", "sqrt", "min", "max", "cos", "sin", "V", "children", "offset", "line", "ns", "attributes", "parent", "clone", "className", "svg", "bbox", "center", "position", "scale", "length", "width", "height", "rect", "documentElement", "data", "point", "attr", "ellipse", "math", "abs", "_13", "_23", "a", "b", "path", "pcom", "i", "result", "length", "props", "data", "othValue", "set", "values", "array", "cacheHas", "key", "collection", "defaultsDeep", "wait", "intersection", "data", "props", "document", "matches", "types", "data", "fn", "one", "special", "type", "clone", "clone", "html", "parent", "matches", "children", "closest", "types", "data", "fn", "height", "width", "offset", "el", "position", "rect", "attributes", "attr", "value", "className", "svg", "attributes", "keys", "length", "last", "value", "stop", "property", "max", "validUnitExp", "matches", "word", "width", "height", "words", "data", "html", "xhr", "callback", "bbox", "attrs", "top", "right", "bottom", "left", "cb", "b", "align", "scale", "i", "d", "attr", "el", "prop", "diff", "result", "length", "extend", "parent", "length", "methods", "attributes", "attr", "unset", "diff", "extend", "clone", "parent", "props_default", "point", "fn", "props", "rect", "property", "width", "height", "expression", "width", "height", "offset", "stroke", "filter", "point", "html", "props_default", "attributes", "defaults", "finalAttributes", "parent", "clone", "props", "property", "options", "point", "defaultsDeep", "Cell", "defaultsDeep", "intersection", "methods", "fn", "document", "svg", "attributes", "className", "children", "node", "rect", "position", "ellipse", "line", "point", "ports", "center", "ellipse", "bbox", "line", "bottom", "left", "right", "top", "defaultsDeep", "center", "offset", "round", "left", "right", "top", "bottom", "data", "position", "result", "Element", "parent", "position", "bbox", "width", "height", "center", "left", "right", "top", "bottom", "absolute", "attributes", "router", "fn", "attributes", "fn", "result", "Element", "Ellipse", "Path", "Polygon", "Polyline", "data", "Link", "_13", "_23", "line2", "point", "line", "intersection", "diff", "offset", "CORNER_RADIUS", "PRECISION", "last", "curve", "cos", "sin", "addClass", "attributes", "extend", "children", "className", "data", "cb", "length", "set", "merge", "remove", "fn", "config", "methods", "extend", "toArray", "attributes", "views", "width", "height", "fn", "addClass", "Directions", "offset", "length", "position", "width", "height", "left", "right", "top", "bottom", "bbox", "offset", "line", "length", "stroke", "align", "bbox", "center", "intersection", "anchor", "data", "absolute", "max", "fn", "bbox", "length", "normal", "normal", "bbox", "bearing", "boundary", "max", "config", "bbox", "point", "getSourceBBox", "getTargetBBox", "getSourceAnchor", "getTargetAnchor", "diff", "snapToGrid", "round", "parent", "min", "anchor", "keys", "key", "config", "point", "Directions", "line", "width", "height", "anchor", "point", "bbox", "x", "y", "toDirection", "isVertexInside", "bottom", "left", "right", "top", "length", "fn", "bbox", "anchor", "topLeft", "bottomRight", "center", "top", "bottom", "left", "right", "Element", "children", "model", "exists", "links", "point", "bbox", "rect", "width", "height", "data", "list", "attributes", "bbox", "rect", "position", "data", "attrName", "scale", "item", "point", "parent", "Flags", "width", "height", "data", "max", "parent", "position", "Flags", "attributes", "children", "labelMarkup", "point", "anchor", "line", "bbox", "position", "vToken", "callback", "router", "data", "length", "normal", "setOptions", "magnet", "view", "paper", "width", "height", "HighlightingTypes", "position", "data", "defaultsDeep", "svg", "css", "scale", "point", "empty", "flag", "width", "height", "views", "rect", "deltaY", "evt", "filter", "offset", "opacity", "radians", "opacity", "views", "scale", "scale", "line", "anchor", "position", "data", "offset", "length", "position", "scale", "data", "position", "bbox", "center", "anchor", "scale", "bbox", "center", "offset", "position", "offset", "scale", "bbox", "position", "bbox", "offset", "scale", "position", "HoverConnect", "HoverConnect", "bbox"]
}
